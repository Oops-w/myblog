<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>树结构实际应用 | w</title><meta name="keywords" content="数据结构,Tree"><meta name="author" content="w"><meta name="copyright" content="w"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="1.堆排序1.1堆排序基本介绍 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复 杂度均为 O(nlogn)，它也是不稳定排序。  堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有 要求结点的左孩子的值和右孩子的值的大小关系。  每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆  大顶堆举例">
<meta property="og:type" content="article">
<meta property="og:title" content="树结构实际应用">
<meta property="og:url" content="http://oopsw.top/2021/01/25/%E6%A0%91%E7%BB%93%E6%9E%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/index.html">
<meta property="og:site_name" content="w">
<meta property="og:description" content="1.堆排序1.1堆排序基本介绍 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复 杂度均为 O(nlogn)，它也是不稳定排序。  堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有 要求结点的左孩子的值和右孩子的值的大小关系。  每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆  大顶堆举例">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://oopsw.top/img/8.jpg">
<meta property="article:published_time" content="2021-01-25T07:46:12.000Z">
<meta property="article:modified_time" content="2021-01-30T10:26:03.360Z">
<meta property="article:author" content="w">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="Tree">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://oopsw.top/img/8.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://oopsw.top/2021/01/25/%E6%A0%91%E7%BB%93%E6%9E%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: w","link":"链接: ","source":"来源: w","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-01-30 18:26:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><style>#article-container.post-content h1:before, h2:before, h3:before, h4:before, h5:before, h6:before { -webkit-animation: avatar_turn_around 1s linear infinite; -moz-animation: avatar_turn_around 1s linear infinite; -o-animation: avatar_turn_around 1s linear infinite; -ms-animation: avatar_turn_around 1s linear infinite; animation: avatar_turn_around 1s linear infinite; }</style><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我的</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/8.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">w</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我的</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">树结构实际应用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-25T07:46:12.000Z" title="发表于 2021-01-25 15:46:12">2021-01-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-01-30T10:26:03.360Z" title="更新于 2021-01-30 18:26:03">2021-01-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Tree/">Tree</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-堆排序"><a href="#1-堆排序" class="headerlink" title="1.堆排序"></a>1.堆排序</h2><h3 id="1-1堆排序基本介绍"><a href="#1-1堆排序基本介绍" class="headerlink" title="1.1堆排序基本介绍"></a>1.1堆排序基本介绍</h3><ol>
<li><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复 杂度均为 O(nlogn)，它也是不稳定排序。</p>
</li>
<li><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有 要求结点的左孩子的值和右孩子的值的大小关系。</p>
</li>
<li><p>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</p>
</li>
<li><p>大顶堆举例说明<img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154133.png" alt="image-20210125153328527"></p>
</li>
<li><p>小顶堆举例说明<img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154134.png" alt="image-20210125153342184"></p>
</li>
<li><p>一般升序采用大顶堆，降序采用小顶堆</p>
</li>
</ol>
<h3 id="1-2堆排序基本思想"><a href="#1-2堆排序基本思想" class="headerlink" title="1.2堆排序基本思想"></a>1.2堆排序基本思想</h3><p>堆排序的基本思想是:</p>
<ol>
<li>将待排序序列构造成一个大顶堆</li>
<li>此时，整个序列的最大值就是堆顶的根节点。</li>
<li>将其与末尾元素进行交换，此时末尾就为最大值。</li>
<li>然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序 序列了。</li>
</ol>
<p>可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了</p>
<h3 id="1-3堆排序步骤图解说明"><a href="#1-3堆排序步骤图解说明" class="headerlink" title="1.3堆排序步骤图解说明"></a>1.3堆排序步骤图解说明</h3><p>要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。</p>
<blockquote>
<p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。 原始的数组 [4, 6, 8, 5, 9] 1) .假设给定无序序列结构如下</strong></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154135.png" alt="image-20210125153459770"></p>
<p>此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154136.png" alt="image-20210125153527868"></p>
<p>找到第二个非叶节点 4，由于[4,9,8]中 9 元素最大，4 和 9 交换。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154137.png" alt="image-20210125153541179"></p>
<p>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154138.png" alt="image-20210125153550700"></p>
<p>此时，我们就将一个无序序列构造成了一个大顶堆。</p>
<p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p>
<p>将堆顶元素 9 和末尾元素 4 进行交换</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154139.png" alt="image-20210125153629892"></p>
<p>重新调整结构，使其继续满足堆定义</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154140.png" alt="image-20210125153638314"></p>
<p>再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8.</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154141.png" alt="image-20210125153647101"></p>
<p>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154142.png" alt="image-20210125153655194"></p>
<p><strong>再简单总结下堆排序的基本思路：</strong></p>
<ol>
<li>.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</li>
<li>.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</li>
<li>.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤， 直到整个序列有序</li>
</ol>
</blockquote>
<h3 id="1-4堆排序代码实现"><a href="#1-4堆排序代码实现" class="headerlink" title="1.4堆排序代码实现"></a>1.4堆排序代码实现</h3><p>要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。</p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-25 14:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            swap(arr,<span class="number">0</span>,j);<span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt;temp)&#123;<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-赫夫曼树"><a href="#2-赫夫曼树" class="headerlink" title="2.赫夫曼树"></a>2.赫夫曼树</h2><h3 id="2-1基本介绍"><a href="#2-1基本介绍" class="headerlink" title="2.1基本介绍"></a>2.1基本介绍</h3><ol>
<li>给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，<strong>若该树的带权路径长度(wpl)达到最小，</strong>称这样的二叉树为 最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。</li>
<li>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近</li>
</ol>
<h3 id="2-2赫夫曼树几个重要概念和举例说明"><a href="#2-2赫夫曼树几个重要概念和举例说明" class="headerlink" title="2.2赫夫曼树几个重要概念和举例说明"></a>2.2赫夫曼树几个重要概念和举例说明</h3><ol>
<li><strong>路径和路径长度</strong>：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。<strong>通路中分支的数目称为路径长度。</strong>若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1</li>
<li><strong>结点的权及带权路径长度</strong>：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。<strong>结点的带权路径长度为</strong>：从根结点到该结点之间的路径长度与该结点的权的乘积</li>
<li>树的带权路径长度：树的带权路径长度规定为<strong>所有叶子结点的带权路径长度之和，</strong>记为 <strong>WPL(weighted path length)</strong> ,权值越大的结点离根结点越近的二叉树才是最优二叉树。</li>
<li>WPL 最小的就是赫夫曼树</li>
</ol>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154143.png" alt="image-20210125153956963"></p>
<h3 id="2-3赫夫曼树创建思路图解"><a href="#2-3赫夫曼树创建思路图解" class="headerlink" title="2.3赫夫曼树创建思路图解"></a>2.3赫夫曼树创建思路图解</h3><p>给你一个数列 {13, 7, 8, 3, 29, 6, 1}，要求转成一颗赫夫曼树. </p>
<ul>
<li><p>思路分析(示意图)：</p>
<p>{13, 7, 8, 3, 29, 6, 1}</p>
<p><strong>构成赫夫曼树的步骤：</strong></p>
</li>
</ul>
<ol>
<li>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</li>
<li>取出根节点权值最小的两颗二叉树</li>
<li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</li>
<li>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数 据都被处理，就得到一颗赫夫曼树</li>
<li>图解:</li>
</ol>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154144.png" alt="image-20210125154103500"></p>
<h3 id="2-4赫夫曼树的代码实现"><a href="#2-4赫夫曼树的代码实现" class="headerlink" title="2.4赫夫曼树的代码实现"></a>2.4赫夫曼树的代码实现</h3><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.huffman;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-25 15:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 哈夫曼树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">29</span>, <span class="number">6</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Node root = createHuffmanTree(arr);</span><br><span class="line">        preOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        root.preOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建哈夫曼树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> root节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先将数组中所有数值创建成节点并加入到list集合中</span></span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> Node(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环创建子树</span></span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//首先对集合中进行排序</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            <span class="comment">//取出最小的两个节点</span></span><br><span class="line">            Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line">            Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//创建新的根节点</span></span><br><span class="line">            Node parant = <span class="keyword">new</span> Node(leftNode.value + rightNode.value);</span><br><span class="line">            parant.left = leftNode;</span><br><span class="line">            parant.right = rightNode;</span><br><span class="line">            <span class="comment">//从集合中删除取出来的两个节点</span></span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            <span class="comment">//添加新创建的节点</span></span><br><span class="line">            nodes.add(parant);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node.value);</span><br><span class="line">        preOrder(node.left);</span><br><span class="line">        preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value - o.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-赫夫曼编码"><a href="#3-赫夫曼编码" class="headerlink" title="3.赫夫曼编码"></a>3.赫夫曼编码</h2><h3 id="3-1基本介绍"><a href="#3-1基本介绍" class="headerlink" title="3.1基本介绍"></a>3.1基本介绍</h3><ol>
<li>赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法</li>
<li>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</li>
<li>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在 20%～90%之间</li>
<li>赫夫曼码是可变字长编码(VLC)的一种。Huffman 于 1952 年提出一种编码方法，称之为最佳编码</li>
</ol>
<h3 id="3-2原理剖析"><a href="#3-2原理剖析" class="headerlink" title="3.2原理剖析"></a>3.2原理剖析</h3><ul>
<li><p>通信领域中信息的处理方式 1-定长编码<img src="https://gitee.com/Pink_oops/image/raw/master/20210130144533.png" alt="image-20210126162836670"></p>
</li>
<li><p>通信领域中信息的处理方式 2-变长编码<img src="https://gitee.com/Pink_oops/image/raw/master/20210130144534.png" alt="image-20210126162849216"></p>
</li>
<li><p>通信领域中信息的处理方式 3-赫夫曼编码</p>
<p>步骤如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130144535.png" alt="image-20210126163131417"></p>
</li>
</ul>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130144536.png" alt="image-20210126163141984"></p>
<p>长度为 ： 133 </p>
<p>说明: 原来长度是 359 , 压缩了 (359-133) / 359 = 62.9%  </p>
<p>此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性 赫夫曼编码是无损处理方案</p>
<p><strong>注意事项：</strong></p>
<p>注意, 这个赫夫曼树根据<strong>排序方法不同</strong>，也可能不太一样，这样对应的<strong>赫夫曼编码也不完全一样</strong>，但是 <strong>wpl 是 一样的</strong>，都是最小的, 最后生成的赫夫曼编码的长度是一样，比如: 如果我们让每次生成的新的二叉树总是排在权 值相同的二叉树的最后一个，则生成的二叉树为:</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130144537.png" alt="image-20210126163251087"></p>
<h3 id="3-3最佳实践-数据压缩"><a href="#3-3最佳实践-数据压缩" class="headerlink" title="3.3最佳实践-数据压缩"></a>3.3最佳实践-数据压缩</h3><p>将给出的一段文本，比如 “i like like like java do you like a java” ， 根据前面的讲的赫夫曼编码原理，对其进行数 据 压 缩 处 理 ， 形 式 如 “1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100 110111101111011100100001100001110 “</p>
<ol>
<li>根据赫夫曼编码压缩数据的原理，需要创建 “i like like like java do you like a java” 对应的赫夫曼树.</li>
<li>生成赫夫曼树对应的赫夫曼编码 , 如下表: =01 a=100 d=11000 u=11001 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000 o=0011</li>
<li>使用赫夫曼编码来生成赫夫曼编码数据 ,即按照上面的赫夫曼编码，将”i like like like java do you like a java  字符串生成对应的编码数据, 形式如下. 10101000101111111100100010111111110010001011111111001001010011011100011100000110111010001111001010 00101111111100110001001010011011100</li>
<li>使用赫夫曼编码来解码数据</li>
<li>来完成对文件的压缩</li>
<li>来完成对文件的解压</li>
</ol>
<h3 id="3-4赫夫曼编码压缩文件注意事项"><a href="#3-4赫夫曼编码压缩文件注意事项" class="headerlink" title="3.4赫夫曼编码压缩文件注意事项"></a>3.4赫夫曼编码压缩文件注意事项</h3><ol>
<li>如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件 [举例压一个 .ppt]</li>
<li>赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件) [举例压一个.xml 文件]</li>
<li>如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显.</li>
</ol>
<h2 id="4-二叉排序树"><a href="#4-二叉排序树" class="headerlink" title="4.二叉排序树"></a>4.二叉排序树</h2><h3 id="3-1先看一个需求"><a href="#3-1先看一个需求" class="headerlink" title="3.1先看一个需求"></a>3.1先看一个需求</h3><p>给你一个数列 (7, 3, 10, 12, 5, 1, 9)，要求能够高效的完成对数据的查询和添加 </p>
<h3 id="3-2解决方案分析"><a href="#3-2解决方案分析" class="headerlink" title="3.2解决方案分析"></a>3.2解决方案分析</h3><ul>
<li><p>使用数组</p>
<p>数组未排序， 优点：直接在数组尾添加，速度快。 缺点：查找速度慢. [示意图] </p>
<p>数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位 </p>
<p>置后，后面的数据需整体移动，速度慢。[示意图]</p>
</li>
<li><p>使用链式存储-链表 </p>
<p>不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动。</p>
</li>
<li><p>使用二叉排序树</p>
</li>
</ul>
<h3 id="4-3二叉排序树介绍"><a href="#4-3二叉排序树介绍" class="headerlink" title="4.3二叉排序树介绍"></a>4.3二叉排序树介绍</h3><p><strong>二叉排序树</strong>：BST: (Binary Sort(Search) Tree), 对于二叉排序树的<strong>任何一个非叶子节点</strong>，要求<strong>左子节点的值比当</strong> </p>
<p><strong>前节点的值小</strong>，<strong>右子节点的值比当前节点的值大</strong>。 </p>
<p><strong>特别说明</strong>：如果有相同的值，可以将该节点放在左子节点或右子节点 </p>
<p>比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130144538.png" alt="image-20210130140018262"></p>
<h3 id="4-4二叉排序树创建和遍历"><a href="#4-4二叉排序树创建和遍历" class="headerlink" title="4.4二叉排序树创建和遍历"></a>4.4二叉排序树创建和遍历</h3><p>一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如: 数组为 Array(7, 3, 10, 12, 5, 1, 9) ， 创 </p>
<p>建成对应的二叉排序树为 : </p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130144539.png" alt="image-20210130140047802"></p>
<h3 id="4-5二叉排序树的删除"><a href="#4-5二叉排序树的删除" class="headerlink" title="4.5二叉排序树的删除"></a>4.5二叉排序树的删除</h3><p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑 </p>
<ol>
<li><p><strong>删除叶子节点</strong> (比如：2, 5, 9, 12)</p>
</li>
<li><p>删除<strong>只有一颗子树的节点</strong> (比如：1)</p>
</li>
<li><p>删除<strong>有两颗子树的节点</strong>. (比如：7, 3，10 )</p>
</li>
<li><p>操作的思路分析</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130144540.png" alt="image-20210130140144676"></p>
</li>
</ol>
<p>//对删除结点的各种情况的思路分析: </p>
<p>第一种情况: </p>
<p>删除叶子节点 (比如：2, 5, 9, 12) </p>
<p>思路</p>
<p>(1) 需求先去找到要删除的结点 targetNode </p>
<p>(2) 找到 targetNode 的 父结点 parent </p>
<p>(3) 确定 targetNode 是 parent 的左子结点 还是右子结点 </p>
<p>(4) 根据前面的情况来对应删除 </p>
<p>左子结点 parent.left = null </p>
<p>右子结点 parent.right = null; </p>
<p>第二种情况: 删除只有一颗子树的节点 比如 1 </p>
<p>思路</p>
<p>(1) 需求先去找到要删除的结点 targetNode </p>
<p>(2) 找到 targetNode 的 父结点 parent </p>
<p>(3) 确定 targetNode 的子结点是左子结点还是右子结点 </p>
<p>(4) targetNode 是 parent 的左子结点还是右子结点 </p>
<p>(5) 如果 targetNode 有左子结点</p>
<p>5.1 如果 targetNode 是 parent 的左子结点</p>
<p>parent.left = targetNode.left; </p>
<p>5.2 如果 targetNode 是 parent 的右子结点 </p>
<p>parent.right = targetNode.left; </p>
<p>(6) 如果 targetNode 有右子结点 </p>
<p>6.1 如果 targetNode 是 parent 的左子结点 </p>
<p>parent.left = targetNode.right; </p>
<p>6.2 如果 targetNode 是 parent 的右子结点 </p>
<p>parent.right = targetNode.right </p>
<p>情况三 ： 删除有两颗子树的节点. (比如：7, 3，10 ) </p>
<p>思路</p>
<p>(1) 需求先去找到要删除的结点 targetNode </p>
<p>(2) 找到 targetNode 的 父结点 parent </p>
<p>(3) 从 targetNode 的右子树找到最小的结点 </p>
<p>(4) 用一个临时变量，将 最小结点的值保存 temp = 11 </p>
<p>(5) 删除该最小结点 </p>
<p>(6) targetNode.value = temp </p>
<h3 id="4-6二叉排序树删除节点的代码实现"><a href="#4-6二叉排序树删除节点的代码实现" class="headerlink" title="4.6二叉排序树删除节点的代码实现"></a>4.6二叉排序树删除节点的代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.binarysorttree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-26 16:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 二叉排序树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            binarySortTree.add(<span class="keyword">new</span> Node(i));</span><br><span class="line">        &#125;</span><br><span class="line">        binarySortTree.midOrder();</span><br><span class="line"><span class="comment">//        binarySortTree.delNode(2);</span></span><br><span class="line">        binarySortTree.delNode(<span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">        binarySortTree.midOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root.midOrder(<span class="keyword">this</span>.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除右子树中最小的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root  根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  被删除的节点的value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">delRightTreeMinNode</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Node temp = root;</span><br><span class="line">        <span class="comment">//因为是二叉排序树所以左子树的值一定比根节点和右子树小 所以一直往左找 找到最左的节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除该节点</span></span><br><span class="line">        delNode(temp.value);</span><br><span class="line">        <span class="keyword">return</span> temp.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先获得要删除的节点</span></span><br><span class="line">        Node node = <span class="keyword">this</span>.root.search(value);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断root节点是需要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root.left == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.root.right == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.root.value == value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得父节点</span></span><br><span class="line">        Node parent = <span class="keyword">this</span>.root.searchParent(value);</span><br><span class="line">        <span class="comment">//判断需要删除的节点是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是父节点的左子节点还是右子节点</span></span><br><span class="line">            <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == node.value) &#123;</span><br><span class="line">                <span class="comment">//左子节点</span></span><br><span class="line">                parent.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == node.value) &#123;</span><br><span class="line">                <span class="comment">//右子节点</span></span><br><span class="line">                parent.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//左右两边都不为空的情况下</span></span><br><span class="line">            <span class="keyword">int</span> min = delRightTreeMinNode(node.right);</span><br><span class="line">            node.value = min;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//左右两边有一个不为空的情况下</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//在左子节点不为空的情况下</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == node.value) &#123;</span><br><span class="line">                    <span class="comment">//该节点是父节点的左子节点的情况下</span></span><br><span class="line">                    parent.left = node.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == node.value) &#123;</span><br><span class="line">                    <span class="comment">//该节点是父节点的右节点的情况下</span></span><br><span class="line">                    parent.right = node.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;出错了！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//在右子节点不为空的情况下</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == node.value) &#123;</span><br><span class="line">                    <span class="comment">//该节点是父节点的左子节点的情况下</span></span><br><span class="line">                    parent.left = node.right;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == node.value) &#123;</span><br><span class="line">                    <span class="comment">//该节点是父节点的右节点的情况下</span></span><br><span class="line">                    parent.right = node.right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;出错了！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 需要删除节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 需要删除的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值比当前节点的值要小的话就递归查询左子树</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值比当前节点的值要大的话就递归查询右子树</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点的父节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 需要删除的节点的父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value) || (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果需要查询的值小于当前节点则往左子树递归遍历</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果需要查询的值大于当前节点则往右子树递归遍历</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.midOrder(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.midOrder(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉排序树添加方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小于当前节点所有向左</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//大于等于当前节点向右</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-平衡二叉树-AVL-树"><a href="#5-平衡二叉树-AVL-树" class="headerlink" title="5.平衡二叉树(AVL 树)"></a>5.平衡二叉树(AVL 树)</h2><h3 id="5-1看一个案例-说明二叉排序树可能的问题"><a href="#5-1看一个案例-说明二叉排序树可能的问题" class="headerlink" title="5.1看一个案例(说明二叉排序树可能的问题)"></a>5.1看一个案例(说明二叉排序树可能的问题)</h3><p>给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在. </p>
<p>左边 BST 存在的问题分析: </p>
<ol>
<li><p>左子树全部为空，从形式上看，更像一个单链表.</p>
</li>
<li><p>插入速度没有影响</p>
</li>
<li><p>查询速度明显降低(因为需要依次比较), 不能发挥 BST的优势，因为每次还需要比较左子树，其查询速度比 </p>
<p>单链表还慢</p>
</li>
<li><p>解决方案-平衡二叉树(AVL)</p>
</li>
</ol>
<h3 id="5-2基本介绍"><a href="#5-2基本介绍" class="headerlink" title="5.2基本介绍"></a>5.2基本介绍</h3><ol>
<li><p>平衡二叉树也叫平衡<strong>二叉搜索树</strong>（Self-balancing binary search tree）又被称为 AVL 树， 可以保证查询效率较高。</p>
</li>
<li><p>具有以下特点：它是<strong>一 棵空树</strong>或<strong>它的左右两个子树的高度差的绝对值不超过</strong> <strong>1</strong>，并且<strong>左右两个子树都是一棵</strong> <strong>平衡二叉树</strong>。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等</p>
</li>
<li><p>举例说明, 看看下面哪些 AVL 树, 为什么?<img src="https://gitee.com/Pink_oops/image/raw/master/20210130165515.png" alt="image-20210130165514884"></p>
</li>
</ol>
<h3 id="5-3应用案例-单旋转-左旋转"><a href="#5-3应用案例-单旋转-左旋转" class="headerlink" title="5.3应用案例-单旋转(左旋转)"></a>5.3应用案例-单旋转(左旋转)</h3><ol>
<li>要求: 给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8} </li>
<li>思路分析(示意图)<img src="https://gitee.com/Pink_oops/image/raw/master/20210130165614.png" alt="image-20210130165614396"></li>
<li>代码实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 左旋转</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建新的结点，以当前根结点的值</span></span><br><span class="line">  Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">  <span class="comment">//把新的结点的左子树设置成当前结点的左子树</span></span><br><span class="line">  newNode.left = <span class="keyword">this</span>.left;</span><br><span class="line">  <span class="comment">//把新的结点的右子树设置成当前结点的右子树的左子树</span></span><br><span class="line">  newNode.right =  <span class="keyword">this</span>.right.left;</span><br><span class="line">  <span class="comment">//把当前结点的值替换成右子结点的值</span></span><br><span class="line">  <span class="keyword">this</span>.value = right.value;</span><br><span class="line">  <span class="comment">//把当前结点的右子树设置成当前结点右子树的右子树</span></span><br><span class="line">  <span class="keyword">this</span>.right = <span class="keyword">this</span>.right.right;</span><br><span class="line">  <span class="comment">//把当前结点的左子树(左子结点)设置成新的结点</span></span><br><span class="line">  <span class="keyword">this</span>.left = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4应用案例-单旋转-右旋转"><a href="#5-4应用案例-单旋转-右旋转" class="headerlink" title="5.4应用案例-单旋转(右旋转)"></a>5.4应用案例-单旋转(右旋转)</h3><ol>
<li>要求: 给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6}</li>
<li>思路分析（示意图）<img src="https://gitee.com/Pink_oops/image/raw/master/20210130165753.png" alt="image-20210130165753518"></li>
<li>代码实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 右旋转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">  newNode.right = <span class="keyword">this</span>.right;</span><br><span class="line">  newNode.left = <span class="keyword">this</span>.left.right;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">this</span>.left.value;</span><br><span class="line">  <span class="keyword">this</span>.left = <span class="keyword">this</span>.left.left;</span><br><span class="line">  <span class="keyword">this</span>.right = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-5应用案例-双旋转"><a href="#5-5应用案例-双旋转" class="headerlink" title="5.5应用案例-双旋转"></a>5.5应用案例-双旋转</h3><p>前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转 </p>
<p>不能完成平衡二叉树的转换。比如数列 </p>
<p>int[] arr = { 10, 11, 7, 6, 8, 9 }; 运行原来的代码可以看到，并没有转成 AVL 树. </p>
<p>int[] arr = {2,1,6,5,7,3}; // 运行原来的代码可以看到，并没有转成 AVL 树</p>
<p>问题分析<img src="https://gitee.com/Pink_oops/image/raw/master/20210130165903.png" alt="image-20210130165903250"></p>
<p>总体代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.avl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/30 3:05 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> AVL数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;4,3,6,5,7,8&#125;;</span></span><br><span class="line"><span class="comment">//        int[] arr = &#123; 10, 12, 8, 9, 7, 6 &#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="comment">//创建一个 AVLTree对象</span></span><br><span class="line">        AVLTree avlTree = <span class="keyword">new</span> AVLTree();</span><br><span class="line">        <span class="comment">//添加结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            avlTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        avlTree.midOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;在平衡处理~~&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;树的高度=&quot;</span> + avlTree.getRoot().height()); <span class="comment">//3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;树的左子树高度=&quot;</span> + avlTree.getRoot().leftTreeHeight()); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;树的右子树高度=&quot;</span> + avlTree.getRoot().rightTreeHeight()); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root.midOrder(<span class="keyword">this</span>.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除右子树中最小的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被删除的节点的value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">delRightTreeMinNode</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Node temp = root;</span><br><span class="line">        <span class="comment">//因为是二叉排序树所以左子树的值一定比根节点和右子树小 所以一直往左找 找到最左的节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除该节点</span></span><br><span class="line">        delNode(temp.value);</span><br><span class="line">        <span class="keyword">return</span> temp.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先获得要删除的节点</span></span><br><span class="line">        Node node = <span class="keyword">this</span>.root.search(value);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断root节点是需要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root.left == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.root.right == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.root.value == value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得父节点</span></span><br><span class="line">        Node parent = <span class="keyword">this</span>.root.searchParent(value);</span><br><span class="line">        <span class="comment">//判断需要删除的节点是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是父节点的左子节点还是右子节点</span></span><br><span class="line">            <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == node.value) &#123;</span><br><span class="line">                <span class="comment">//左子节点</span></span><br><span class="line">                parent.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == node.value) &#123;</span><br><span class="line">                <span class="comment">//右子节点</span></span><br><span class="line">                parent.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//左右两边都不为空的情况下</span></span><br><span class="line">            <span class="keyword">int</span> min = delRightTreeMinNode(node.right);</span><br><span class="line">            node.value = min;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//左右两边有一个不为空的情况下</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//在左子节点不为空的情况下</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == node.value) &#123;</span><br><span class="line">                    <span class="comment">//该节点是父节点的左子节点的情况下</span></span><br><span class="line">                    parent.left = node.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == node.value) &#123;</span><br><span class="line">                    <span class="comment">//该节点是父节点的右节点的情况下</span></span><br><span class="line">                    parent.right = node.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    root = node.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//在右子节点不为空的情况下</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == node.value) &#123;</span><br><span class="line">                    <span class="comment">//该节点是父节点的左子节点的情况下</span></span><br><span class="line">                    parent.left = node.right;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == node.value) &#123;</span><br><span class="line">                    <span class="comment">//该节点是父节点的右节点的情况下</span></span><br><span class="line">                    parent.right = node.right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    root = node.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightTreeHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.right.height();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左子树的高度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 左子树的高度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftTreeHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.left.height();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求出树的高度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(<span class="keyword">this</span>.left == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="keyword">this</span>.left.height(), <span class="keyword">this</span>.right == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="keyword">this</span>.right.height()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左旋转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建新的结点，以当前根结点的值</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">        <span class="comment">//把新的结点的左子树设置成当前结点的左子树</span></span><br><span class="line">        newNode.left = <span class="keyword">this</span>.left;</span><br><span class="line">        <span class="comment">//把新的结点的右子树设置成当前结点的右子树的左子树</span></span><br><span class="line">        newNode.right =  <span class="keyword">this</span>.right.left;</span><br><span class="line">        <span class="comment">//把当前结点的值替换成右子结点的值</span></span><br><span class="line">        <span class="keyword">this</span>.value = right.value;</span><br><span class="line">        <span class="comment">//把当前结点的右子树设置成当前结点右子树的右子树</span></span><br><span class="line">        <span class="keyword">this</span>.right = <span class="keyword">this</span>.right.right;</span><br><span class="line">        <span class="comment">//把当前结点的左子树(左子结点)设置成新的结点</span></span><br><span class="line">        <span class="keyword">this</span>.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右旋转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">        newNode.right = <span class="keyword">this</span>.right;</span><br><span class="line">        newNode.left = <span class="keyword">this</span>.left.right;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.left.value;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">this</span>.left.left;</span><br><span class="line">        <span class="keyword">this</span>.right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 需要删除节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 需要删除的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值比当前节点的值要小的话就递归查询左子树</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值比当前节点的值要大的话就递归查询右子树</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点的父节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 需要删除的节点的父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value) || (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果需要查询的值小于当前节点则往左子树递归遍历</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果需要查询的值大于当前节点则往右子树递归遍历</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.midOrder(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.midOrder(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉排序树添加方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小于当前节点所有向左</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//大于等于当前节点向右</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加完之后判断是否需要旋转</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.rightTreeHeight() - <span class="keyword">this</span>.leftTreeHeight() &gt;<span class="number">1</span> ) &#123;</span><br><span class="line">            <span class="comment">//如果当前节点的右子树的左子树高度大于右子树的右子树的高度的话就需要先将当前节点的右子树先进行一次右旋转</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.left.height() &gt; <span class="keyword">this</span>.right.right.height()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.right.rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            leftRotate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.leftTreeHeight() - <span class="keyword">this</span>.rightTreeHeight() &gt;<span class="number">1</span> ) &#123;</span><br><span class="line">            <span class="comment">//如果当前节点的左子树的左子树高度小于左子树的右子树的话就需要先将当前节点的左子树先进行一次左旋转</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.left.height() &lt; <span class="keyword">this</span>.left.right.height()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.left.leftRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            rightRotate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-多路查找树"><a href="#6-多路查找树" class="headerlink" title="6.多路查找树"></a>6.多路查找树</h2><h3 id="6-1-二叉树与B树"><a href="#6-1-二叉树与B树" class="headerlink" title="6.1 二叉树与B树"></a>6.1 二叉树与B树</h3><h4 id="6-1-1二叉树的问题分析"><a href="#6-1-1二叉树的问题分析" class="headerlink" title="6.1.1二叉树的问题分析"></a>6.1.1二叉树的问题分析</h4><p>二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130182005.png" alt="image-20210130180457810"></p>
<p>二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如 1 亿)， 就 </p>
<p>存在如下问题:</p>
<p>问题 1：在构建二叉树时，需要多次进行 i/o 操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时， 速度有影响</p>
<p>问题 2：节点海量，也会造成二叉树的高度很大，会降低操作速度.</p>
<h4 id="6-1-2多叉树"><a href="#6-1-2多叉树" class="headerlink" title="6.1.2多叉树"></a>6.1.2多叉树</h4><ol>
<li>在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点， 就是多叉树（multiway tree）</li>
<li>后面我们讲解的 2-3 树，2-3-4 树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。</li>
<li>举例说明(下面 2-3 树就是一颗多叉树)<img src="https://gitee.com/Pink_oops/image/raw/master/20210130180746.png" alt="image-20210130180746024"></li>
</ol>
<h3 id="6-2-2-3-树"><a href="#6-2-2-3-树" class="headerlink" title="6.2 2-3 树"></a>6.2 2-3 树</h3><p>2-3 树是最简单的 B 树结构, 具有如下特点:</p>
<ol>
<li>2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件) </li>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</li>
<li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.</li>
<li>2-3 树是由二节点和三节点构成的树。 </li>
</ol>
<p>将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成 2-3 树，并保证数据插入的大小顺序。(演示一下构建 2-3 树的过程.) </p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130181027.png" alt="image-20210130181027566"></p>
<p>插入规则: </p>
<ol>
<li><p>2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件)</p>
</li>
<li><p>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</p>
</li>
<li><p>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</p>
</li>
<li><p>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层， 拆后仍然需要满足上面 3 个条件。 </p>
</li>
<li><p>对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则</p>
</li>
</ol>
<p>除了 23 树，还有 234 树等，概念和 23 树类似，也是一种 B 树。 如图:<img src="https://gitee.com/Pink_oops/image/raw/master/20210130181223.png" alt="image-20210130181223147"></p>
<h3 id="6-3-B-树、B-树和-B-树"><a href="#6-3-B-树、B-树和-B-树" class="headerlink" title="6.3 B 树、B+树和 B*树"></a>6.3 B 树、B+树和 B*树</h3><h4 id="6-3-1-B-树的介绍"><a href="#6-3-1-B-树的介绍" class="headerlink" title="6.3.1 B 树的介绍"></a>6.3.1 B 树的介绍</h4><p>B-tree 树即 B 树，B 即 Balanced，平衡的意思。有人把 B-tree 翻译成 B-树，容易让人产生误解。会以为 B-树 是一种树，而 B 树又是另一种树。实际上，B-tree 就是指的 B 树。</p>
<h3 id="6-3-2-B-树的介绍"><a href="#6-3-2-B-树的介绍" class="headerlink" title="6.3.2 B 树的介绍"></a>6.3.2 B 树的介绍</h3><p>前面已经介绍了 2-3 树和 2-3-4 树，他们就是 B 树(英语：B-tree 也写成 B-树)，这里我们再做一个说明，我们在学 习 Mysql 时，经常听到说某种类型的索引是基于 B 树或者 B+树的，如图: <img src="https://gitee.com/Pink_oops/image/raw/master/20210130181425.png" alt="image-20210130181425020"></p>
<p>对上图的说明:</p>
<ol>
<li>B 树的阶：节点的最多子节点个数。比如 2-3 树的阶是 3，2-3-4 树的阶是 4</li>
<li>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询 关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li>
<li>关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据. </li>
<li>搜索有可能在非叶子结点结束</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找</li>
</ol>
<h3 id="6-3-3-B-树的介绍"><a href="#6-3-3-B-树的介绍" class="headerlink" title="6.3.3 B+树的介绍"></a>6.3.3 B+树的介绍</h3><p>B+树是 B 树的变体，也是一种多路搜索树。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130181535.png" alt="image-20210130181535392"></p>
<p>对上图的说明:</p>
<ol>
<li>B+树的搜索与 B 树也基本相同，区别是 B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性 能也等价于在关键字全集做一次二分查找</li>
<li>所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据) 恰好是有序的。 </li>
<li>不可能在非叶子结点命中</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数b据层</li>
<li>更适合文件索引系统</li>
<li>B 树和 B+树各有自己的应用场景，不能说 B+树完全比 B 树好，反之亦然</li>
</ol>
<h3 id="6-3-4-B-树的介绍"><a href="#6-3-4-B-树的介绍" class="headerlink" title="6.3.4 B*树的介绍"></a>6.3.4 B*树的介绍</h3><p>B*树是 B+树的变体，在 B+树的<strong>非根和非叶子结点</strong>再增<strong>加指向兄弟的指针</strong>。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130181716.png" alt="image-20210130181716612"></p>
<p>B*树的说明: </p>
<ol>
<li><p>B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为 2/3，而 B+树的块的最低使用率为的 1/2。</p>
</li>
<li><p>从第 1 个特点我们可以看出，B*树分配新结点的概率比 B+树要低，空间使用率更高</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">w</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://oopsw.top/2021/01/25/%E6%A0%91%E7%BB%93%E6%9E%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/">http://oopsw.top/2021/01/25/树结构实际应用/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://oopsw.top" target="_blank">w</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/Tree/">Tree</a></div><div class="post_share"><div class="social-share" data-image="/img/8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/01/31/%E5%9B%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="/img/8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">图学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/21/%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="/img/8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">树学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/01/21/树学习笔记/" title="树学习笔记"><img class="cover" src="/img/8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-21</div><div class="title">树学习笔记</div></div></a></div><div><a href="/2021/01/17/哈希表学习笔记/" title="哈希表学习笔记"><img class="cover" src="/img/9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-17</div><div class="title">哈希表学习笔记</div></div></a></div><div><a href="/2021/01/31/图学习笔记/" title="图学习笔记"><img class="cover" src="/img/8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-31</div><div class="title">图学习笔记</div></div></a></div><div><a href="/2021/01/07/稀疏矩阵学习笔记/" title="稀疏矩阵学习笔记"><img class="cover" src="/img/8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-07</div><div class="title">稀疏矩阵学习笔记</div></div></a></div><div><a href="/2021/01/08/递归回溯学习/" title="递归回溯学习笔记"><img class="cover" src="/img/%E5%92%8C%E6%9C%8D.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-08</div><div class="title">递归回溯学习笔记</div></div></a></div><div><a href="/2021/01/07/队列学习笔记/" title="队列学习笔记"><img class="cover" src="/img/%E7%BB%BF%E6%B5%B7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-07</div><div class="title">队列学习笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">w</div><div class="author-info__description">好好生活</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qq1437631334"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/qq1437631334" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1437631334@qq.com" target="_blank" title=""><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的个人博客，如果有什么想和我说的话可以在留言板留言噢</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">1.堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E5%A0%86%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.1堆排序基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E5%A0%86%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-text">1.2堆排序基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E5%A0%86%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A4%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E"><span class="toc-text">1.3堆排序步骤图解说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E5%A0%86%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.4堆排序代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-text">2.赫夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.1基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%92%8C%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-text">2.2赫夫曼树几个重要概念和举例说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%88%9B%E5%BB%BA%E6%80%9D%E8%B7%AF%E5%9B%BE%E8%A7%A3"><span class="toc-text">2.3赫夫曼树创建思路图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.4赫夫曼树的代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-text">3.赫夫曼编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">3.1基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span class="toc-text">3.2原理剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9"><span class="toc-text">3.3最佳实践-数据压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">3.4赫夫曼编码压缩文件注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-text">4.二叉排序树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E5%85%88%E7%9C%8B%E4%B8%80%E4%B8%AA%E9%9C%80%E6%B1%82"><span class="toc-text">3.1先看一个需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90"><span class="toc-text">3.2解决方案分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%BB%8B%E7%BB%8D"><span class="toc-text">4.3二叉排序树介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86"><span class="toc-text">4.4二叉排序树创建和遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-text">4.5二叉排序树的删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.6二叉排序树删除节点的代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-AVL-%E6%A0%91"><span class="toc-text">5.平衡二叉树(AVL 树)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E7%9C%8B%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B-%E8%AF%B4%E6%98%8E%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%8F%AF%E8%83%BD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">5.1看一个案例(说明二叉排序树可能的问题)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">5.2基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B-%E5%8D%95%E6%97%8B%E8%BD%AC-%E5%B7%A6%E6%97%8B%E8%BD%AC"><span class="toc-text">5.3应用案例-单旋转(左旋转)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B-%E5%8D%95%E6%97%8B%E8%BD%AC-%E5%8F%B3%E6%97%8B%E8%BD%AC"><span class="toc-text">5.4应用案例-单旋转(右旋转)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B-%E5%8F%8C%E6%97%8B%E8%BD%AC"><span class="toc-text">5.5应用案例-双旋转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-text">6.多路查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8EB%E6%A0%91"><span class="toc-text">6.1 二叉树与B树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">6.1.1二叉树的问题分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2%E5%A4%9A%E5%8F%89%E6%A0%91"><span class="toc-text">6.1.2多叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-3-%E6%A0%91"><span class="toc-text">6.2 2-3 树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-B-%E6%A0%91%E3%80%81B-%E6%A0%91%E5%92%8C-B-%E6%A0%91"><span class="toc-text">6.3 B 树、B+树和 B*树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-B-%E6%A0%91%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">6.3.1 B 树的介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-B-%E6%A0%91%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">6.3.2 B 树的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-3-B-%E6%A0%91%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">6.3.3 B+树的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-4-B-%E6%A0%91%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">6.3.4 B*树的介绍</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/08/15/Java%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92/" title="Java生产者消费者模型的虚假唤醒"><img src="/img/%E5%92%8C%E6%9C%8D.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java生产者消费者模型的虚假唤醒"/></a><div class="content"><a class="title" href="/2021/08/15/Java%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92/" title="Java生产者消费者模型的虚假唤醒">Java生产者消费者模型的虚假唤醒</a><time datetime="2021-08-15T08:40:20.000Z" title="发表于 2021-08-15 16:40:20">2021-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/13/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MySQL学习笔记"><img src="/img/8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL学习笔记"/></a><div class="content"><a class="title" href="/2021/08/13/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MySQL学习笔记">MySQL学习笔记</a><time datetime="2021-08-13T07:35:20.000Z" title="发表于 2021-08-13 15:35:20">2021-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/02/kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Kafka学习笔记"><img src="/img/9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kafka学习笔记"/></a><div class="content"><a class="title" href="/2021/08/02/kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Kafka学习笔记">Kafka学习笔记</a><time datetime="2021-08-02T04:18:20.000Z" title="发表于 2021-08-02 12:18:20">2021-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/30/%E8%87%AA%E5%AE%9A%E4%B9%89Spring-IOC%E6%80%BB%E7%BB%93/" title="自定义Spring IOC总结"><img src="/img/8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自定义Spring IOC总结"/></a><div class="content"><a class="title" href="/2021/03/30/%E8%87%AA%E5%AE%9A%E4%B9%89Spring-IOC%E6%80%BB%E7%BB%93/" title="自定义Spring IOC总结">自定义Spring IOC总结</a><time datetime="2021-03-30T15:50:20.000Z" title="发表于 2021-03-30 23:50:20">2021-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="设计模式学习笔记"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式学习笔记"/></a><div class="content"><a class="title" href="/2021/03/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="设计模式学习笔记">设计模式学习笔记</a><time datetime="2021-03-26T03:07:51.000Z" title="发表于 2021-03-26 11:07:51">2021-03-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By w</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://beian.miit.gov.cn/" target="_blank">湘ICP备2021000978号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    let initData = {
      el: '#twikoo-wrap',
      envId: 'myblog-cloudbase-0fahk0qccd61fec',
      region: 'ap-shanghai'
    }

    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    twikoo.init(initData)
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'myblog-cloudbase-0fahk0qccd61fec',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<[^>]+>/g,"") // remove html tag
    content = content.replace(/(http(s?):)([/|.|\w|\s|-])*\.(?:jpg|jpeg|gif|png|webp)/g, '') // remove image link
    content = content.replace(/(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gi, '') // remove url

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'myblog-cloudbase-0fahk0qccd61fec',
        region: 'ap-shanghai',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        saveToLocal.set('twikoo-newest-comments', JSON.stringify(res), 10/(60*24))
        generateHtml(res)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          let name = 'src'
          if(false) {
            name = 'data-lazy-src'
          }
          result += `<a href='${array[i].url + '#' + array[i].id}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url + '#' + array[i].id}'>${changeContent(array[i].commentText)}</a>
        <div class='name'><span>${array[i].nick}</span><time> / ${btf.diffDate(array[i].created, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="2941656328" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" data-lrctype="0" muted></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config_change',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})</script></div></body></html>