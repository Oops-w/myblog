<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ELK综合实例</title>
    <url>/2021/01/07/ELK%E7%BB%BC%E5%90%88%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ElasticStack综合案例"><a href="#ElasticStack综合案例" class="headerlink" title="ElasticStack综合案例"></a>ElasticStack综合案例</h1><p>本篇将我们前面学习到的技术：ElasticSearch、Beats、Kibana、Logstash 整合起来，做一个综合性的学习，目的是为了让小伙伴们能够更加深刻的理解ElasticStack的使用</p>
<h2 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h2><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095437.png" alt="image-20200925083514711"></p>
<ul>
<li>应用APP生产日志，用来记录用户的操作<ul>
<li>[INFO] 2019-03-15 22:55:20 [Main] - DAU|5206|使用优惠券|2019-03-15 03:37:20</li>
<li>[INFO] 2019-03-15 22:55:21 [Main] - DAU|3880|浏览页面|2019-03-15 07:25:09</li>
</ul>
</li>
<li>通过Filebeat读取日志文件中的内容，并且将内容发送给Logstash，原因是需要对内容做处理</li>
<li>Logstash接收到内容后，进行处理，如分割操作，然后将内容发送到Elasticsearch中</li>
<li>Kibana会读取Elasticsearch中的数据，并且在Kibana中进行设计Dashboard，最后进行展示</li>
</ul>
<blockquote>
<p>说明：日志格式、图表、Dashboard都是自定义的</p>
</blockquote>
<h2 id="App介绍"><a href="#App介绍" class="headerlink" title="App介绍"></a>App介绍</h2><p>APP在生产环境应该是真实系统，然而，现在我们学习的话，为了简化操作，所以就做数据的模拟生成即可。</p>
<p>业务代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.RandomUtils;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.DateTime;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] VISIT = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;浏览页面&quot;</span>, <span class="string">&quot;评论商品&quot;</span>, <span class="string">&quot;加入收藏&quot;</span>, <span class="string">&quot;加入购物车&quot;</span>, <span class="string">&quot;提交订单&quot;</span>, <span class="string">&quot;使用优惠券&quot;</span>, <span class="string">&quot;领取优惠券&quot;</span>, <span class="string">&quot;搜索&quot;</span>, <span class="string">&quot;查看订单&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Long sleep = RandomUtils.nextLong(<span class="number">200</span>, <span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">            Thread.sleep(sleep);</span><br><span class="line">            Long maxUserId = <span class="number">9999L</span>;</span><br><span class="line">            Long userId = RandomUtils.nextLong(<span class="number">1</span>, maxUserId);</span><br><span class="line">            String visit = VISIT[RandomUtils.nextInt(<span class="number">0</span>, VISIT.length)];</span><br><span class="line">            DateTime now = <span class="keyword">new</span> DateTime();</span><br><span class="line">            <span class="keyword">int</span> maxHour = now.getHourOfDay();</span><br><span class="line">            <span class="keyword">int</span> maxMillis = now.getMinuteOfHour();</span><br><span class="line">            <span class="keyword">int</span> maxSeconds = now.getSecondOfMinute();</span><br><span class="line">            String date = now.plusHours(-(RandomUtils.nextInt(<span class="number">0</span>, maxHour)))</span><br><span class="line">                    .plusMinutes(-(RandomUtils.nextInt(<span class="number">0</span>, maxMillis)))</span><br><span class="line">                    .plusSeconds(-(RandomUtils.nextInt(<span class="number">0</span>, maxSeconds)))</span><br><span class="line">                    .toString(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">            String result = <span class="string">&quot;DAU|&quot;</span> + userId + <span class="string">&quot;|&quot;</span> + visit + <span class="string">&quot;|&quot;</span> + date;</span><br><span class="line">            log.error(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以启动运行，就是不断的生成日志，模拟了我们的实际业务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">09:18:32.721 [main] ERROR com.log.Main - DAU|8183|加入购物车|2020-09-25 06:10:25</span><br><span class="line">09:18:33.599 [main] ERROR com.log.Main - DAU|7097|提交订单|2020-09-25 06:18:31</span><br><span class="line">09:18:37.265 [main] ERROR com.log.Main - DAU|1468|查看订单|2020-09-25 02:04:10</span><br><span class="line">09:18:39.634 [main] ERROR com.log.Main - DAU|7821|领取优惠券|2020-09-25 02:04:07</span><br><span class="line">09:18:41.909 [main] ERROR com.log.Main - DAU|7962|提交订单|2020-09-25 03:02:39</span><br><span class="line">09:18:43.596 [main] ERROR com.log.Main - DAU|3358|评论商品|2020-09-25 08:14:19</span><br></pre></td></tr></table></figure>
<p>然后我们将该项目使用下面命令进行打包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure>
<p>打包完成后，到target目录下，能够看到我们生成的jar包</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095438.png" alt="image-20200925092119075"></p>
<p>我们将其复制到我们的服务器上，然后创建一个启动的脚本 startup.sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash     </span></span><br><span class="line">nohup java  -Xms256m -Xmx512m -jar  mogu-dashboard-generate-0.0.1-SNAPSHOT.jar  &gt; app.log  2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>然后就使用脚本进行启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">./startup.sh</span><br><span class="line"><span class="comment"># 启动成功后，会看到一个日志 app.log，我们可以查看</span></span><br><span class="line">tail -f app.log</span><br></pre></td></tr></table></figure>
<h2 id="配置Filebeat"><a href="#配置Filebeat" class="headerlink" title="配置Filebeat"></a>配置Filebeat</h2><p>在有了不断产生日志的应用程序后，我们就需要创建一个Filebeat的配置文件，用于日志的收集</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开配置文件</span></span><br><span class="line">vim  mogu-dashboard.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入数据</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /soft/app/*.<span class="built_in">log</span></span><br><span class="line">setup.template.settings:</span><br><span class="line">  index.number_of_shards: 1</span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [<span class="string">&quot;127.0.0.1:5044&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>然后我们就可以启动了【需要我们把Logstash启动起来】</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./filebeat -e -c mogu-dashboard.yml</span><br></pre></td></tr></table></figure>
<h2 id="配置Logstash"><a href="#配置Logstash" class="headerlink" title="配置Logstash"></a>配置Logstash</h2><h3 id="Logstash输出到控制台"><a href="#Logstash输出到控制台" class="headerlink" title="Logstash输出到控制台"></a>Logstash输出到控制台</h3><p>Logstash的主要目的就是处理Filebeat发送过来的数据，进行数据的清洗，过滤等，我们首先简单的将logstash获得的数据输出到控制台</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开配置文件</span></span><br><span class="line">vim  mogu-dashboard.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加以下内容</span></span><br><span class="line">input &#123;</span><br><span class="line">	beats &#123;</span><br><span class="line">		port =&gt; <span class="string">&quot;5044&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">	stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后启动我们的logstash 【注意，启动时间比较长，需要我们等待】</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/logstash -f mogu-dashboard.conf</span><br></pre></td></tr></table></figure>
<p>启动logstash完成后，我们需要再次启动filebeat，回到上面的启动步骤，然后就能看到logstash输出我们的日志</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095439.png" alt="image-20200925095319950"></p>
<h3 id="配置Logstash连接ElasticSearch"><a href="#配置Logstash连接ElasticSearch" class="headerlink" title="配置Logstash连接ElasticSearch"></a>配置Logstash连接ElasticSearch</h3><p>上面的数据，其实还是我们的原始数据，并没有经过处理，所以我们这个时候就需要使用到Logstash的其它功能了。我们继续修改配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开配置文件</span></span><br><span class="line">vim  mogu-dashboard.conf</span><br></pre></td></tr></table></figure>
<p>然后修改一下的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">        beats &#123;</span><br><span class="line">                port =&gt; <span class="string">&quot;5044&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">        mutate &#123;</span><br><span class="line">                split =&gt; &#123;<span class="string">&quot;message&quot;</span>=&gt;<span class="string">&quot;|&quot;</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mutate &#123;</span><br><span class="line">                add_field =&gt; &#123;</span><br><span class="line">                <span class="string">&quot;userId&quot;</span> =&gt; <span class="string">&quot;%&#123;[message][1]&#125;&quot;</span></span><br><span class="line">                <span class="string">&quot;visit&quot;</span> =&gt; <span class="string">&quot;%&#123;[message][2]&#125;&quot;</span></span><br><span class="line">                <span class="string">&quot;date&quot;</span> =&gt; <span class="string">&quot;%&#123;[message][3]&#125;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mutate &#123;</span><br><span class="line">                convert =&gt; &#123;</span><br><span class="line">                <span class="string">&quot;userId&quot;</span> =&gt; <span class="string">&quot;integer&quot;</span></span><br><span class="line">                <span class="string">&quot;visit&quot;</span> =&gt; <span class="string">&quot;string&quot;</span></span><br><span class="line">                <span class="string">&quot;date&quot;</span> =&gt; <span class="string">&quot;string&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mutate &#123;</span><br><span class="line">           remove_field =&gt; [ <span class="string">&quot;host&quot;</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#output &#123;</span></span><br><span class="line"><span class="comment"># stdout &#123; codec =&gt; rubydebug &#125;</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [ <span class="string">&quot;127.0.0.1:9200&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再次启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/logstash -f mogu-dashboard.conf</span><br></pre></td></tr></table></figure>
<p>其实能够看到，我们原来的数据，就经过了处理了，产生了新的字段</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095440.png" alt="image-20200925095824693"></p>
<p>同时我们还可以对我们的数据，进行类型转换，为了方便我们的下游进行处理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mutate &#123;</span><br><span class="line">	convert =&gt; &#123;</span><br><span class="line">	<span class="string">&quot;userId&quot;</span> =&gt; <span class="string">&quot;integer&quot;</span></span><br><span class="line">	<span class="string">&quot;visit&quot;</span> =&gt; <span class="string">&quot;string&quot;</span></span><br><span class="line">	<span class="string">&quot;date&quot;</span> =&gt; <span class="string">&quot;string&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遇到的问题1"><a href="#遇到的问题1" class="headerlink" title="遇到的问题1"></a>遇到的问题1</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2020-09-25T02:32:44,042][WARN ][logstash.filters.mutate  ][main][5fd6a2f2f396816d849f2e3e2e0a53f2500a9b58c6819e23f42d2bfd34cde207] Exception caught <span class="keyword">while</span> applying mutate filter &#123;:exception=&gt;<span class="string">&quot;Invalid FieldReference: `message[1]`&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>不断的刷这个错误，配置文件没问题，但添加字段那一个mutate需要给message套一层中括号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mutate &#123;</span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">        <span class="string">&quot;userId&quot;</span> =&gt; <span class="string">&quot;%&#123;[message][1]&#125;&quot;</span></span><br><span class="line">        <span class="string">&quot;visit&quot;</span> =&gt; <span class="string">&quot;%&#123;[message][2]&#125;&quot;</span></span><br><span class="line">        <span class="string">&quot;date&quot;</span> =&gt; <span class="string">&quot;%&#123;[message][3]&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遇到的问题2"><a href="#遇到的问题2" class="headerlink" title="遇到的问题2"></a>遇到的问题2</h3><p>filebeat 传输到host的字段中host是一个对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">failed to parse field [host] of <span class="built_in">type</span> [text] <span class="keyword">in</span> document</span><br></pre></td></tr></table></figure>
<p>解决方法就是过滤掉host字段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mutate &#123;</span><br><span class="line">	remove_field =&gt; [ <span class="string">&quot;host&quot;</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="启动ElasticSearch"><a href="#启动ElasticSearch" class="headerlink" title="启动ElasticSearch"></a>启动ElasticSearch</h2><p>在我们通过Logstash发送数据到ElasticSearch，所以我们还需要启动我们的ElasticSearch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到elsearch用户</span></span><br><span class="line">su elsearch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 到目录</span></span><br><span class="line"><span class="built_in">cd</span> /soft/elsearch/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">./elasticsearch</span><br></pre></td></tr></table></figure>
<h2 id="启动Kibana"><a href="#启动Kibana" class="headerlink" title="启动Kibana"></a>启动Kibana</h2><p>我们最后就需要通过Kibana来展示我们的图形化数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动kibana</span></span><br><span class="line">./bin/kibana</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过浏览器访问</span></span><br><span class="line">http://202.193.56.222:5601/app/kibana</span><br></pre></td></tr></table></figure>
<h3 id="添加到索引库"><a href="#添加到索引库" class="headerlink" title="添加到索引库"></a>添加到索引库</h3><p>添加Logstash索引到Kibana中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://202.193.56.222:5601/app/management/kibana/indexPatterns/create</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095441.png" alt="image-20200925112345791"></p>
<p>输入我们的匹配规则，然后匹配到logstash，然后选择时间字段后创建</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095442.png" alt="image-20200925112534588"></p>
<h3 id="创建柱形图"><a href="#创建柱形图" class="headerlink" title="创建柱形图"></a>创建柱形图</h3><p>我们点击右侧Visualizations，然后开始创建图标</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095443.png" alt="image-20200925112621210"></p>
<p>然后选择柱形图</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095444.png" alt="image-20200925112705557"></p>
<p>在选择我们的索引</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095445.png" alt="image-20200925112758534"></p>
<p>最后我们定义我们的X轴，选择按照时间进行添加</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095446.png" alt="image-20200925113054316"></p>
<p>最后更新我们的页面，然后在选择最近的30分钟</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095447.png" alt="image-20200925113133267"></p>
<p>就能够看到我们的日志在源源不断的生成了，同时我们可以对我们的这个图表进行保存</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095448.png" alt="image-20200925113154752"></p>
<h3 id="创建饼图"><a href="#创建饼图" class="headerlink" title="创建饼图"></a>创建饼图</h3><p>我们继续选择饼图</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095449.png" alt="image-20200925144902642"></p>
<p>然后选择我们的索引</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095450.png" alt="image-20200925144939062"></p>
<p>添加完成后，我们就看到这样一个页面了</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095451.png" alt="image-20200925145116116"></p>
<p>但是这样还不死很直观，所以我们还需要做处理，找到右侧的Buckets，然后选择Split Slices，然后把我们的每个字段都添加上去，其中visit指的是我们es中的属性</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095452.png" alt="image-20200925145451255"></p>
<p>最后选择update，得到的效果如下所示</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095453.png" alt="image-20200925145553509"></p>
<p>我们还可以继续给每个字段都添加label标签</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095454.png" alt="image-20200925145747292"></p>
<p>添加完成后，更新页面，就得到非常不错的效果了~</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095455.png" alt="image-20200925145807688"></p>
<h3 id="数据表格"><a href="#数据表格" class="headerlink" title="数据表格"></a>数据表格</h3><p>在图标中，选择我们需要显示的字段即可</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095456.png" alt="image-20200925150415045"></p>
<h2 id="制作Dashboard"><a href="#制作Dashboard" class="headerlink" title="制作Dashboard"></a>制作Dashboard</h2><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095457.png" alt="image-20200925151827734"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>Kibana学习笔记</title>
    <url>/2021/01/07/Kibana%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Kibana入门"><a href="#Kibana入门" class="headerlink" title="Kibana入门"></a>Kibana入门</h1><p>Kibana 是一款开源的数据分析和可视化平台，它是 Elastic Stack 成员之一，设计用于和 Elasticsearch 协作。您可以使用 Kibana 对 Elasticsearch 索引中的数据进行搜索、查看、交互操作。您可以很方便的利用图表、表格及地图对数据进行多元化的分析和呈现。</p>
<p>官网：<a href="https://www.elastic.co/cn/kibana">https://www.elastic.co/cn/kibana</a></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095308.png" alt="image-20200924193926486"></p>
<h2 id="配置和安装"><a href="#配置和安装" class="headerlink" title="配置和安装"></a>配置和安装</h2><p>到下载地址，选择对应的版本：<a href="https://www.elastic.co/cn/downloads/kibana">https://www.elastic.co/cn/downloads/kibana</a></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095309.png" alt="image-20200924194324366">下载完成后，将文件拷贝到我们的服务器上，然后解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf kibana-7.9.1-linux-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line">mv kibana-7.9.1-linux-x86_64 kibana</span><br></pre></td></tr></table></figure>
<p>然后在进入kibana目录，找到config文件夹下的kibana.yml进行配置的修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /soft/kibana/config/kibana.yml</span><br></pre></td></tr></table></figure>
<p>然后找到下面的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对外暴露服务的地址</span></span><br><span class="line">server.host: <span class="string">&quot;0.0.0.0&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#配置Elasticsearch</span></span><br><span class="line">elasticsearch.url: <span class="string">&quot;http://127.0.0.1:9200&quot;</span> </span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>修改配置完成后，我们就可以启动kibana了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">./bin/kibana</span><br></pre></td></tr></table></figure>
<p>点击启动，发现报错了</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095310.png" alt="image-20200924195011533"></p>
<p>原因是kibana不能使用root用户进行启动，所以我们切换到elsearch用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将soft文件夹的所属者改成elsearch</span></span><br><span class="line">chown elsearch:elsearch /soft/ -R</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line">su elsearch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">./bin/kibana</span><br></pre></td></tr></table></figure>
<p>然后打开下面的地址，即可访问我们的kibana了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://202.193.56.222:5601/</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095311.png" alt="image-20200924200502907"></p>
<h2 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h2><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095312.png" alt="image-20200924200615995"></p>
<ul>
<li>Discover：数据探索</li>
<li>Visualize：可视化</li>
<li>Dashboard：仪表盘</li>
<li>Timelion：时序控件</li>
<li>Canvas：画布</li>
<li>Machine Learning：机器学习</li>
<li>Infrastructure：基本信息</li>
<li>Logs：数据日志展示</li>
<li>APM：性能监控</li>
<li>Dev Tools：开发者工具</li>
<li>Monitoring：监控</li>
<li>Management：管理</li>
</ul>
<h2 id="数据探索"><a href="#数据探索" class="headerlink" title="数据探索"></a>数据探索</h2><p>先添加索引信息</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095313.png" alt="image-20200924201110208"></p>
<p>然后我们就输入匹配规则进行匹配</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095314.png" alt="image-20200924201234997"></p>
<p>然后选择时间字段，一般选择第一个</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095315.png" alt="image-20200924201312845"></p>
<p>索引创建完毕后</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095316.png" alt="image-20200924201354838"></p>
<p>然后我们就可以往nginx error.log日志文件中，添加几天错误记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello error&quot;</span> &gt;&gt; error.log</span><br></pre></td></tr></table></figure>
<p>我们追加了两条数据，然后到kibana的discover中，刷新页面，就能够看到我们刚添加的日志了，同时我们点击右侧还可以选择需要展示的字段，非常的方便</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095317.png" alt="image-20200924201952010"></p>
<p>点击右上角，我们还可以针对时间来进行过滤</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095318.png" alt="image-20200924202210114"></p>
<h2 id="Metricbeat仪表盘"><a href="#Metricbeat仪表盘" class="headerlink" title="Metricbeat仪表盘"></a>Metricbeat仪表盘</h2><p>现在将Metricbeat的数据展示在Kibana中，首先需要修改我们的MetricBeat配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改metricbeat配置</span></span><br><span class="line">setup.kibana:</span><br><span class="line">  host: <span class="string">&quot;192.168.40.133:5601&quot;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#安装仪表盘到Kibana【需要确保Kibana在正常运行，这个过程可能会有些耗时】</span></span><br><span class="line">./metricbeat setup --dashboards</span><br></pre></td></tr></table></figure>
<p>安装完成后，如下所示</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095319.png" alt="image-20200924203831606"></p>
<p>然后我们启动Metricbeat</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;metricbeat -e</span><br></pre></td></tr></table></figure>
<p>然后到kibana页面下，找到我们刚刚安装的仪表盘</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095320.png" alt="image-20200924204708099"></p>
<p>然后我们就能够看到非常多的指标数据了</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095321.png" alt="image-20200924204636176"></p>
<h2 id="Nginx指标仪表盘【Metricbeat】"><a href="#Nginx指标仪表盘【Metricbeat】" class="headerlink" title="Nginx指标仪表盘【Metricbeat】"></a>Nginx指标仪表盘【Metricbeat】</h2><p>选择Metricbeat的nginx仪表盘即可</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095322.png" alt="image-20200924205523107"></p>
<p>然后就能够看到Nginx的指标信息了</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095323.png" alt="image-20200924205552446"></p>
<h2 id="Nginx日志仪表盘"><a href="#Nginx日志仪表盘" class="headerlink" title="Nginx日志仪表盘"></a>Nginx日志仪表盘</h2><p>我们可以和刚刚Metricbeat的仪表盘一样，也可以将filebeat收集的日志记录，推送到Kibana中</p>
<p>首先我们需要修改filebeat的 mogublog-nginx.yml配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="attr">setup.template.settings:</span></span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;127.0.0.1:9200&quot;</span>]</span><br><span class="line"><span class="attr">filebeat.config.modules:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">$&#123;path.config&#125;/modules.d/*.yml</span></span><br><span class="line">  <span class="attr">reload.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">setup.kibana:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">&quot;127.0.0.1:5601&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后按照仪表盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./filebeat -c mogublog-nginx.yml setup</span><br></pre></td></tr></table></figure>
<p>等待一会后，仪表盘也安装成功了</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095324.png" alt="image-20200924210454873"></p>
<p>然后我们启动filebeat即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./filebeat -e -c mogublog-nginx.yml</span><br></pre></td></tr></table></figure>
<p>启动完成后，我们回到我们的Kibana中，找到Dashboard，添加我们的filebeat - nginx即可</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095325.png" alt="image-20200924210913557"></p>
<p>然后就能看到我们的仪表盘了，上图就是请求的来源</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095326.png" alt="image-20200924210816489"></p>
<blockquote>
<p>需要注意的是，这些仪表盘本身是没有的，我们需要通过filebeat来进行安装</p>
</blockquote>
<h2 id="Kibana自定义仪表盘"><a href="#Kibana自定义仪表盘" class="headerlink" title="Kibana自定义仪表盘"></a>Kibana自定义仪表盘</h2><p>在Kibana中，我们也可以自定义图标，如制作柱形图</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095327.png" alt="image-20200924211227780"></p>
<p>我们选择最下面的 Vertical Bar，也就是柱形图，然后在选择我们的索引</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095328.png" alt="image-20200924211318386"></p>
<p>这样就出来了</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095329.png" alt="image-20200924211427643"></p>
<h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h2><p>在Kibana中，为开发者的测试提供了便捷的工具使用，如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095330.png" alt="image-20200924211727920"></p>
<p>我们就可以在这里面写一些请求了</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095331.png" alt="image-20200924212137167"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>ELK</category>
        <category>Kibana</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>Kibana</tag>
      </tags>
  </entry>
  <entry>
    <title>Logstash学习笔记</title>
    <url>/2021/01/07/Logstash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Logstash入门简介"><a href="#Logstash入门简介" class="headerlink" title="Logstash入门简介"></a>Logstash入门简介</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Logstash是一个开源的服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到最喜欢的存储库中（我们的存储库当然是ElasticSearch）</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095421.png" alt="image-20200924213006328"></p>
<p>我们回到我们ElasticStack的架构图，可以看到Logstash是充当数据处理的需求的，当我们的数据需要处理的时候，会将它发送到Logstash进行处理，否则直接送到ElasticSearch中</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095422.png" alt="image-20200924213319642"></p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>Logstash可以处理各种各样的输入，从文档，图表中=，数据库中，然后处理完后，发送到</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095423.png" alt="image-20200924213350345"></p>
<h2 id="部署安装"><a href="#部署安装" class="headerlink" title="部署安装"></a>部署安装</h2><p>Logstash主要是将数据源的数据进行一行一行的处理，同时还直接过滤切割等功能。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095424.png" alt="image-20200924214152859"></p>
<p>首先到官网下载logstash：<a href="https://www.elastic.co/cn/downloads/logstash">https://www.elastic.co/cn/downloads/logstash</a></p>
<p>选择我们需要下载的版本：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095425.png" alt="image-20200924215805219"></p>
<p>下载完成后，使用xftp工具，将其丢入到服务器中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#检查jdk环境，要求jdk1.8+</span></span><br><span class="line">java -version</span><br><span class="line"></span><br><span class="line"><span class="comment">#解压安装包</span></span><br><span class="line">tar -xvf logstash-7.9.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#第一个logstash示例</span></span><br><span class="line">bin/logstash -e <span class="string">&#x27;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>其实原来的logstash的作用，就是为了做数据的采集，但是因为logstash的速度比较慢，所以后面使用beats来代替了Logstash，当我们使用上面的命令进行启动的时候，就可以发现了，因为logstash使用java写的，首先需要启动虚拟机，最后下图就是启动完成的截图</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095426.png" alt="image-20200924221006644"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们在控制台输入 hello，马上就能看到它的输出信息</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095427.png" alt="image-20200924221052791"></p>
<h2 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h2><p>Logstash的配置有三部分，如下所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123; <span class="comment">#输入</span></span><br><span class="line">stdin &#123; ... &#125; <span class="comment">#标准输入</span></span><br><span class="line">&#125;</span><br><span class="line">filter &#123; <span class="comment">#过滤，对数据进行分割、截取等处理</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">output &#123; <span class="comment">#输出</span></span><br><span class="line">stdout &#123; ... &#125; <span class="comment">#标准输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><ul>
<li>采集各种样式、大小和来源的数据，数据往往以各种各样的形式，或分散或集中地存在于很多系统中。</li>
<li>Logstash 支持各种输入选择 ，可以在同一时间从众多常用来源捕捉事件。能够以连续的流式传输方式，轻松地从您的日志、指标、Web 应用、数据存储以及各种 AWS 服务采集数据。</li>
</ul>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095428.png" alt="image-20200924221256569"></p>
<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><ul>
<li>实时解析和转换数据</li>
<li>数据从源传输到存储库的过程中，Logstash 过滤器能够解析各个事件，识别已命名的字段以构建结构，并将它们转换成通用格式，以便更轻松、更快速地分析和实现商业价值。</li>
</ul>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095429.png" alt="image-20200924221459397"></p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>Logstash 提供众多输出选择，您可以将数据发送到您要指定的地方，并且能够灵活地解锁众多下游用例。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095430.png" alt="image-20200924221528089"></p>
<h2 id="读取自定义日志"><a href="#读取自定义日志" class="headerlink" title="读取自定义日志"></a>读取自定义日志</h2><p>前面我们通过Filebeat读取了nginx的日志，如果是自定义结构的日志，就需要读取处理后才能使用，所以，这个时候就需要使用Logstash了，因为Logstash有着强大的处理能力，可以应对各种各样的场景。</p>
<h3 id="日志结构"><a href="#日志结构" class="headerlink" title="日志结构"></a>日志结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2019-03-15 21:21:21|ERROR|1 读取数据出错|参数：id=1002</span><br></pre></td></tr></table></figure>
<p>可以看到，日志中的内容是使用“|”进行分割的，使用，我们在处理的时候，也需要对数据做分割处理。</p>
<h3 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim mogublog-pipeline.conf</span><br></pre></td></tr></table></figure>
<p>然后添加如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    file &#123;</span><br><span class="line">        path =&gt; <span class="string">&quot;/soft/beats/logs/app.log&quot;</span></span><br><span class="line">        start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    mutate &#123;</span><br><span class="line">    	split =&gt; &#123;<span class="string">&quot;message&quot;</span>=&gt;<span class="string">&quot;|&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">	stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">./bin/logstash -f ./mogublog-pipeline.conf</span><br></pre></td></tr></table></figure>
<p>然后我们就插入我们的测试数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2019-03-15 21:21:21|ERROR|读取数据出错|参数：id=1002&quot;</span> &gt;&gt; app.log</span><br></pre></td></tr></table></figure>
<p>然后我们就可以看到logstash就会捕获到刚刚我们插入的数据，同时我们的数据也被分割了</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095431.png" alt="image-20200924224710757"></p>
<h3 id="输出到Elasticsearch"><a href="#输出到Elasticsearch" class="headerlink" title="输出到Elasticsearch"></a>输出到Elasticsearch</h3><p>我们可以修改我们的配置文件，将我们的日志记录输出到ElasticSearch中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    file &#123;</span><br><span class="line">        path =&gt; <span class="string">&quot;/soft/beats/logs/app.log&quot;</span></span><br><span class="line">        start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    mutate &#123;</span><br><span class="line">    	split =&gt; &#123;<span class="string">&quot;message&quot;</span>=&gt;<span class="string">&quot;|&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">	elasticsearch &#123;</span><br><span class="line">		hosts =&gt; [<span class="string">&quot;127.0.0.1:9200&quot;</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在重启我们的logstash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/logstash -f ./mogublog-pipeline.conf</span><br></pre></td></tr></table></figure>
<p>然后向日志记录中，插入两条数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2019-03-15 21:21:21|ERROR|读取数据出错|参数：id=1002&quot;</span> &gt;&gt; app.log</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2019-03-15 21:21:21|ERROR|读取数据出错|参数：id=1002&quot;</span> &gt;&gt; app.log</span><br></pre></td></tr></table></figure>
<p>最后就能够看到我们刚刚插入的数据了</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095432.png" alt="image-20200924230314560"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>ELK</category>
        <category>Logstash</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>Logstash</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis &lt;if&gt;标签的使用问题</title>
    <url>/2021/01/07/Mybatis%20%EF%BC%9Cif%EF%BC%9E%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mybatis-标签的使用问题"><a href="#Mybatis-标签的使用问题" class="headerlink" title="Mybatis 标签的使用问题"></a>Mybatis <if>标签的使用问题</h1><p>今天在使用Mybatis的时候发现前端传参’0’无效，无法更新字段，于是第一想到的就是百度解决，果然百度上已经有不少的案例了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">        update bl_type</span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;typeName!=null and typeNmae!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                    type_name = #&#123;typeName&#125;,</span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;typeBlogCount!=null and typeBlogCount!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                    type_blog_count = #&#123;typeBlogCount&#125;,</span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;enable!=null&quot;</span>&gt;</span></span><br><span class="line">                    enable = #&#123;enable&#125;,</span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where type_id = #&#123;typeId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用mybatis 写mapper.xml文件时，使用if标签如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;typeName!=null and typeNmae!=&#x27;&#x27;&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>这时如果传入的参数为0的话会被忽略掉 无法正常的更新</p>
<p>使用if标签的嵌套经测试也是会忽略参数’0</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">        update bl_type</span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;typeName!=null&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;typeName!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                    type_name = #&#123;typeName&#125;,</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;typeBlogCount!=null&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;typeBlogCount!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                    type_blog_count = #&#123;typeBlogCount&#125;,</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;enable!=null&quot;</span>&gt;</span></span><br><span class="line">                    enable = #&#123;enable&#125;,</span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where type_id = #&#123;typeId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果if标签判断的是字段是否为空字符串也会忽略参数’0’</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">        update bl_type</span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;typeName!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                    type_name = #&#123;typeName&#125;,</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;typeBlogCount!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                    type_blog_count = #&#123;typeBlogCount&#125;,</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;enable!=null&quot;</span>&gt;</span></span><br><span class="line">                    enable = #&#123;enable&#125;,</span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where type_id = #&#123;typeId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结论是if标签只有如以下代码时才不省略参数’’0’：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">        update bl_type</span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;typeName!=null&quot;</span>&gt;</span></span><br><span class="line">                    type_name = #&#123;typeName&#125;,</span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;typeBlogCount!=null&quot;</span>&gt;</span></span><br><span class="line">                    type_blog_count = #&#123;typeBlogCount&#125;,</span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;enable!=null&quot;</span>&gt;</span></span><br><span class="line">                    enable = #&#123;enable&#125;,</span><br><span class="line">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where type_id = #&#123;typeId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么又有问题来了，如果前台传来一个字符串时，某些字段就会被置为空字符串，这个怎么解决呢？</p>
<p>—————————————更新————————————-</p>
<p>问题已解决</p>
<p>为什么会出现这个问题？</p>
<p>因为在mybatis源码中有将空字符串给转换为0这个操作 所以我们传入的参数’0’时就会被判断与空字符串相等 所以if标签的结果值为false</p>
<p><img src="https://img-blog.csdnimg.cn/20200810225335144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ0ODU5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 参考资料：<a href="https://blog.csdn.net/Dongguabai/article/details/82981250">https://blog.csdn.net/Dongguabai/article/details/82981250</a></p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>docker操作</title>
    <url>/2021/03/25/docker%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1 安装docker"></a>1 安装docker</h2><h3 id="1-1-安装依赖包"><a href="#1-1-安装依赖包" class="headerlink" title="1.1 安装依赖包"></a>1.1 安装依赖包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2 </span><br></pre></td></tr></table></figure>
<h3 id="1-2-设置阿里云镜像源"><a href="#1-2-设置阿里云镜像源" class="headerlink" title="1.2 设置阿里云镜像源"></a>1.2 设置阿里云镜像源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo </span><br></pre></td></tr></table></figure>
<h3 id="1-3-安装docker-ce"><a href="#1-3-安装docker-ce" class="headerlink" title="1.3 安装docker-ce"></a>1.3 安装docker-ce</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure>
<h3 id="1-4-启动docker"><a href="#1-4-启动docker" class="headerlink" title="1.4 启动docker"></a>1.4 启动docker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 开机自启</span><br><span class="line">sudo systemctl enable docker </span><br><span class="line"># 启动docker服务  </span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h3 id="1-5镜像加速配置"><a href="#1-5镜像加速配置" class="headerlink" title="1.5镜像加速配置"></a>1.5镜像加速配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加速器地址 ：</span></span><br><span class="line"><span class="comment"># 阿里云控制台搜索容器镜像服务</span></span><br><span class="line"><span class="comment"># 进入容器镜像服务， 左侧最下方容器镜像服务中复制加速器地址</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;你的加速器地址&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h3 id="1-6-镜像查看地址"><a href="#1-6-镜像查看地址" class="headerlink" title="1.6 镜像查看地址"></a>1.6 镜像查看地址</h3><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h2 id="2-docker-安装mysql"><a href="#2-docker-安装mysql" class="headerlink" title="2. docker 安装mysql"></a>2. docker 安装mysql</h2><h3 id="2-1-拉取镜像"><a href="#2-1-拉取镜像" class="headerlink" title="2.1 拉取镜像"></a>2.1 拉取镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>
<h3 id="2-2-查看镜像"><a href="#2-2-查看镜像" class="headerlink" title="2.2 查看镜像"></a>2.2 查看镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<h3 id="2-3-启动容器"><a href="#2-3-启动容器" class="headerlink" title="2.3 启动容器"></a>2.3 启动容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -idt --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>–name 容器的名字</li>
<li>-p 映射的端口号</li>
<li>-e MYSQL_ROOT_PASSWORD mysql的密码</li>
</ul>
<h3 id="2-4-查看容器"><a href="#2-4-查看容器" class="headerlink" title="2.4 查看容器"></a>2.4 查看容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps </span><br></pre></td></tr></table></figure>
<h2 id="3-docker安装minio"><a href="#3-docker安装minio" class="headerlink" title="3. docker安装minio"></a>3. docker安装minio</h2><h3 id="3-1-拉取并运行镜像"><a href="#3-1-拉取并运行镜像" class="headerlink" title="3.1. 拉取并运行镜像"></a>3.1. 拉取并运行镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --privileged -d -it -p 9000:9000 --name minio \</span><br><span class="line">-e <span class="string">&quot;MINIO_ACCESS_KEY=oops&quot;</span> \</span><br><span class="line">--privileged=<span class="literal">true</span> \</span><br><span class="line">-e <span class="string">&quot;MINIO_SECRET_KEY=123456789&quot;</span> \</span><br><span class="line">-v /Users/wsy/docker/minio/data:/data \</span><br><span class="line">-v /Users/wsy/docker/minio/config:/root/.minio \</span><br><span class="line">minio/minio server /data</span><br></pre></td></tr></table></figure>
<h3 id="3-2-打开minio服务端"><a href="#3-2-打开minio服务端" class="headerlink" title="3.2 打开minio服务端"></a>3.2 打开minio服务端</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://localhost:9000</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210411115610.png" alt="image-20210411115604972"></p>
<p>使用启动容器的时候设置的用户名和密码登录</p>
<h2 id="4-docker安装mangodb"><a href="#4-docker安装mangodb" class="headerlink" title="4. docker安装mangodb"></a>4. docker安装mangodb</h2><h3 id="4-1-拉取最新镜像"><a href="#4-1-拉取最新镜像" class="headerlink" title="4.1 拉取最新镜像"></a>4.1 拉取最新镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mongo:latest</span><br></pre></td></tr></table></figure>
<h3 id="4-2-运行容器"><a href="#4-2-运行容器" class="headerlink" title="4.2 运行容器"></a>4.2 运行容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -itd --name mongo -p 27017:27017 mongo --auth</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><strong>-p 27017:27017</strong> ：映射容器服务的 27017 端口到宿主机的 27017 端口。外部可以直接通过 宿主机 ip:27017 访问到 mongo 的服务。</li>
<li><strong>–auth</strong>：需要密码才能访问容器服务。</li>
</ul>
<h3 id="4-3-创建用户"><a href="#4-3-创建用户" class="headerlink" title="4.3 创建用户"></a>4.3 创建用户</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it mongo mongo admin</span><br><span class="line"><span class="comment"># 创建一个名为 admin，密码为 123456 的用户。</span></span><br><span class="line">&gt;  db.createUser(&#123; user:<span class="string">&#x27;admin&#x27;</span>,<span class="built_in">pwd</span>:<span class="string">&#x27;123456&#x27;</span>,roles:[ &#123; role:<span class="string">&#x27;userAdminAnyDatabase&#x27;</span>, db: <span class="string">&#x27;admin&#x27;</span>&#125;,<span class="string">&quot;readWriteAnyDatabase&quot;</span>]&#125;);</span><br><span class="line"><span class="comment"># 尝试使用上面创建的用户信息进行连接。</span></span><br><span class="line">&gt; db.auth(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="5-docker安装redis"><a href="#5-docker安装redis" class="headerlink" title="5. docker安装redis"></a>5. docker安装redis</h2><h3 id="5-1-拉取最新镜像"><a href="#5-1-拉取最新镜像" class="headerlink" title="5.1 拉取最新镜像"></a>5.1 拉取最新镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull redis:latest</span><br></pre></td></tr></table></figure>
<h3 id="5-2-运行容器"><a href="#5-2-运行容器" class="headerlink" title="5.2 运行容器"></a>5.2 运行容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis --privileged=<span class="literal">true</span>\</span><br><span class="line"> -v /Users/wsy/docker/redis/redis.conf:/etc/redis/redis.conf\</span><br><span class="line"> -v /Users/wsy/docker/redis/data:/data \</span><br><span class="line"> -d redis \</span><br><span class="line"> redis-server /etc/redis/redis.conf --appendonly yes --requirepass 123456</span><br></pre></td></tr></table></figure>
<blockquote>
<p>命令分析</p>
<p>–privileged=true 使用该参数container内的root拥有真正的root权限</p>
<p>-p 6379:6379 端口映射：前表示主机部分，：后表示容器部分。</p>
<p>–name redis 指定该容器名称，查看和进行操作都比较方便。</p>
<p>-v 挂载文件或目录 ：前表示主机部分，：后表示容器部分。</p>
<p>-d redis 表示后台启动redis</p>
<p>redis-server /etc/redis/redis.conf<br>以配置文件启动redis，加载容器内的conf文件，最终找到的是挂载的目录/Users/wsy/docker/redis/redis.conf</p>
<p>–appendonly yes 开启redis 持久化</p>
<p>–requirepass 123456 设置密码为123456</p>
</blockquote>
<h3 id="5-3-常见问题"><a href="#5-3-常见问题" class="headerlink" title="5.3 常见问题"></a>5.3 常见问题</h3><p>Docker 自定义配置运行redis自动退出</p>
<ul>
<li>检查配置文件是否设置了<code>daemonize yes</code>，如果是，就要改为<code>daemonize no</code></li>
</ul>
<p>因为该选项让redis成为在后台运行的守护进程而docker容器必须要有一个前台进程才能留存否则容器会自动退出</p>
<p>该博客将持续更新docker安装的操作……</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>dubbo-admin登录问题</title>
    <url>/2021/01/07/dubbo-admin%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="dubbo-admin登录问题"><a href="#dubbo-admin登录问题" class="headerlink" title="dubbo-admin登录问题"></a>dubbo-admin登录问题</h1><p>今天在学习dubbo时，clone了dubbo-admin这个dubbo的后台管理项目，结果配置了密码之后发现一直登录不上，也没有任何报错等消息，经过了不少时间的测试和在网上翻阅博客，发现了原来是配置文件里面有一个坑，我习惯性的认为是配置的是账号与密码，结果发现是配置的root的密码和guest的密码。无语。。。。。<br><img src="https://img-blog.csdnimg.cn/20200915205347940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ0ODU5OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>https定期更新证书</title>
    <url>/2021/01/20/https%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>昨天我的备案刚刚成功就想着将http改成https经过了几个小时的寻找博客，终于成功的将http改成了https，并配置到nginx上，写上定时脚本更新证书</p>
<h2 id="2-背景知识"><a href="#2-背景知识" class="headerlink" title="2.背景知识"></a>2.背景知识</h2><h3 id="2-1http和https是什么？"><a href="#2-1http和https是什么？" class="headerlink" title="2.1http和https是什么？"></a>2.1http和https是什么？</h3><p>简单来说，http 是一个传输网页内容的协议，比如你看到的 http 开头的网站 <a href="http://www.163.com/">http://www.163.com</a> ，其网页上的文字、图片、 CSS 、 JS 等文件都是通过 http 协议传输到我们的浏览器，然后被我们看到。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210120131217.png" alt="image-20210120124933946"></p>
<p>而 https 可以理解为“ HTTP over SSL/TLS ”，好端端的 http 为什么需要“ over SSL/TLS ”呢，因为 http 是明文传输的，通过 http 协议传输的内容很容易被偷看和篡改，为了安全（你肯定不想被人偷看或者篡改网页内容吧，比如网站银行密码什么的。）就为 http 协议再加上了一层 SSL/TLS 安全协议，所以就有了 https 。</p>
<h3 id="2-2SSL-TLS-是什么？"><a href="#2-2SSL-TLS-是什么？" class="headerlink" title="2.2SSL/TLS 是什么？"></a>2.2SSL/TLS 是什么？</h3><p>“ HTTP over SSL/TLS ”字面意思就是带”安全套接层”的 http 协议，内心纯洁的同学也可以理解为“带安全套的 http ”，因为带了安全套，所以当然会比较安全。其中 SSL 是“ Secure Sockets Layer ” 的缩写，是“安全套接层”的意思。 TLS 是 “Transport Layer Security” 的缩写，是 ” 传输层安全协议 ” 的意思。 SSL 和 TLS 是同一个东西的不同阶段，理解为同一个东西也行，都是安全协议就对了。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210120131218.png" alt="image-20210120125014624"></p>
<h3 id="2-3为什么要部署-https？"><a href="#2-3为什么要部署-https？" class="headerlink" title="2.3为什么要部署 https？"></a>2.3为什么要部署 https？</h3><p>说到底，就是 https 更安全。甚至为了安全，一个专业可靠的网站， https 是必须的。 Firefox 和 Chrome 都计划将没有配置 SSL 加密的 http 网站标记为不安全（貌似 Firefox 50 已经这么干了），目前它们也正在联合其他相关的基金会与公司推动整个互联网 https 化，现在大家访问的一些主要的网站。如 Google 多年前就已经全部启用 https ，国内的淘宝、搜狗、知乎、百度等等也全面 https 了。甚至 Google 的搜索结果也正在给予 https 的网站更高的排名和优先收录权。</p>
<h3 id="2-4怎么部署-https-呢？"><a href="#2-4怎么部署-https-呢？" class="headerlink" title="2.4怎么部署 https 呢？"></a>2.4怎么部署 https 呢？</h3><p>你只需要有一张被信任的 CA （ Certificate Authority ）也就是证书授权中心颁发的 SSL 安全证书，并且将它部署到你的网站服务器上。一旦部署成功后，当用户访问你的网站时，浏览器会在显示的网址前加一把小绿锁，表明这个网站是安全的，当然同时你也会看到网址前的前缀变成了 https ，不再是 http 了。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210120131219.png" alt="image-20210120125114719"></p>
<h3 id="2-5怎么获得-SSL-安全证书呢？"><a href="#2-5怎么获得-SSL-安全证书呢？" class="headerlink" title="2.5怎么获得 SSL 安全证书呢？"></a>2.5怎么获得 SSL 安全证书呢？</h3><p>理论上，我们自己也可以签发 SSL 安全证书，但是我们自己签发的安全证书不会被主流的浏览器信任，所以我们需要被信任的证书授权中心（ CA ）签发的安全证书。而一般的 SSL 安全证书签发服务都比较贵，比如 Godaddy 、 GlobalSign 等机构签发的证书一般都需要20美金一年甚至更贵，不过为了加快推广 https 的普及， EEF 电子前哨基金会、 Mozilla 基金会和美国密歇根大学成立了一个公益组织叫 ISRG （ Internet Security Research Group ），这个组织从 2015 年开始推出了 Let’s Encrypt 免费证书。这个免费证书不仅免费，而且还相当好用，所以我们就可以利用 Let’s Encrypt 提供的免费证书部署 https 了。那么怎么获得 Let’s Encrypt 安全证书，并且将它部署在自己的网站服务器上呢？这就是这篇文章要讲的内容了。</p>
<h2 id="3-Let’s-Encrypt-及-Certbot-简介"><a href="#3-Let’s-Encrypt-及-Certbot-简介" class="headerlink" title="3.Let’s Encrypt 及 Certbot 简介"></a>3.Let’s Encrypt 及 Certbot 简介</h2><p>前面已经介绍过， Let’s Encrypt 是 一个叫 ISRG （ Internet Security Research Group ，互联网安全研究小组）的组织推出的免费安全证书计划。参与这个计划的组织和公司可以说是互联网顶顶重要的先驱，除了前文提到的三个牛气哄哄的发起单位外，后来又有思科（全球网络设备制造商执牛耳者）、 Akamai 加入，甚至连 Linux 基金会也加入了合作，这些大牌组织的加入保证了这个项目的可信度和可持续性。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210120131220.png" alt="image-20210120125200888"></p>
<p>后来 ISRG 的发起者 EFF （电子前哨基金会）为 Let’s Encrypt 项目发布了一个官方的客户端 Certbot ，利用它可以完全自动化的获取、部署和更新安全证书。这真是非常容易、方便呀，所以我们就可以直接使用官方客户端，不需要再使用第三方的工具了。虽然第三方工具也可以使用，但是官方工具更权威，风险也更小，而且遇到问题也更容易解决，毕竟有官方的支持。何况 Certbot 确实非常方便，也比所有的第三方工具都更方便，何乐而不用呢?</p>
<h3 id="3-1Authenticators和Installers"><a href="#3-1Authenticators和Installers" class="headerlink" title="3.1Authenticators和Installers"></a>3.1Authenticators和Installers</h3><p>Certbot支持两种类型的plugin，一种是用来获取和安装证书的，成为称为Authenticators；<br>另外一种是用来安装证书的，称为Installers。有的plugin支持一种，有的两种都支持，如nginx。<br>Authenticators plugin使用certonly命令来获取证书，而Installers plugin使用install命令来安装证书。</p>
<h3 id="3-2plugin说明"><a href="#3-2plugin说明" class="headerlink" title="3.2plugin说明"></a>3.2plugin说明</h3><p>下面列举几个常用的plugin作简要说明：</p>
<ul>
<li><p><strong>Webroot：</strong>本地有运行webserver并且有能力修改其配置，就可以用该种方式（创建隐藏文件.well-known），获取证书时无需暂停webserver的运行。</p>
</li>
<li><p><strong>Standalone：</strong>服务器未运行webserver可以使用该方式，要保持80或443端口开放。</p>
</li>
<li><p><strong>Nginx：</strong>自动获取和安装证书（自动修改配置文件）。</p>
<p>4Certbot 为 nginx 配置证书</p>
</li>
</ul>
<h2 id="4-Certbot-为-nginx-配置证书"><a href="#4-Certbot-为-nginx-配置证书" class="headerlink" title="4.Certbot 为 nginx 配置证书"></a>4.Certbot 为 nginx 配置证书</h2><h3 id="4-1安装certbot"><a href="#4-1安装certbot" class="headerlink" title="4.1安装certbot"></a>4.1安装certbot</h3><p>Certbot 的官方网站是 <a href="https://certbot.eff.org/">https://certbot.eff.org/</a> ，打开这个链接选择自己使用的 web server 和操作系统，EFF 官方会给出详细的使用方法，以下以本网站域名（ bbs.wzlinux.com ）举例。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210120131221.png" alt="image-20210120125626689"></p>
<p>我们的系统环境为 CentOS 7，Web 服务器为 epel 源中的 nginx，只是为了掩饰安装证书，没有做什么网页，大家了解这个过程为主，我们使用下面命令进行安装 certbot。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install certbot python2-certbot-nginx</span><br></pre></td></tr></table></figure>
<h3 id="4-2生成证书"><a href="#4-2生成证书" class="headerlink" title="4.2生成证书"></a>4.2生成证书</h3><p>我们在使用 certbot 生成证书之前，要把域名解析到当前的服务器，使用令生<code>certbot --nginx</code>成证书，并且会帮我们自动配置到 nginx 上面，过程中需要我们输入邮箱地址。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@lnmp-1 ~] certbot --nginx</span><br><span class="line">Saving debug <span class="built_in">log</span> to /var/<span class="built_in">log</span>/letsencrypt/letsencrypt.log</span><br><span class="line">Plugins selected: Authenticator nginx, Installer nginx</span><br><span class="line">Enter email address (used <span class="keyword">for</span> urgent renewal and security notices) (Enter <span class="string">&#x27;c&#x27;</span> to</span><br><span class="line">cancel): pink_oops@163.com</span><br><span class="line">Starting new HTTPS connection (1): acme-v02.api.letsencrypt.org</span><br><span class="line"> </span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Please <span class="built_in">read</span> the Terms of Service at</span><br><span class="line">https://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf. You must</span><br><span class="line">agree <span class="keyword">in</span> order to register with the ACME server at</span><br><span class="line">https://acme-v02.api.letsencrypt.org/directory</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">(A)gree/(C)ancel: A</span><br><span class="line"> </span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Would you be willing to share your email address with the Electronic Frontier</span><br><span class="line">Foundation, a founding partner of the Let<span class="string">&#x27;s Encrypt project and the non-profit</span></span><br><span class="line"><span class="string">organization that develops Certbot? We&#x27;</span>d like to send you email about our work</span><br><span class="line">encrypting the web, EFF news, campaigns, and ways to support digital freedom.</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">(Y)es/(N)o: Y</span><br><span class="line">Starting new HTTPS connection (1): supporters.eff.org</span><br><span class="line">No names were found <span class="keyword">in</span> your configuration files. Please enter <span class="keyword">in</span> your domain</span><br><span class="line">name(s) (comma and/or space separated)  (Enter <span class="string">&#x27;c&#x27;</span> to cancel): bbs.wzlinux.com</span><br><span class="line">Obtaining a new certificate</span><br><span class="line">Performing the following challenges:</span><br><span class="line">http-01 challenge <span class="keyword">for</span> bbs.wzlinux.com</span><br><span class="line">Waiting <span class="keyword">for</span> verification...</span><br><span class="line">Cleaning up challenges</span><br><span class="line">Resetting dropped connection: acme-v02.api.letsencrypt.org</span><br><span class="line">Deploying Certificate to VirtualHost /etc/nginx/nginx.conf</span><br><span class="line"> </span><br><span class="line">Please choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">1: No redirect - Make no further changes to the webserver configuration.</span><br><span class="line">2: Redirect - Make all requests redirect to secure HTTPS access. Choose this <span class="keyword">for</span></span><br><span class="line">new sites, or <span class="keyword">if</span> you<span class="string">&#x27;re confident your site works on HTTPS. You can undo this</span></span><br><span class="line"><span class="string">change by editing your web server&#x27;</span>s configuration.</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Select the appropriate number [1-2] <span class="keyword">then</span> [enter] (press <span class="string">&#x27;c&#x27;</span> to cancel): 2</span><br><span class="line">Redirecting all traffic on port 80 to ssl <span class="keyword">in</span> /etc/nginx/nginx.conf</span><br><span class="line"> </span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Congratulations! You have successfully enabled https://bbs.wzlinux.com</span><br><span class="line"> </span><br><span class="line">You should <span class="built_in">test</span> your configuration at:</span><br><span class="line">https://www.ssllabs.com/ssltest/analyze.html?d=bbs.wzlinux.com</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"> </span><br><span class="line">IMPORTANT NOTES:</span><br><span class="line"> - Congratulations! Your certificate and chain have been saved at:</span><br><span class="line">   /etc/letsencrypt/live/bbs.wzlinux.com/fullchain.pem</span><br><span class="line">   Your key file has been saved at:</span><br><span class="line">   /etc/letsencrypt/live/bbs.wzlinux.com/privkey.pem</span><br><span class="line">   Your cert will expire on 2019-07-25. To obtain a new or tweaked</span><br><span class="line">   version of this certificate <span class="keyword">in</span> the future, simply run certbot again</span><br><span class="line">   with the <span class="string">&quot;certonly&quot;</span> option. To non-interactively renew *all* of</span><br><span class="line">   your certificates, run <span class="string">&quot;certbot renew&quot;</span></span><br><span class="line"> - Your account credentials have been saved <span class="keyword">in</span> your Certbot</span><br><span class="line">   configuration directory at /etc/letsencrypt. You should make a</span><br><span class="line">   secure backup of this folder now. This configuration directory will</span><br><span class="line">   also contain certificates and private keys obtained by Certbot so</span><br><span class="line">   making regular backups of this folder is ideal.</span><br><span class="line"> - If you like Certbot, please consider supporting our work by:</span><br><span class="line"> </span><br><span class="line">   Donating to ISRG / Let<span class="string">&#x27;s Encrypt:   https://letsencrypt.org/donate</span></span><br><span class="line"><span class="string">   Donating to EFF:                    https://eff.org/donate-le</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3配置证书"><a href="#4-3配置证书" class="headerlink" title="4.3配置证书"></a>4.3配置证书</h3><p>目前已经自动帮我们配置证书了，我们可以看下配置的形式，后续可以自己配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  server &#123;</span><br><span class="line">      listen 443 ssl; # managed by Certbot</span><br><span class="line">      server_name  oopsw.top www.oopsw.top;</span><br><span class="line">      ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;oopsw.top&#x2F;fullchain.pem; # managed by Certbot</span><br><span class="line">      ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;oopsw.top&#x2F;privkey.pem; # managed by Certbot</span><br><span class="line">      include &#x2F;etc&#x2F;letsencrypt&#x2F;options-ssl-nginx.conf; # managed by Certbot</span><br><span class="line">      ssl_dhparam &#x2F;etc&#x2F;letsencrypt&#x2F;ssl-dhparams.pem; # managed by Certbot</span><br><span class="line">      location &#x2F; &#123;</span><br><span class="line">          root   &#x2F;var&#x2F;www&#x2F;hexo&#x2F;;</span><br><span class="line">          index  index.html index.htm;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-更新证书"><a href="#5-更新证书" class="headerlink" title="5.更新证书"></a>5.更新证书</h2><p>出于安全策略， Let’s Encrypt 签发的证书有效期只有 90 天，所以需要每隔三个月就要更新一次安全证书，虽然有点麻烦，但是为了网络安全，这是值得的也是应该的。好在 Certbot 也提供了很方便的更新方法。</p>
<h3 id="5-1linux添加定时任务crond"><a href="#5-1linux添加定时任务crond" class="headerlink" title="5.1linux添加定时任务crond"></a>5.1linux添加定时任务crond</h3><h4 id="5-1-1crontab-–e-编辑当前定时任务"><a href="#5-1-1crontab-–e-编辑当前定时任务" class="headerlink" title="5.1.1crontab –e:编辑当前定时任务"></a>5.1.1crontab –e:编辑当前定时任务</h4><p>保存完重新crond :</p>
<p>service crond restart</p>
<h4 id="5-1-2crontab用法"><a href="#5-1-2crontab用法" class="headerlink" title="5.1.2crontab用法"></a>5.1.2crontab用法</h4><ul>
<li>crontab –e : 修改 crontab 文件，如果文件不存在会自动创建。 </li>
<li>crontab –l : 显示 crontab 文件。 </li>
<li>crontab -r : 删除 crontab 文件。</li>
<li>crontab -ir : 删除 crontab 文件前提醒用户。</li>
</ul>
<p>在crontab文件中写入需要执行的命令和时间，该文件中每行都包括六个域，其中前五个域是指定命令被执行的时间，最后一个域是要被执行的命令。每个域之间使用空格或者制表符分隔。格式如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">minute hour day-of-month month-of-year day-of-week commands  </span><br></pre></td></tr></table></figure>
<p>合法值为：00-59 00-23 01-31 01-12 0-6 (0 is sunday) </p>
<p>除了数字还有几个特殊的符号：”*”、”/“和”-“、”,”</p>
<ul>
<li>*代表所有的取值范围内的数字</li>
<li>“/“代表每的意思,”/5”表示每5个单位</li>
<li>“-“代表从某个数字到某个数字</li>
<li>“,”分开几个离散的数字</li>
</ul>
<p><strong>注</strong>：commands 注意以下几点</p>
<ul>
<li>要是存在文件，要写绝对路径</li>
<li>即使是打印也不会显示在显示屏，在后台运行，最好重定向日志</li>
</ul>
<h3 id="5-2添加定时任务更新证书"><a href="#5-2添加定时任务更新证书" class="headerlink" title="5.2添加定时任务更新证书"></a>5.2添加定时任务更新证书</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">crontab –e</span><br></pre></td></tr></table></figure>
<p>添加以下文本</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0 0,12 * * * python -c &#x27;import random; import time; time.sleep(random.random() * 3600)&#x27; &amp;&amp; certbot renew</span><br></pre></td></tr></table></figure>
<p>然后保存退出即可</p>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/wangzan18/article/details/89579427?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control">https://blog.csdn.net/wangzan18/article/details/89579427?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control</a></p>
<p><a href="https://www.cnblogs.com/wangzhuxing/p/6169847.html">https://www.cnblogs.com/wangzhuxing/p/6169847.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro+redis整合实现session持久化登陆失败时也会生成session问题</title>
    <url>/2021/01/07/shiro+redis%E6%95%B4%E5%90%88%E5%AE%9E%E7%8E%B0session%E6%8C%81%E4%B9%85%E5%8C%96%E7%99%BB%E9%99%86%E5%A4%B1%E8%B4%A5%E6%97%B6%E4%B9%9F%E4%BC%9A%E7%94%9F%E6%88%90session%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在给博客更新，将session存到redis中持久化存储，正常操作是没问题的，但是后来尝试发现，在我输入的密码是错误的时候，他也创建了session，经过我的一番从尾到头的debug。。。。<br>复杂的debug过程就不贴出来了，放出问题的根源<br>在登陆时，会访问到我用来记录日志的切面,而我的记录日志方法中有一个需要获取到当前登录的用户的信息，来完善日志的字段</p>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9126eb184f07ef4079eddf3e1361a4c4.png" alt="image.png"><br>以下是工具类中的原方法：<br><img src="https://img-blog.csdnimg.cn/img_convert/7cd9178191e483f567ef7b0f94e7ffae.png" alt="image.png"><br>以下是修改后的方法<br><img src="https://img-blog.csdnimg.cn/img_convert/be57bae0b018c7e7f5257c8f40856bd8.png" alt="image.png"><br>这就是问题的根源，因为在我登录的时候，要记录日志，然后去调用工具类，工具类去获取session，如果没有getSession(false)的话，就会判断session是否存在，如果不存在的话就会自动创建session，这就是为什么明明密码错了还会创建session的原因</p>
</blockquote>
]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>shiroFilter踩坑</title>
    <url>/2021/01/07/shiroFilter%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="shiroFilter踩坑"><a href="#shiroFilter踩坑" class="headerlink" title="shiroFilter踩坑"></a>shiroFilter踩坑</h1><p>今天出门了一趟，没有关电脑，服务器一直开着，回来发现某一些shiro设置了放行的后端接口竟然无法访问了。经过一段时间的debug，总的来说找到了原因，就是shiro过滤器的问题，通过搜索资料找到了问题根源。原来是HashMap和LinkedMap的问题。 我使用的是HashMap，HashMap不会按照顺序去存储，而shiro有个要求，就是”<strong>authc”</strong> 这个权限必须得放在放行权限的后面”<strong>anon</strong>“。所以使用HashMap时会导致某一些需要放行的接口被放在了authc下面，导致放行无效。</p>
]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 后端传给前端相差8小时</title>
    <url>/2021/01/07/springboot%20%E5%90%8E%E7%AB%AF%E4%BC%A0%E7%BB%99%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%B7%AE8%E5%B0%8F%E6%97%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 在开发中日期最常打交道的东西之一，但是日期又会存在各式各样的格式，常见的情形就是，从数据库取出的日期往往都是时间戳（毫秒数）的形式，这个一般情况下是前端不想要的结果，需要进行处理，那在springboot中比较简单：<br>因为后端传给前端时默认使用jackson转换格式所以我们可以</p>
<ol>
<li>在application.yml中设置<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br></pre></td></tr></table></figure></li>
<li>在pojo对象上添加@JsonFormat注解<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date createdTime;</span><br></pre></td></tr></table></figure>
但是我在尝试了这两个方法以及相类似的方法，但是都无效，要么就是格式化无效，直接返回的时间戳，要么就是时间还是相差8个小时，但是格式化有效。</li>
</ol>
<p>这时我看到了另外一篇不一样的博客，随后明白了为什么我的配置没有用，原来是因为我添加拦截器时写的配置类的问题。<br>以下代码是我更改之前的配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.blog.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.DeserializationFeature;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.wsy.blog.interceptor.LoginInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/8/10 11:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoginInterceptor <span class="title">getLoginInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoginInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry  拦截器注册</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        registry.addInterceptor(getLoginInterceptor()).addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/*/login&quot;</span>);;</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里大家注意，看看自己的代码有没有因为添加拦截器而创建了一个配置类，该类继承了<code>WebMvcConfigurationSupport</code>，就是他！以前是用 <code>WebMvcConfigurerAdapter</code> ，springboot 2.0 建议使用 <code>WebMvcConfigurationSupport</code> 。但是在添加拦截器并继承 <code>WebMvcConfigurationSupport</code> 后会覆盖<code>@EnableAutoConfiguration</code>关于<code>WebMvcAutoConfiguration</code>的配置！从而导致所有的Date返回都变成时间戳！<br>可以采用另外一种方式，在你继承<code>WebMvcConfigurationSupport</code>的子类中添加日期转换的bean<br>以下是我更改后的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.blog.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.DeserializationFeature;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.wsy.blog.interceptor.LoginInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/8/10 11:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoginInterceptor <span class="title">getLoginInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoginInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义时间格式转换器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  MappingJackson2HttpMessageConverter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappingJackson2HttpMessageConverter <span class="title">jackson2HttpMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MappingJackson2HttpMessageConverter converter = <span class="keyword">new</span> MappingJackson2HttpMessageConverter();</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">        mapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        converter.setObjectMapper(mapper);</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加转换器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converters    converters</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将我们定义的时间格式转换器添加到转换器列表中,</span></span><br><span class="line">        <span class="comment">//这样jackson格式化时候但凡遇到Date类型就会转换成我们定义的格式</span></span><br><span class="line">        converters.add(jackson2HttpMessageConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry  拦截器注册</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        registry.addInterceptor(getLoginInterceptor()).addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/*/login&quot;</span>);;</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 感谢博主的分享经验<br>参考博客：<a href="https://blog.csdn.net/qq_34975710/article/details/84872489">https://blog.csdn.net/qq_34975710/article/details/84872489</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表学习笔记</title>
    <url>/2021/01/17/%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1.哈希表"></a>1.哈希表</h2><h3 id="1-1-哈希表-散列-Google-上机题"><a href="#1-1-哈希表-散列-Google-上机题" class="headerlink" title="1.1 哈希表(散列)-Google 上机题"></a>1.1 哈希表(散列)-Google 上机题</h3><ol>
<li><p>看一个实际需求，google 公司的一个上机题: </p>
</li>
<li><p>有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,住址..),当输入该员工的 id 时,要求查 找到该员工的 所有信息. </p>
</li>
<li><p>要求: 不使用数据库,尽量节省内存,速度越快越好=&gt;哈希表(散列)</p>
</li>
</ol>
<h3 id="1-2-哈希表的基本介绍"><a href="#1-2-哈希表的基本介绍" class="headerlink" title="1.2 哈希表的基本介绍"></a>1.2 哈希表的基本介绍</h3><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通 过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组 叫做散列表。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210117151659.png" alt="image-20210117151611781"></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210117151700.png" alt="image-20210117151618499"></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210117151701.png" alt="image-20210117151628457"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.hashTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-17 14:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建哈希表</span></span><br><span class="line">        HashTable hashTab = <span class="keyword">new</span> HashTable(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写一个简单的菜单</span></span><br><span class="line">        String key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;add:  添加雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;list: 显示雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;find: 查找雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;delete: 删除雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit: 退出系统&quot;</span>);</span><br><span class="line"></span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入id&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> id = scanner.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入名字&quot;</span>);</span><br><span class="line">                    String name = scanner.next();</span><br><span class="line">                    <span class="comment">//创建 雇员</span></span><br><span class="line">                    Emp emp = <span class="keyword">new</span> Emp(id, name);</span><br><span class="line">                    hashTab.add(emp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;list&quot;</span>:</span><br><span class="line">                    hashTab.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;find&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入要查找的id&quot;</span>);</span><br><span class="line">                    id = scanner.nextInt();</span><br><span class="line">                    hashTab.findEmpById(id);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;delete&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入要删除的id&quot;</span>);</span><br><span class="line">                    id = scanner.nextInt();</span><br><span class="line">                    hashTab.deleteEmpById(id);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EmpLinkedList[] empLinkedListArray;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        empLinkedListArray = <span class="keyword">new</span> EmpLinkedList[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; empLinkedListArray.length; i++) &#123;</span><br><span class="line">            empLinkedListArray[i] = <span class="keyword">new</span> EmpLinkedList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> emp 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> empLinkedListIndex = hash(emp.id);</span><br><span class="line">        empLinkedListArray[empLinkedListIndex].add(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; empLinkedListArray.length; i++) &#123;</span><br><span class="line">            empLinkedListArray[i].list(i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> empLinkedListIndex = hash(id);</span><br><span class="line">        Emp emp = empLinkedListArray[empLinkedListIndex].find(id);</span><br><span class="line">        <span class="keyword">if</span> (emp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到该节点&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在第&quot;</span> + (empLinkedListIndex + <span class="number">1</span>) + <span class="string">&quot;条链表找到了&quot;</span> + emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> empLinkedListIndex = hash(id);</span><br><span class="line">        Emp emp = empLinkedListArray[empLinkedListIndex].delete(id);</span><br><span class="line">        <span class="keyword">if</span> (emp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到该节点&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在第&quot;</span> + (empLinkedListIndex + <span class="number">1</span>) + <span class="string">&quot;条删除了了&quot;</span> + emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 散列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id % <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 雇员链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmpLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Emp head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> emp 雇员信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = emp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Emp temp = head;</span><br><span class="line">        <span class="comment">//移动到最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + (no + <span class="number">1</span>) + <span class="string">&quot;条链表为空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Emp temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(temp + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 雇员节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Emp temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span> &amp;&amp; temp.id != id) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除的节点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Emp temp = head;</span><br><span class="line">        Emp lastTemp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果要删除的是头节点</span></span><br><span class="line">        <span class="keyword">if</span> (head.id == id) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span> &amp;&amp; temp.id != id) &#123;</span><br><span class="line">            lastTemp = temp;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastTemp.next = temp.next;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 雇员节点类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Emp next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Emp&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
        <category>HashTable</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title>图学习笔记</title>
    <url>/2021/01/31/%E5%9B%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-图基本介绍"><a href="#1-图基本介绍" class="headerlink" title="1.图基本介绍"></a>1.图基本介绍</h2><h3 id="1-1为什么要有图"><a href="#1-1为什么要有图" class="headerlink" title="1.1为什么要有图"></a>1.1为什么要有图</h3><ol>
<li>前面我们学了线性表和树 </li>
<li>线性表局限于一个直接前驱和一个直接后继的关系</li>
<li>树也只能有一个直接前驱也就是父节点 </li>
<li>当我们需要<strong>表示多对多</strong>的关系时， 这里我们就用到了<strong>图</strong>。</li>
</ol>
<h3 id="1-2图的举例说明"><a href="#1-2图的举例说明" class="headerlink" title="1.2图的举例说明"></a>1.2图的举例说明</h3><p>图是一种<strong>数据结构</strong>，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为 顶点。如图：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210131113756.png" alt="image-20210131112717130"></p>
<h3 id="1-3图的常用概念"><a href="#1-3图的常用概念" class="headerlink" title="1.3图的常用概念"></a>1.3图的常用概念</h3><ol>
<li>顶点(vertex)</li>
<li>边(edge)</li>
<li>路径</li>
<li>无向图<img src="https://gitee.com/Pink_oops/image/raw/master/20210131113757.png" alt="image-20210131112818622"></li>
<li>有向图<img src="https://gitee.com/Pink_oops/image/raw/master/20210131112835.png" alt="image-20210131112835477"></li>
<li>带权图<img src="https://gitee.com/Pink_oops/image/raw/master/20210131112848.png" alt="image-20210131112848510"></li>
</ol>
<h2 id="2-图的表示方式"><a href="#2-图的表示方式" class="headerlink" title="2.图的表示方式"></a>2.图的表示方式</h2><p>图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。</p>
<h3 id="2-1邻接矩阵"><a href="#2-1邻接矩阵" class="headerlink" title="2.1邻接矩阵"></a>2.1邻接矩阵</h3><p>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于 n 个顶点的图而言，矩阵是的 row 和 col 表示的是 1….n 个点。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210131112935.png" alt="image-20210131112935156"></p>
<h3 id="2-2邻接表"><a href="#2-2邻接表" class="headerlink" title="2.2邻接表"></a>2.2邻接表</h3><ol>
<li>邻接矩阵需要为每个顶点都分配 n 个边的空间，其实有很多边都是不存在,会造成空间的一定损失. </li>
<li>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成</li>
<li>举例说明<img src="https://gitee.com/Pink_oops/image/raw/master/20210131113008.png" alt="image-20210131113008489"></li>
</ol>
<h2 id="3-图的快速入门案例"><a href="#3-图的快速入门案例" class="headerlink" title="3.图的快速入门案例"></a>3.图的快速入门案例</h2><p>要求: 代码实现如下图结构.</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210131113028.png" alt="image-20210131113028668"></p>
<p>思路分析 (1) 存储顶点 String 使用 ArrayList (2) 保存矩阵 int[][] edges</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入顶点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> vertex 顶点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.vertexList.add(vertex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 插入边</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> v1     第一个顶点的下标</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> v2     第二个顶点的下标</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> weight 表示连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.edges[v1][v2] = weight;</span><br><span class="line">  <span class="keyword">this</span>.edges[v2][v1] = weight;</span><br><span class="line">  <span class="keyword">this</span>.edgeCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-图的深度优先遍历介绍"><a href="#4-图的深度优先遍历介绍" class="headerlink" title="4.图的深度优先遍历介绍"></a>4.图的深度优先遍历介绍</h2><h3 id="4-1图遍历介绍"><a href="#4-1图遍历介绍" class="headerlink" title="4.1图遍历介绍"></a>4.1图遍历介绍</h3><p>所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种 访问策略: (1)深度优先遍历 (2)广度优先遍历</p>
<h3 id="4-2深度优先遍历基本思想"><a href="#4-2深度优先遍历基本思想" class="headerlink" title="4.2深度优先遍历基本思想"></a>4.2深度优先遍历基本思想</h3><p>图的深度优先搜索(<strong>Depth First Search</strong>) 。</p>
<ol>
<li>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问 第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。</li>
<li>我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。</li>
<li>显然，深度优先搜索是一个递归的过程 </li>
</ol>
<h3 id="4-3深度优先遍历算法步骤"><a href="#4-3深度优先遍历算法步骤" class="headerlink" title="4.3深度优先遍历算法步骤"></a>4.3深度优先遍历算法步骤</h3><ol>
<li>访问初始结点 v，并标记结点 v 为已访问。</li>
<li>查找结点 v 的第一个邻接结点 w。 </li>
<li>若 w 存在，则继续执行 4，如果 w 不存在，则回到第 1 步，将从 v 的下一个结点继续。</li>
<li>若 w 未被访问，对 w 进行深度优先遍历递归（即把 w 当做另一个 v，然后进行步骤 123）。</li>
<li>查找结点 v 的 w 邻接结点的下一个邻接结点，转到步骤 3。</li>
<li>分析图<img src="https://gitee.com/Pink_oops/image/raw/master/20210131113337.png" alt="image-20210131113330972"></li>
</ol>
<h3 id="4-4深度优先算法的代码实现"><a href="#4-4深度优先算法的代码实现" class="headerlink" title="4.4深度优先算法的代码实现"></a>4.4深度优先算法的代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.getNumOfVertex(); i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.isVisited[i]) &#123;</span><br><span class="line">               dfs(<span class="keyword">this</span>.isVisited, i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 深度优先遍历</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> isVisited 是否已遍历数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index     下标</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//首先输出</span></span><br><span class="line">       System.out.print(<span class="keyword">this</span>.getValueByIndex(index) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">       <span class="comment">//将已经输出的顶点设置成已访问</span></span><br><span class="line">       isVisited[index] = <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">//获得第一个邻接节点</span></span><br><span class="line">       <span class="keyword">int</span> w = <span class="keyword">this</span>.getFirstNeighbor(index);</span><br><span class="line">       <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">//如果第一个邻接节点没有被访问则直接递归</span></span><br><span class="line">           <span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">               dfs(isVisited, w);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//获得下一个节点</span></span><br><span class="line">           w = <span class="keyword">this</span>.getNextNeighbor(index, w);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-图的广度优先遍历"><a href="#5-图的广度优先遍历" class="headerlink" title="5.图的广度优先遍历"></a>5.图的广度优先遍历</h2><h3 id="5-1广度优先遍历基本思想"><a href="#5-1广度优先遍历基本思想" class="headerlink" title="5.1广度优先遍历基本思想"></a>5.1广度优先遍历基本思想</h3><ol>
<li>图的广度优先搜索(Broad First Search) 。</li>
<li>类似于一个<strong>分层搜索</strong>的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来 访问这些结点的邻接结点 </li>
</ol>
<h3 id="5-2广度优先遍历算法步骤"><a href="#5-2广度优先遍历算法步骤" class="headerlink" title="5.2广度优先遍历算法步骤"></a>5.2广度优先遍历算法步骤</h3><ol>
<li>访问初始结点 v 并标记结点 v 为已访问。</li>
<li>结点 v 入队列</li>
<li>当队列非空时，继续执行，否则算法结束。</li>
<li>出队列，取得队头结点 u。</li>
<li>查找结点 u 的第一个邻接结点 w。</li>
<li>若结点 u 的邻接结点 w 不存在，则转到步骤 3；否则循环执行以下三个步骤：<ul>
<li>若结点 w 尚未被访问，则访问结点 w 并标记为已访问。 </li>
<li>结点 w 入队列</li>
<li>查找结点 u 的继 w 邻接结点后的下一个邻接结点 w，转到步骤 6。</li>
</ul>
</li>
</ol>
<p>广度优先算法的图示</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210131113652.png" alt="image-20210131113652192"></p>
<h2 id="6-广度优先算法的代码实现"><a href="#6-广度优先算法的代码实现" class="headerlink" title="6.广度优先算法的代码实现"></a>6.广度优先算法的代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i]) &#123;</span><br><span class="line">                bfs(<span class="keyword">this</span>.isVisited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 广度优先搜索</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isVisited 是否被访问的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index     索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="keyword">this</span>.getValueByIndex(index) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//标识已经访问过</span></span><br><span class="line">        isVisited[index] = <span class="keyword">true</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//将访问过的节点放入队列中</span></span><br><span class="line">        queue.addLast(index);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = queue.removeFirst();</span><br><span class="line">            <span class="keyword">int</span> w = <span class="keyword">this</span>.getFirstNeighbor(u);</span><br><span class="line">            <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">                    <span class="comment">//没被访问过的话直接输出并标识已访问并加入队列</span></span><br><span class="line">                    System.out.print(<span class="keyword">this</span>.getValueByIndex(w) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                    isVisited[w] = <span class="keyword">true</span>;</span><br><span class="line">                    queue.addLast(w);</span><br><span class="line">                &#125;</span><br><span class="line">                w = <span class="keyword">this</span>.getNextNeighbor(u, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-代码汇总"><a href="#7-代码汇总" class="headerlink" title="7.代码汇总"></a>7.代码汇总</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/30 7:28 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试一把图是否创建ok</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;  <span class="comment">//结点的个数</span></span><br><span class="line">        String Vertexs[] = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//        String Vertexs[] = &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;&#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(n);</span><br><span class="line">        <span class="comment">//循环的添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex : Vertexs) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// A-B</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新边的关系</span></span><br><span class="line"><span class="comment">//        graph.insertEdge(0, 1, 1);</span></span><br><span class="line"><span class="comment">//        graph.insertEdge(0, 2, 1);</span></span><br><span class="line"><span class="comment">//        graph.insertEdge(1, 3, 1);</span></span><br><span class="line"><span class="comment">//        graph.insertEdge(1, 4, 1);</span></span><br><span class="line"><span class="comment">//        graph.insertEdge(3, 7, 1);</span></span><br><span class="line"><span class="comment">//        graph.insertEdge(4, 7, 1);</span></span><br><span class="line"><span class="comment">//        graph.insertEdge(2, 5, 1);</span></span><br><span class="line"><span class="comment">//        graph.insertEdge(2, 6, 1);</span></span><br><span class="line"><span class="comment">//        graph.insertEdge(5, 6, 1);</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line">        <span class="comment">//测试一把，我们的dfs遍历是否ok</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;深度遍历&quot;);</span></span><br><span class="line"><span class="comment">//        graph.dfs();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;广度优先&quot;</span>);</span><br><span class="line">        graph.bfs();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; vertexList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edgeCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertexList = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">this</span>.edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">this</span>.edgeCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 顶点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 边数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.edgeCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示图相对应的矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(edge));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据index获取vertex</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValueByIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.vertexList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得权值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 行下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 列下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 权值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入顶点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1     第一个顶点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2     第二个顶点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 表示连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.edges[v1][v2] = weight;</span><br><span class="line">        <span class="keyword">this</span>.edges[v2][v1] = weight;</span><br><span class="line">        <span class="keyword">this</span>.edgeCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得邻接节点的第一个节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果存在就返回对应的下标，否则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.vertexList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.edges[index][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据上一个邻接节点获取下一个邻接节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 开始的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 上一个邻接节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个邻接节点 如果不存在则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = v2 + <span class="number">1</span>; i &lt; <span class="keyword">this</span>.vertexList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.edges[v1][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.isVisited[i]) &#123;</span><br><span class="line">                dfs(<span class="keyword">this</span>.isVisited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isVisited 是否已遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index     下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先输出</span></span><br><span class="line">        System.out.print(<span class="keyword">this</span>.getValueByIndex(index) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//将已经输出的顶点设置成已访问</span></span><br><span class="line">        isVisited[index] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//获得第一个邻接节点</span></span><br><span class="line">        <span class="keyword">int</span> w = <span class="keyword">this</span>.getFirstNeighbor(index);</span><br><span class="line">        <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//如果第一个邻接节点没有被访问则直接递归</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">                dfs(isVisited, w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获得下一个节点</span></span><br><span class="line">            w = <span class="keyword">this</span>.getNextNeighbor(index, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i]) &#123;</span><br><span class="line">                bfs(<span class="keyword">this</span>.isVisited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 广度优先搜索</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isVisited 是否被访问的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index     索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="keyword">this</span>.getValueByIndex(index) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//标识已经访问过</span></span><br><span class="line">        isVisited[index] = <span class="keyword">true</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//将访问过的节点放入队列中</span></span><br><span class="line">        queue.addLast(index);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = queue.removeFirst();</span><br><span class="line">            <span class="keyword">int</span> w = <span class="keyword">this</span>.getFirstNeighbor(u);</span><br><span class="line">            <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">                    <span class="comment">//没被访问过的话直接输出并标识已访问并加入队列</span></span><br><span class="line">                    System.out.print(<span class="keyword">this</span>.getValueByIndex(w) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                    isVisited[w] = <span class="keyword">true</span>;</span><br><span class="line">                    queue.addLast(w);</span><br><span class="line">                &#125;</span><br><span class="line">                w = <span class="keyword">this</span>.getNextNeighbor(u, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>数组-长度最小的子数组-滑动窗口</title>
    <url>/2021/02/26/%E6%95%B0%E7%BB%84-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>该博客由我刷leetcode题时的学得的一种解题的思路，该题编号为：209 长度最小的子数组，链接：<a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">https://leetcode-cn.com/problems/minimum-size-subarray-sum/</a></p>
<h3 id="习得思路前"><a href="#习得思路前" class="headerlink" title="习得思路前"></a>习得思路前</h3><p>在不知道这个解题的思路前我考虑的是普通人最常想到的方法，暴力破解法。我贴下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum(nums, j + i, j) &gt;= target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求和</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstIndex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> showIndex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> firstIndex, <span class="keyword">int</span> showIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = showIndex; i &lt;= firstIndex; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p>
<p>我在idea中测试是没有问题的，但是提交在leetcode中报错，超过时间限制了。</p>
<h3 id="习得思路后"><a href="#习得思路后" class="headerlink" title="习得思路后"></a>习得思路后</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> showIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLength = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> subLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            showIndex 滑动窗口的起始位置</span></span><br><span class="line"><span class="comment">            firstIndex 滑动窗口的结束位置</span></span><br><span class="line"><span class="comment">            subLength 滑动窗口的窗口长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> firstIndex = <span class="number">0</span>; firstIndex &lt; nums.length; firstIndex++) &#123;</span><br><span class="line">            sum = sum(nums, firstIndex, showIndex);</span><br><span class="line">            <span class="comment">//如果sum &gt;= target的话就需要记录当前窗口的大小 并且尝试移动窗口的起始位置来缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                subLength = firstIndex - showIndex + <span class="number">1</span>;</span><br><span class="line">                minLength = Math.min(minLength, subLength);</span><br><span class="line">                showIndex++;</span><br><span class="line">                sum = sum(nums, firstIndex, showIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果此时minLength == Integer.MAX_VALUE的话代表还没被赋值过 代表是没有找到子数组所以直接返回0</span></span><br><span class="line">        <span class="keyword">return</span> minLength == Integer.MAX_VALUE ? <span class="number">0</span> : minLength;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求和</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstIndex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> showIndex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> firstIndex, <span class="keyword">int</span> showIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = showIndex; i &lt;= firstIndex; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>接下来就开始介绍数组操作中另一个重要的方法：<strong>「滑动窗口」</strong>。</p>
<p>所谓滑动窗口，<strong>「就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果」</strong>。</p>
<p>这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，</p>
<p>最后找到 4，3 是最短距离。</p>
<p>在本题中实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p>
<p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p>
<p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。</p>
<p>解题的关键在于 窗口的起始位置如何移动，如图所示：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210226182521.png" alt="图片"></p>
<p>可以发现<strong>「滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。」</strong></p>
<p>该滑动窗口教程出自于微信公众号：代码随想录  </p>
<p>链接：<a href="https://mp.weixin.qq.com/s/UrZynlqi4QpyLlLhBPglyg">https://mp.weixin.qq.com/s/UrZynlqi4QpyLlLhBPglyg</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵学习笔记</title>
    <url>/2021/01/07/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-稀疏数组"><a href="#1-稀疏数组" class="headerlink" title="1.稀疏数组"></a>1.稀疏数组</h2><blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107182140.png" alt="image-20210107181603999"></p>
</blockquote>
<h3 id="1-1分析问题"><a href="#1-1分析问题" class="headerlink" title="1.1分析问题"></a>1.1分析问题</h3><p>因为该二维数组的很多值是默认值 0, 因此记录了很多没有意义的数据.-&gt;稀疏数组。</p>
<h3 id="1-2基本介绍"><a href="#1-2基本介绍" class="headerlink" title="1.2基本介绍"></a>1.2基本介绍</h3><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。 稀疏数组的处理方法是: 1) 记录数组一共有几行几列，有多少个不同的值 2) 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</p>
<ul>
<li><p>稀疏数组举例说明</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107182141.png" alt="image-20210107181647446"></p>
</li>
</ul>
<h3 id="1-3应用实例"><a href="#1-3应用实例" class="headerlink" title="1.3应用实例"></a>1.3应用实例</h3><ol>
<li><p>使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等) </p>
</li>
<li><p>把稀疏数组存盘，并且可以从新恢复原来的二维数组数</p>
</li>
<li><p>整体思路分析</p>
</li>
</ol>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107182142.png" alt="image-20210107181808332"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.sparsearray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-28 2:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 稀疏数组实现棋盘的存储和加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArr</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个原始的二维数组 11 * 11</span></span><br><span class="line">        <span class="comment">//0: 表示没有棋子， 1 表示 黑子 2 表蓝子</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        <span class="comment">//设置已经下的棋子</span></span><br><span class="line">        arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        arr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;原数组：&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 遍历  原始的二维数组，得到有效数据的个数 sum</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : arr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : ints) &#123;</span><br><span class="line">                System.out.print(num + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;有效数值共：&quot;</span> + sum);</span><br><span class="line">        <span class="comment">//2. 根据sum 就可以创建 稀疏数组 sparseArr   int[sum + 1] [3]</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparseArr = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//存取稀疏数组第一行 分别存储原数组的行、列、有效数据</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = arr.length;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = arr[<span class="number">0</span>].length;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">        <span class="comment">//3. 将二维数组的有效数据数据存入到 稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                <span class="comment">//如果数组的数据不是0的话就需要存入稀疏矩阵</span></span><br><span class="line">                <span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = arr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.将稀疏数组写入文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;d:/arr.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//如果该文件不存在，就创建</span></span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> newFile = file.createNewFile();</span><br><span class="line">            <span class="keyword">if</span>(newFile) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;成功创建文件！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;稀疏数组：&quot;</span>);</span><br><span class="line">        <span class="comment">//创建文件字符输出流</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : sparseArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : ints) &#123;</span><br><span class="line">                System.out.print(num + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                fw.write(num + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            fw.write(<span class="string">&quot;\t\n&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        fw.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.读取稀疏数组文件恢复稀疏数组</span></span><br><span class="line">        <span class="comment">//创建恢复稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] resotreSparseArr = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//创建文件字符输入流</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">        <span class="comment">//创建字符输入缓冲流</span></span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">        String str;</span><br><span class="line">        <span class="comment">//逐行遍历</span></span><br><span class="line">        <span class="keyword">int</span> line = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((str = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//用\t来做分割</span></span><br><span class="line">            String[] split = str.split(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            resotreSparseArr[line][<span class="number">0</span>] = Integer.parseInt(split[<span class="number">0</span>]);</span><br><span class="line">            resotreSparseArr[line][<span class="number">1</span>] = Integer.parseInt(split[<span class="number">1</span>]);</span><br><span class="line">            resotreSparseArr[line][<span class="number">2</span>] = Integer.parseInt(split[<span class="number">2</span>]);</span><br><span class="line">            line++;</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        fr.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后的稀疏数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : resotreSparseArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : ints) &#123;</span><br><span class="line">                System.out.print(num + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]</span></span><br><span class="line">        <span class="keyword">int</span>[][] restoreArr = <span class="keyword">new</span> <span class="keyword">int</span>[resotreSparseArr[<span class="number">0</span>][<span class="number">0</span>]][resotreSparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">//3. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; resotreSparseArr.length; i++) &#123;</span><br><span class="line">            restoreArr[resotreSparseArr[i][<span class="number">0</span>]][resotreSparseArr[i][<span class="number">1</span>]] = resotreSparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后的源原数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : restoreArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : ints) &#123;</span><br><span class="line">                System.out.print(num + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>递归回溯学习笔记</title>
    <url>/2021/01/08/%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h2><h3 id="1-1递归应用场景"><a href="#1-1递归应用场景" class="headerlink" title="1.1递归应用场景"></a>1.1递归应用场景</h3><p>看个实际应用场景，迷宫问题(回溯)， 递归(Recursion)</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108172010.png" alt="image-20210108153737509"></p>
<h3 id="1-2递归的概念"><a href="#1-2递归的概念" class="headerlink" title="1.2递归的概念"></a>1.2递归的概念</h3><p>简单的说: 递归就是<strong>方法自己调用自己</strong>,每次调用时<strong>传入不同的变量</strong>.递归有助于编程者解决复杂的问题,同时 可以让代码变得简洁。</p>
<h3 id="1-3递归调用机制"><a href="#1-3递归调用机制" class="headerlink" title="1.3递归调用机制"></a>1.3递归调用机制</h3><p>我列举两个小案例,来帮助大家理解递归，部分学员已经学习过递归了，这里在给大家回顾一下递归调用机制</p>
<ol>
<li><p>打印问题 </p>
</li>
<li><p>阶乘问题 </p>
</li>
<li><p>使用图解方式说明了递归的调用机制</p>
</li>
</ol>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108172011.png" alt="image-20210108153832379"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//通过打印问题，回顾递归调用机制</span></span><br><span class="line"><span class="comment">//test(4);</span></span><br><span class="line">        <span class="keyword">int</span> res = factorial(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;res=&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印问题.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            test(n - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="comment">//else &#123;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n=&quot;</span> + n);</span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//阶乘问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n; <span class="comment">// 1 * 2 * 3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4递归能解决什么样的问题"><a href="#1-4递归能解决什么样的问题" class="headerlink" title="1.4递归能解决什么样的问题"></a>1.4递归能解决什么样的问题</h3><p>递归用于解决什么样的问题</p>
<ol>
<li><p>各种数学问题如: 8 皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google 编程大赛) </p>
</li>
<li><p>各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等. </p>
</li>
<li><p>将用栈解决的问题–&gt;递归代码比较简洁</p>
</li>
</ol>
<h4 id="1-5递归需要遵守的重要规则"><a href="#1-5递归需要遵守的重要规则" class="headerlink" title="1.5递归需要遵守的重要规则"></a>1.5递归需要遵守的重要规则</h4><p>递归需要遵守的重要规则</p>
<ol>
<li><p>执行一个方法时，就创建一个新的受保护的独立空间(栈空间) </p>
</li>
<li><p>方法的局部变量是独立的，不会相互影响, 比如 n 变量 </p>
</li>
<li><p>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据. </p>
</li>
<li><p>递归必须向退出递归的条件逼近，否则就是无限递归,出现 StackOverflowError，死龟了:) </p>
</li>
<li><p>当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或 者返回时，该方法也就执行完毕</p>
</li>
</ol>
<h3 id="1-6递归-迷宫问题"><a href="#1-6递归-迷宫问题" class="headerlink" title="1.6递归-迷宫问题"></a>1.6递归-迷宫问题</h3><h4 id="1-6-1迷宫问题"><a href="#1-6-1迷宫问题" class="headerlink" title="1.6.1迷宫问题"></a>1.6.1迷宫问题</h4><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108172012.png" alt="image-20210108170740965"></p>
<h4 id="1-6-2代码实现"><a href="#1-6-2代码实现" class="headerlink" title="1.6.2代码实现"></a>1.6.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.recursion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-01 13:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 迷宫</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Maze</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个大小为8行7列的地图</span></span><br><span class="line">        <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">// 使用1 表示墙</span></span><br><span class="line">        <span class="comment">// 上下全部置为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左右全部置为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置挡板, 1 表示</span></span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//		map[1][2] = 1;</span></span><br><span class="line"><span class="comment">//		map[2][2] = 1;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出地图</span></span><br><span class="line">        System.out.println(<span class="string">&quot;地图的情况&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用递归回溯给小球找路</span></span><br><span class="line">        setWay(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出新的地图, 小球走过，并标识过的递归</span></span><br><span class="line">        System.out.println(<span class="string">&quot;小球走过，并标识过的 地图的情况&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * //使用递归回溯来给小球找路</span></span><br><span class="line"><span class="comment">     * //说明</span></span><br><span class="line"><span class="comment">     * //1. map 表示地图</span></span><br><span class="line"><span class="comment">     * //2. i,j 表示从地图的哪个位置开始出发 (1,1)</span></span><br><span class="line"><span class="comment">     * //3. 如果小球能到 map[6][5] 位置，则说明通路找到.</span></span><br><span class="line"><span class="comment">     * //4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙  ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通</span></span><br><span class="line"><span class="comment">     * //5. 在走迷宫时，需要确定一个策略(方法) 右-&gt;下-&gt;左-&gt;上 , 如果该点走不通，再回溯</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 地图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i   表示地图开始的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j   表示地图开始的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>+(++count)+<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">7</span>; l++) &#123;</span><br><span class="line">                System.out.print(map[k][l] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//map[6][5]代表终点 如果终点被标注为2了代表已经走通了 直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果该点还没有走过则暂定他是可以走通的</span></span><br><span class="line">                map[i][j] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (setWay(map, i, j + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i + <span class="number">1</span>, j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i - <span class="number">1</span>, j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//代表上下左右都走不通 是死路则标注为3</span></span><br><span class="line">                    map[i][j] = <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//表示该点为1,2,3 而不是0 直接返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-3对迷宫问题的讨论"><a href="#1-6-3对迷宫问题的讨论" class="headerlink" title="1.6.3对迷宫问题的讨论"></a>1.6.3对迷宫问题的讨论</h4><ol>
<li><p>小球得到的路径，和程序员设置的找路策略有关即：找路的上下左右的顺序相关 </p>
</li>
<li><p>再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变化 </p>
</li>
<li><p>测试回溯现象</p>
</li>
</ol>
<h3 id="1-7递归-八皇后问题-回溯算法"><a href="#1-7递归-八皇后问题-回溯算法" class="headerlink" title="1.7递归-八皇后问题(回溯算法)"></a>1.7递归-八皇后问题(回溯算法)</h3><h4 id="1-7-1八皇后问题介绍"><a href="#1-7-1八皇后问题介绍" class="headerlink" title="1.7.1八皇后问题介绍"></a>1.7.1八皇后问题介绍</h4><p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、 同一列或同一斜线上，问有多少种摆法(92)。1.</p>
<h4 id="1-7-2八皇后问题算法思路分析"><a href="#1-7-2八皇后问题算法思路分析" class="headerlink" title="1.7.2八皇后问题算法思路分析"></a>1.7.2八皇后问题算法思路分析</h4><ol>
<li><p>第一个皇后先放第一行第一列 </p>
</li>
<li><p>第二个皇后放在第二行第一列、然后判断是否 OK， 如果不 OK，继续放在第二列、第三列、依次把所有列都 放完，找到一个合适 </p>
</li>
<li><p>继续第三个皇后，还是第一列、第二列……直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正确 解 </p>
</li>
<li><p>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解， 全部得到. </p>
</li>
<li><p>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4 的步骤 </p>
</li>
<li><p>示意图:</p>
</li>
</ol>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108172013.png" alt="image-20210108171019528"></p>
<p>说明： </p>
<p>理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应 arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第 i+1 个皇后，放在第 i+1 行的第 val+1 列</p>
<h4 id="1-7-3八皇后问题算法代码实现"><a href="#1-7-3八皇后问题算法代码实现" class="headerlink" title="1.7.3八皇后问题算法代码实现"></a>1.7.3八皇后问题算法代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.recursion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-02 20:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 八皇后问题</span></span><br><span class="line"><span class="comment"> * 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于</span></span><br><span class="line"><span class="comment"> * 1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、</span></span><br><span class="line"><span class="comment"> * 同一列或同一斜线上，问有多少种摆法(92)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认是8个皇后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] =</span></span><br><span class="line"><span class="comment">     * &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125; //对应 arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第 i+1 个皇后，放在第 i+1</span></span><br><span class="line"><span class="comment">     * 行的第 val+1 列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> judgeCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue8 queue8 = <span class="keyword">new</span> Queue8();</span><br><span class="line">        queue8.check(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总共有解法：&quot;</span> + count);</span><br><span class="line">        System.out.println(<span class="string">&quot;总共进行了判断：&quot;</span> + judgeCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放置皇后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 代表n+1个皇后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="comment">//这时代表放置第9个皇后 说明8个皇后已经放置好了 代表一个解法已经做出来了</span></span><br><span class="line">            print();</span><br><span class="line">            <span class="comment">//在回溯后会继续执行循环 就是尝试将皇后移动到下一列 是否能够得到新解法 循环结束还没有找到则会继续回溯到上一个皇后</span></span><br><span class="line">            <span class="comment">//直到第一行的皇后将所有列尝试完</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环尝试放置第n+1个皇后的列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max ; i++) &#123;</span><br><span class="line">            <span class="comment">//尝试放置</span></span><br><span class="line">            arr[n] = i;</span><br><span class="line">            <span class="comment">//判断是否出冲突</span></span><br><span class="line">            <span class="keyword">if</span>(judge(n)) &#123;</span><br><span class="line">                <span class="comment">//如果结果为true代表没冲突可以放置下一个皇后</span></span><br><span class="line">                check(n+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果有冲突则执行下一次循环尝试将皇后放置在下一列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断传入的皇后与之前的皇后是否有冲突</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 代表第n+1个皇后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  true：没冲突 false：有冲突</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        judgeCount++;</span><br><span class="line">        <span class="comment">//遍历传入的皇后之前放置的皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//arr[i] == arr[n] 判断的是传入的皇后与第i+1个皇后是否在同一列</span></span><br><span class="line">            <span class="comment">//Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第 n 个皇后是否和第 i 皇后是否在同一斜线</span></span><br><span class="line">            <span class="comment">//Math.abs(n-1)代表当前需要放置的皇后与当前判断的第i+1个皇后相差多少行</span></span><br><span class="line">            <span class="comment">//Math.abc(arr[n]-arr[i])代表当前需要放置的皇后与当前判断的第i+1个皇后相差多少列</span></span><br><span class="line">            <span class="comment">//如果相差的行和列是相等的则代表是在同一条斜线上</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] == arr[n] || Math.abs(n-i) == Math.abs(arr[n] - arr[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
        <category>递归回溯</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>递归回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>队列学习笔记</title>
    <url>/2021/01/07/%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-队列"><a href="#1-队列" class="headerlink" title="1.队列"></a>1.队列</h2><h3 id="1-1队列的使用"><a href="#1-1队列的使用" class="headerlink" title="1.1队列的使用"></a>1.1队列的使用</h3><p>银行排队的案例:</p>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107182931.png" alt="image-20210107182107201"></p>
</blockquote>
<h3 id="1-2队列的介绍"><a href="#1-2队列的介绍" class="headerlink" title="1.2队列的介绍"></a>1.2队列的介绍</h3><ol>
<li><p>队列是一个有序列表，可以用数组或是链表来实现。 </p>
</li>
<li><p>遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出</p>
</li>
<li><p>示意图：(使用数组模拟队列示意图)</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107182932.png" alt="image-20210107182313878"></p>
</li>
</ol>
<h3 id="1-3数组模拟队列思路"><a href="#1-3数组模拟队列思路" class="headerlink" title="1.3数组模拟队列思路"></a>1.3数组模拟队列思路</h3><ul>
<li><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队 列的最大容量。 </p>
</li>
<li><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标， front 会随着数据输出而改变，而 rear 则是随着数据输入而改变，如图所示:</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107182933.png" alt="image-20210107182359479"></p>
</li>
<li><p>当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：思路分析 1) 将尾指针往后移：rear+1 , 当 front == rear 【空】 2) 若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear 所指的数组元素中，否则无法存入数据。 rear == maxSize - 1[队列满]</p>
</li>
</ul>
<p>ArrayQueue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-28 8:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 数组队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> arr[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize 最大容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        <span class="comment">//让前指针指向头部的前一个</span></span><br><span class="line">        front = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//让后指针指向头部的前一个</span></span><br><span class="line">        rear = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否队列满</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否队列空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断是否队列满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前队列容量已满无法插入！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后指针后移</span></span><br><span class="line">        rear++;</span><br><span class="line">        arr[rear] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从队列首部取出数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断是否队列空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;当前队列是空的无法取出数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前指针后移</span></span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出队列所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断是否队列空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;当前队列是空的无法取出数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot;  :&quot;</span> + arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示头元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  头元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">showHeadQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断是否队列空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;当前队列是空的无法取出数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayQueueDemo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-28 8:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 数组队列案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试一把</span></span><br><span class="line">        <span class="comment">//创建一个队列</span></span><br><span class="line">        ArrayQueue queue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">&#x27; &#x27;</span>; <span class="comment">//接收用户输入</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//</span></span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show): 显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit): 退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add): 添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get): 从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head): 查看队列头的数据&quot;</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue.showQueue();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入一个数&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>: <span class="comment">//取出数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            res = queue.getQueue();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: <span class="comment">//查看队列头的数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.showHeadQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头的数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: <span class="comment">//退出</span></span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序退出~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4问题分析并优化"><a href="#1-4问题分析并优化" class="headerlink" title="1.4问题分析并优化"></a>1.4问题分析并优化</h3><ol>
<li><p>目前数组使用一次就不能用， 没有达到复用的效果</p>
</li>
<li><p>将这个数组使用算法，改进成一个环形的队列 取模：%</p>
</li>
</ol>
<h3 id="1-5数组模拟环形队列"><a href="#1-5数组模拟环形队列" class="headerlink" title="1.5数组模拟环形队列"></a>1.5数组模拟环形队列</h3><p>对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)</p>
<p>分析说明： </p>
<ol>
<li><p>尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的 时候需要注意 (rear + 1) % maxSize == front 满] </p>
</li>
<li><p>rear == front [空]</p>
</li>
<li><p>分析示意图:</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107182934.png" alt="image-20210107182709464"></p>
</li>
</ol>
<p>CircleArrayQueue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-28 9:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 环形队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> arr[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize 最大容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="comment">//1.  front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素front 的初始值 = 0</span></span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//2.  rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.</span></span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否队列满</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//假设rear = 3 maxSize = 4 front = 0 这时rear在数组的最后一个下标 而front在首个下标</span></span><br><span class="line">        <span class="comment">//这时通过+1 模取最大容量判断是否相等 如果相等的话则表示此事队列满了</span></span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否队列空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断是否队列满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前队列容量已满无法插入！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接存入rear位置</span></span><br><span class="line">        arr[rear] = num;</span><br><span class="line">        <span class="comment">//rear下移 如果超过下标则需要进行模取后的下标</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从队列首部取出数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断是否队列空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;当前队列是空的无法取出数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存储需要返回的值</span></span><br><span class="line">        <span class="keyword">int</span> value = arr[front];</span><br><span class="line">        <span class="comment">//front下移 需要考虑模取</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出队列所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断是否队列空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;当前队列是空的无法取出数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小于有效数值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size(); i++) &#123;</span><br><span class="line">            System.out.println((front + i) % maxSize + <span class="string">&quot; :&quot;</span> + arr[(front + i) % maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取有效数值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 有效数值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假设 rear = 1 maxSize = 3 front = 2</span></span><br><span class="line">        <span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示头元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 头元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">showHeadQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断是否队列空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;当前队列是空的无法取出数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CircleArrayQueueDemo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-28 8:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 数组队列案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试一把</span></span><br><span class="line">        <span class="comment">//创建一个循环队列 因我们在设置循环队列类时给rear设计了一个预留空间，则我们创建循环队列时实际存储的比输入的maxSize小1</span></span><br><span class="line">        CircleArrayQueue queue = <span class="keyword">new</span> CircleArrayQueue(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">&#x27; &#x27;</span>; <span class="comment">//接收用户输入</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//</span></span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show): 显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit): 退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add): 添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get): 从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head): 查看队列头的数据&quot;</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue.showQueue();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入一个数&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>: <span class="comment">//取出数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            res = queue.getQueue();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: <span class="comment">//查看队列头的数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.showHeadQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头的数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: <span class="comment">//退出</span></span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序退出~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
        <category>Queue</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Beats学习笔记</title>
    <url>/2021/01/07/Beats%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Beats入门简介"><a href="#Beats入门简介" class="headerlink" title="Beats入门简介"></a>Beats入门简介</h1><p>使用Beat收集nginx日志和指标数据</p>
<h2 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h2><p>Nginx是一款非常优秀的web服务器，往往nginx服务会作为项目的访问入口，那么，nginx的性能保障就变得非常重要了，如果nginx的运行出现了问题就会对项目有较大的影响，所以，我们需要对nginx的运行有监控措施，实时掌握nginx的运行情况，那就需要收集nginx的运行指标和分析nginx的运行日志了。</p>
<h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095354.png" alt="image-20200924081614472"></p>
<p>说明：</p>
<ul>
<li>通过Beats采集Nginx的指标数据和日志数据</li>
<li>Beats采集到数据后发送到Elasticsearch中</li>
<li>Kibana读取数据进行分析</li>
<li>用户通过Kibana进行查看分析报表</li>
</ul>
<h2 id="部署Nginx"><a href="#部署Nginx" class="headerlink" title="部署Nginx"></a>部署Nginx</h2><p>部署教程可以参考这篇博客：<a href="http://www.moguit.cn/#/info?blogUid=e8d3e38ba35b4765ae128256eb44e341">CentOS下如何安装Nginx？</a></p>
<p>部署完成后，我们就可以启动nginx了</p>
<p>启动完成后，我们通过下面命令，就可以获取到nginx中的内容了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tail -f /var/<span class="built_in">log</span>/nginx/access.log</span><br></pre></td></tr></table></figure>
<h2 id="Beats简介"><a href="#Beats简介" class="headerlink" title="Beats简介"></a>Beats简介</h2><p>通过查看ElasticStack可以发现，Beats主要用于采集数据</p>
<p>官网地址：<a href="https://www.elastic.co/cn/beats/">https://www.elastic.co/cn/beats/</a></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095355.png" alt="image-20200924091657242"></p>
<p>Beats平台其实是一个轻量性数据采集器，通过集合多种单一用途的采集器，从成百上千台机器中向Logstash或ElasticSearch中发送数据。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095356.png" alt="image-20200924091716757"></p>
<p>通过Beats包含以下的数据采集功能</p>
<ul>
<li>Filebeat：采集日志文件</li>
<li>Metricbeat：采集指标</li>
<li>Packetbeat：采集网络数据</li>
</ul>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095357.png" alt="image-20200924092015934"></p>
<p>如果我们的数据不需要任何处理，那么就可以直接发送到ElasticSearch中</p>
<p>如果们的数据需要经过一些处理的话，那么就可以发送到Logstash中，然后处理完成后，在发送到ElasticSearch</p>
<p>最后在通过Kibana对我们的数据进行一系列的可视化展示</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095358.png" alt="image-20200924092348121"></p>
<h2 id="Filebeat"><a href="#Filebeat" class="headerlink" title="Filebeat"></a>Filebeat</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Filebeat是一个轻量级的日志采集器</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095359.png" alt="image-20200924092551044"></p>
<h3 id="为什么要用Filebeat？"><a href="#为什么要用Filebeat？" class="headerlink" title="为什么要用Filebeat？"></a>为什么要用Filebeat？</h3><p>当你面对成百上千、甚至成千上万的服务器、虚拟机和溶气气生成的日志时，请告别SSH吧！Filebeat将为你提供一种轻量型方法，用于转发和汇总日志与文件，让简单的事情不再繁华，关于Filebeat的记住以下两点：</p>
<ul>
<li>轻量级日志采集器</li>
<li>输送至ElasticSearch或者Logstash，在Kibana中实现可视化</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>用于监控、收集服务器日志文件.</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095400.png" alt="image-20200924092749077"></p>
<p>流程如下：</p>
<ul>
<li>首先是input输入，我们可以指定多个数据输入源，然后通过通配符进行日志文件的匹配</li>
<li>匹配到日志后，就会使用Harvester（收割机），将日志源源不断的读取到来</li>
<li>然后收割机收割到的日志，就传递到Spooler（卷轴），然后卷轴就在将他们传到对应的地方</li>
</ul>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>官网地址：<a href="https://www.elastic.co/cn/downloads/beats/filebeat">https://www.elastic.co/cn/downloads/beats/filebeat</a></p>
<p>选中对应版本的Filebeat，我这里是Centos部署的，所以下载Linux版本</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095401.png" alt="image-20200924093459418"></p>
<p>下载后，我们上传到服务器上，然后创建一个文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">mkdir -p /soft/beats</span><br><span class="line"><span class="comment"># 解压文件</span></span><br><span class="line">tar -zxvf filebeat-7.9.1-linux-x86_64.tar.gz </span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line">mv filebeat-7.9.1-linux-x86_64/ filebeat</span><br></pre></td></tr></table></figure>
<p>然后我们进入到filebeat目录下，创建对应的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入文件夹</span></span><br><span class="line"><span class="built_in">cd</span> filebeats</span><br><span class="line"><span class="comment"># 创建配置文件</span></span><br><span class="line">vim mogublog.yml</span><br></pre></td></tr></table></figure>
<p>添加如下内容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span> <span class="comment"># filebeat input输入</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">stdin</span>    <span class="comment"># 标准输入</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment"># 启用标准输入</span></span><br><span class="line"><span class="attr">setup.template.settings:</span> </span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">3</span> <span class="comment"># 指定下载数</span></span><br><span class="line"><span class="attr">output.console:</span>  <span class="comment"># 控制台输出</span></span><br><span class="line">  <span class="attr">pretty:</span> <span class="literal">true</span>   <span class="comment"># 启用美化功能</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>在我们添加完配置文件后，我们就可以对filebeat进行启动了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./filebeat -e -c mogublog.yml</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095402.png" alt="image-20200924094825962"></p>
<p>然后我们在控制台输入hello，就能看到我们会有一个json的输出，是通过读取到我们控制台的内容后输出的</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095403.png" alt="image-20200924095032365"></p>
<p>内容如下</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;@timestamp&quot;</span>:<span class="string">&quot;2019-01-12T12:50:03.585Z&quot;</span>,</span><br><span class="line">    &quot;@metadata&quot;:&#123; #元数据信息</span><br><span class="line">        &quot;beat&quot;:&quot;filebeat&quot;,</span><br><span class="line">        &quot;type&quot;:&quot;doc&quot;,</span><br><span class="line">        &quot;version&quot;:&quot;6.5.4&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;source&quot;:&quot;&quot;,</span><br><span class="line">    &quot;offset&quot;:0,</span><br><span class="line">    &quot;message&quot;:&quot;hello&quot;, #元数据信息</span><br><span class="line">    &quot;prospector&quot;:&#123;</span><br><span class="line">        &quot;type&quot;:&quot;stdin&quot; #元数据信息</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;input&quot;:&#123; #控制台标准输入</span><br><span class="line">        &quot;type&quot;:&quot;stdin&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;beat&quot;:&#123;  #beat版本以及主机信息</span><br><span class="line">        &quot;name&quot;:&quot;itcast01&quot;,</span><br><span class="line">        &quot;hostname&quot;:&quot;ElasticStack&quot;,</span><br><span class="line">        &quot;version&quot;:&quot;6.5.4&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;host&quot;:&#123;</span><br><span class="line">        &quot;name&quot;:&quot;ElasticStack&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>我们需要再次创建一个文件，叫 mogublog-log.yml，然后在文件里添加如下内容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/soft/beats/logs/*.log</span></span><br><span class="line"><span class="attr">setup.template.settings:</span></span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">output.console:</span></span><br><span class="line">  <span class="attr">pretty:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>添加完成后，我们在到下面目录创建一个日志文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">mkdir -p /soft/beats/logs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入文件夹</span></span><br><span class="line"><span class="built_in">cd</span> /soft/beats/logs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加内容</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt;&gt; a.log</span><br></pre></td></tr></table></figure>
<p>然后我们再次启动filebeat</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./filebeat -e -c mogublog-log.yml</span><br></pre></td></tr></table></figure>
<p>能够发现，它已经成功加载到了我们的日志文件 a.log</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095404.png" alt="image-20200924095926036"></p>
<p>同时我们还可以继续往文件中追加内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;are you ok ?&quot;</span> &gt;&gt; a.log</span><br></pre></td></tr></table></figure>
<p>追加后，我们再次查看filebeat，也能看到刚刚我们追加的内容</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095405.png" alt="image-20200924102409656"></p>
<p>可以看出，已经检测到日志文件有更新，立刻就会读取到更新的内容，并且输出到控制台。</p>
<h3 id="自定义字段"><a href="#自定义字段" class="headerlink" title="自定义字段"></a>自定义字段</h3><p>但我们的元数据没办法支撑我们的业务时，我们还可以自定义添加一些字段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /soft/beats/logs/*.<span class="built_in">log</span></span><br><span class="line">  tags: [<span class="string">&quot;web&quot;</span>, <span class="string">&quot;test&quot;</span>]  <span class="comment">#添加自定义tag，便于后续的处理</span></span><br><span class="line">  fields:  <span class="comment">#添加自定义字段</span></span><br><span class="line">    from: test-web</span><br><span class="line">  fields_under_root: <span class="literal">true</span> <span class="comment">#true为添加到根节点，false为添加到子节点中</span></span><br><span class="line">setup.template.settings:</span><br><span class="line">  index.number_of_shards: 3</span><br><span class="line">output.console:</span><br><span class="line">  pretty: <span class="literal">true</span></span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>添加完成后，我们重启 filebeat</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./filebeat -e -c mogublog-log.yml</span><br></pre></td></tr></table></figure>
<p>然后添加新的数据到 a.log中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;test-web&quot;</span> &gt;&gt; a.log</span><br></pre></td></tr></table></figure>
<p>我们就可以看到字段在原来的基础上，增加了两个</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095406.png" alt="image-20200924103323033"></p>
<h3 id="输出到ElasticSearch"><a href="#输出到ElasticSearch" class="headerlink" title="输出到ElasticSearch"></a>输出到ElasticSearch</h3><p>我们可以通过配置，将修改成如下所示</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/soft/beats/logs/*.log</span></span><br><span class="line">  <span class="attr">tags:</span> [<span class="string">&quot;web&quot;</span>, <span class="string">&quot;test&quot;</span>]</span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="attr">from:</span> <span class="string">test-web</span></span><br><span class="line">  <span class="attr">fields_under_root:</span> <span class="literal">false</span> </span><br><span class="line"><span class="attr">setup.template.settings:</span></span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;127.0.0.1:9200&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>启动成功后，我们就能看到它已经成功连接到了es了</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095407.png" alt="image-20200924145624812"></p>
<p>然后我们到刚刚的 logs文件夹向 a.log文件中添加内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello mogublog&quot;</span> &gt;&gt; a.log</span><br></pre></td></tr></table></figure>
<p>在ES中，我们可以看到，多出了一个 filebeat的索引库</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095408.png" alt="image-20200924145928050"></p>
<p>然后我们浏览对应的数据，看看是否有插入的数据内容</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095409.png" alt="image-20200924150500441"></p>
<h3 id="Filebeat工作原理"><a href="#Filebeat工作原理" class="headerlink" title="Filebeat工作原理"></a>Filebeat工作原理</h3><p>Filebeat主要由下面几个组件组成： harvester、prospector 、input</p>
<h4 id="harvester"><a href="#harvester" class="headerlink" title="harvester"></a>harvester</h4><ul>
<li>负责读取单个文件的内容</li>
<li>harvester逐行读取每个文件（一行一行读取），并把这些内容发送到输出</li>
<li>每个文件启动一个harvester，并且harvester负责打开和关闭这些文件，这就意味着harvester运行时文件描述符保持着打开的状态。</li>
<li>在harvester正在读取文件内容的时候，文件被删除或者重命名了，那么Filebeat就会续读这个文件，这就会造成一个问题，就是只要负责这个文件的harvester没用关闭，那么磁盘空间就不会被释放，默认情况下，Filebeat保存问价你打开直到close_inactive到达</li>
</ul>
<h4 id="prospector"><a href="#prospector" class="headerlink" title="prospector"></a>prospector</h4><ul>
<li><p>prospector负责管理harvester并找到所有要读取的文件来源</p>
</li>
<li><p>如果输入类型为日志，则查找器将查找路径匹配的所有文件，并为每个文件启动一个harvester</p>
</li>
<li><p>Filebeat目前支持两种prospector类型：log和stdin</p>
</li>
<li><p>Filebeat如何保持文件的状态</p>
<ul>
<li>Filebeat保存每个文件的状态并经常将状态刷新到磁盘上的注册文件中</li>
<li>该状态用于记住harvester正在读取的最后偏移量，并确保发送所有日志行。</li>
<li>如果输出（例如ElasticSearch或Logstash）无法访问，Filebeat会跟踪最后发送的行，并在输出再次可以用时继续读取文件。</li>
<li>在Filebeat运行时，每个prospector内存中也会保存的文件状态信息，当重新启动Filebat时，将使用注册文件的数量来重建文件状态，Filebeat将每个harvester在从保存的最后偏移量继续读取</li>
<li>文件状态记录在data/registry文件中</li>
</ul>
</li>
</ul>
<h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><ul>
<li><p>一个input负责管理harvester，并找到所有要读取的源</p>
</li>
<li><p>如果input类型是log，则input查找驱动器上与已定义的glob路径匹配的所有文件，并为每个文件启动一个harvester</p>
</li>
<li><p>每个input都在自己的Go例程中运行</p>
</li>
<li><p>下面的例子配置Filebeat从所有匹配指定的glob模式的文件中读取行</p>
</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/log/*.log</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/path2/*.log</span></span><br></pre></td></tr></table></figure>
<h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./filebeat -e -c mogublog-es.yml</span><br><span class="line">./filebeat -e -c mogublog-es.yml -d <span class="string">&quot;publish&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul>
<li><strong>-e：</strong>输出到标准输出，默认输出到syslog和logs下</li>
<li><strong>-c：</strong>指定配置文件</li>
<li><strong>-d：</strong>输出debug信息</li>
</ul>
<h3 id="读取Nginx中的配置文件"><a href="#读取Nginx中的配置文件" class="headerlink" title="读取Nginx中的配置文件"></a>读取Nginx中的配置文件</h3><p>我们需要创建一个 mogublog-nginx.yml配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/soft/nginx/*.log</span></span><br><span class="line">  <span class="attr">tags:</span> [<span class="string">&quot;nginx&quot;</span>]</span><br><span class="line">  <span class="attr">fields_under_root:</span> <span class="literal">false</span> </span><br><span class="line"><span class="attr">setup.template.settings:</span></span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;127.0.0.1:9200&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>启动后，可以在Elasticsearch中看到索引以及查看数据</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095410.png" alt="image-20200924161739842"></p>
<p>可以看到，在message中已经获取到了nginx的日志，但是，内容并没有经过处理，只是读取到原数据，那么对于我们后期的操作是不利的，有办法解决吗？</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095411.png" alt="image-20200924161814066"></p>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>前面要想实现日志数据的读取以及处理都是自己手动配置的，其实，在Filebeat中，有大量的Module，可以简化我们的配置，直接就可以使用，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./filebeat modules list</span><br></pre></td></tr></table></figure>
<p>得到的列表如下所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Disabled:</span><br><span class="line">activemq</span><br><span class="line">apache</span><br><span class="line">auditd</span><br><span class="line">aws</span><br><span class="line">azure</span><br><span class="line">barracuda</span><br><span class="line">bluecoat</span><br><span class="line">cef</span><br><span class="line">checkpoint</span><br><span class="line">cisco</span><br><span class="line">coredns</span><br><span class="line">crowdstrike</span><br><span class="line">cylance</span><br><span class="line">elasticsearch</span><br><span class="line">envoyproxy</span><br><span class="line">f5</span><br><span class="line">fortinet</span><br><span class="line">googlecloud</span><br><span class="line">gsuite</span><br><span class="line">haproxy</span><br><span class="line">ibmmq</span><br><span class="line">icinga</span><br><span class="line">iis</span><br><span class="line">imperva</span><br><span class="line">infoblox</span><br><span class="line">iptables</span><br><span class="line">juniper</span><br><span class="line">kafka</span><br><span class="line">kibana</span><br><span class="line">logstash</span><br><span class="line">microsoft</span><br><span class="line">misp</span><br><span class="line">mongodb</span><br><span class="line">mssql</span><br><span class="line">mysql</span><br><span class="line">nats</span><br><span class="line">netflow</span><br><span class="line">netscout</span><br><span class="line">nginx</span><br><span class="line">o365</span><br><span class="line">okta</span><br><span class="line">osquery</span><br><span class="line">panw</span><br><span class="line">postgresql</span><br><span class="line">rabbitmq</span><br><span class="line">radware</span><br><span class="line">redis</span><br><span class="line">santa</span><br><span class="line">sonicwall</span><br><span class="line">sophos</span><br><span class="line">squid</span><br><span class="line">suricata</span><br><span class="line">system</span><br><span class="line">tomcat</span><br><span class="line">traefik</span><br><span class="line">zeek</span><br><span class="line">zscaler</span><br></pre></td></tr></table></figure>
<p>可以看到，内置了很多的module，但是都没有启用，如果需要启用需要进行enable操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">./filebeat modules <span class="built_in">enable</span> nginx </span><br><span class="line"><span class="comment">#禁用</span></span><br><span class="line">./filebeat modules <span class="built_in">disable</span> nginx </span><br></pre></td></tr></table></figure>
<p>可以发现，nginx的module已经被启用。</p>
<h4 id="nginx-module-配置"><a href="#nginx-module-配置" class="headerlink" title="nginx module 配置"></a>nginx module 配置</h4><p>我们到下面的目录，就能看到module的配置了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入到module目录</span></span><br><span class="line"><span class="built_in">cd</span> modules.d/</span><br><span class="line"><span class="comment">#查看文件</span></span><br><span class="line">vim nginx.yml.disabled</span><br></pre></td></tr></table></figure>
<p>得到的文件内容如下所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Module: nginx</span></span><br><span class="line"><span class="comment"># Docs: https://www.elastic.co/guide/en/beats/filebeat/7.9/filebeat-module-nginx.html</span></span><br><span class="line"></span><br><span class="line">- module: nginx</span><br><span class="line">  <span class="comment"># Access logs</span></span><br><span class="line">  access:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 添加日志文件</span></span><br><span class="line">    var.paths: [<span class="string">&quot;/var/log/nginx/access.log*&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set custom paths for the log files. If left empty,</span></span><br><span class="line">    <span class="comment"># Filebeat will choose the paths depending on your OS.</span></span><br><span class="line">    <span class="comment">#var.paths:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Error logs</span></span><br><span class="line">  error:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line">    var.paths: [<span class="string">&quot;/var/log/nginx/error.log*&quot;</span>]</span><br></pre></td></tr></table></figure>
<h4 id="配置filebeat"><a href="#配置filebeat" class="headerlink" title="配置filebeat"></a>配置filebeat</h4><p>我们需要修改刚刚的mogublog-nginx.yml文件，然后添加到我们的module</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="attr">setup.template.settings:</span></span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;127.0.0.1:9200&quot;</span>]</span><br><span class="line"><span class="attr">filebeat.config.modules:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">$&#123;path.config&#125;/modules.d/*.yml</span></span><br><span class="line">  <span class="attr">reload.enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>我们启动我们的filebeat</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./filebeat -e -c itcast-nginx.yml</span><br></pre></td></tr></table></figure>
<p>如果启动的时候发现出错了，错误如下所示，执行如图所示的脚本即可 【新版本的ES好像不会出现这个错误】</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动会出错，如下</span></span><br><span class="line">ERROR fileset/factory.go:142 Error loading pipeline: Error loading pipeline <span class="keyword">for</span></span><br><span class="line">fileset nginx/access: This module requires the following Elasticsearch plugins:</span><br><span class="line">ingest-user-agent, ingest-geoip. You can install them by running the following</span><br><span class="line">commands on all the Elasticsearch nodes:</span><br><span class="line">  sudo bin/elasticsearch-plugin install ingest-user-agent</span><br><span class="line">  sudo bin/elasticsearch-plugin install ingest-geoip</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动成功后，能看到日志记录已经成功刷新进去了</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095412.png" alt="image-20200924164750123"></p>
<p>我们可以测试一下，刷新nginx页面，或者向错误日志中，插入数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;err&quot;</span> &gt;&gt; error.log</span><br></pre></td></tr></table></figure>
<p>能够看到，刚刚的记录已经成功插入了</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095413.png" alt="image-20200924164927557"></p>
<p>关于module的其它使用，可以参考文档：</p>
<p><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-modules.html">https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-modules.html</a></p>
<h2 id="Metricbeat"><a href="#Metricbeat" class="headerlink" title="Metricbeat"></a>Metricbeat</h2><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095414.png" alt="image-20200924170741928"></p>
<ul>
<li>定期收集操作系统或应用服务的指标数据</li>
<li>存储到Elasticsearch中，进行实时分析</li>
</ul>
<h3 id="Metricbeat组成"><a href="#Metricbeat组成" class="headerlink" title="Metricbeat组成"></a>Metricbeat组成</h3><p>Metricbeat有2部分组成，一部分是Module，另一个部分为Metricset</p>
<ul>
<li>Module<ul>
<li>收集的对象：如 MySQL、Redis、Nginx、操作系统等</li>
</ul>
</li>
<li>Metricset<ul>
<li>收集指标的集合：如 cpu、memory，network等</li>
</ul>
</li>
</ul>
<p>以Redis Module为例：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095415.png" alt="image-20200924170958343"></p>
<h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><p>首先我们到<a href="https://www.elastic.co/cn/downloads/beats/metricbeat">官网</a>，找到Metricbeat进行下载</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095416.png" alt="image-20200924171232384"></p>
<p>下载完成后，我们通过xftp工具，移动到指定的目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移动到该目录下</span></span><br><span class="line"><span class="built_in">cd</span> /soft/beats</span><br><span class="line"><span class="comment"># 解压文件</span></span><br><span class="line">tar -zxvf </span><br><span class="line"><span class="comment"># 修改文件名</span></span><br><span class="line">mv  metricbeat</span><br></pre></td></tr></table></figure>
<p>然后修改配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim metricbeat.yml</span><br></pre></td></tr></table></figure>
<p>添加如下内容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">metricbeat.config.modules:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">$&#123;path.config&#125;/modules.d/*.yml</span></span><br><span class="line">  <span class="attr">reload.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">setup.template.settings:</span></span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">index.codec:</span> <span class="string">best_compression</span></span><br><span class="line"><span class="attr">setup.kibana:</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;&quot;</span><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9200&quot;</span>]</span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">add_host_metadata:</span> <span class="string">~</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">add_cloud_metadata:</span> <span class="string">~</span></span><br></pre></td></tr></table></figure>
<p>默认会指定的配置文件，就是在</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;path.config&#125;</span>/modules.d/*.yml</span><br></pre></td></tr></table></figure>
<p>也就是 system.yml文件，我们也可以自行开启其它的收集</p>
<h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><p>在配置完成后，我们通过如下命令启动即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./metricbeat -e</span><br></pre></td></tr></table></figure>
<p>在ELasticsearch中可以看到，系统的一些指标数据已经写入进去了：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095417.png" alt="image-20200924171839291"></p>
<h3 id="system-module配置"><a href="#system-module配置" class="headerlink" title="system module配置"></a>system module配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">module:</span> <span class="string">system</span></span><br><span class="line">  <span class="attr">period:</span> <span class="string">10s</span>  <span class="comment"># 采集的频率，每10秒采集一次</span></span><br><span class="line">  <span class="attr">metricsets:</span>  <span class="comment"># 采集的内容</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cpu</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">load</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">memory</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">network</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">process</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">process_summary</span></span><br></pre></td></tr></table></figure>
<h3 id="Metricbeat-Module"><a href="#Metricbeat-Module" class="headerlink" title="Metricbeat Module"></a>Metricbeat Module</h3><p>Metricbeat Module的用法和我们之前学的filebeat的用法差不多</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看列表</span></span><br><span class="line">./metricbeat modules list </span><br></pre></td></tr></table></figure>
<p>能够看到对应的列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enabled:</span><br><span class="line">system <span class="comment">#默认启用</span></span><br><span class="line"></span><br><span class="line">Disabled:</span><br><span class="line">aerospike</span><br><span class="line">apache</span><br><span class="line">ceph</span><br><span class="line">couchbase</span><br><span class="line">docker</span><br><span class="line">dropwizard</span><br><span class="line">elasticsearch</span><br><span class="line">envoyproxy</span><br><span class="line">etcd</span><br><span class="line">golang</span><br><span class="line">graphite</span><br><span class="line">haproxy</span><br><span class="line">http</span><br><span class="line">jolokia</span><br><span class="line">kafka</span><br><span class="line">kibana</span><br><span class="line">kubernetes</span><br><span class="line">kvm</span><br><span class="line">logstash</span><br><span class="line">memcached</span><br><span class="line">mongodb</span><br><span class="line">munin</span><br><span class="line">mysql</span><br><span class="line">nginx</span><br><span class="line">php_fpm</span><br><span class="line">postgresql</span><br><span class="line">prometheus</span><br><span class="line">rabbitmq</span><br><span class="line">redis</span><br><span class="line">traefik</span><br><span class="line">uwsgi</span><br><span class="line">vsphere</span><br><span class="line">windows</span><br></pre></td></tr></table></figure>
<h3 id="Nginx-Module"><a href="#Nginx-Module" class="headerlink" title="Nginx Module"></a>Nginx Module</h3><h4 id="开启Nginx-Module"><a href="#开启Nginx-Module" class="headerlink" title="开启Nginx Module"></a>开启Nginx Module</h4><p>在nginx中，需要开启状态查询，才能查询到指标数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#重新编译nginx</span></span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/nginx --with-http_stub_status_module</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">./nginx -V <span class="comment">#查询版本信息</span></span><br><span class="line">nginx version: nginx/1.11.6</span><br><span class="line">built by gcc 4.4.7 20120313 (Red Hat 4.4.7-23) (GCC)</span><br><span class="line">configure arguments: --prefix=/usr/<span class="built_in">local</span>/nginx --with-http_stub_status_module</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置nginx</span></span><br><span class="line">vim nginx.conf</span><br><span class="line">location /nginx-status &#123;</span><br><span class="line">    stub_status on;</span><br><span class="line">    access_log off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启nginx</span></span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure>
<p>测试</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095418.png" alt="image-20200924172317526"></p>
<p>结果说明：</p>
<ul>
<li>Active connections：正在处理的活动连接数</li>
<li>server accepts handled requests<ul>
<li>第一个 server 表示Nginx启动到现在共处理了9个连接</li>
<li>第二个 accepts 表示Nginx启动到现在共成功创建 9 次握手</li>
<li>第三个 handled requests 表示总共处理了 21 次请求</li>
<li>请求丢失数 = 握手数 - 连接数 ，可以看出目前为止没有丢失请求</li>
</ul>
</li>
<li>Reading: 0 Writing: 1 Waiting: 1<ul>
<li>Reading：Nginx 读取到客户端的 Header 信息数</li>
<li>Writing：Nginx 返回给客户端 Header 信息数</li>
<li>Waiting：Nginx 已经处理完正在等候下一次请求指令的驻留链接（开启keep-alive的情况下，这个值等于<br>Active - (Reading+Writing)）</li>
</ul>
</li>
</ul>
<h3 id="配置nginx-module"><a href="#配置nginx-module" class="headerlink" title="配置nginx module"></a>配置nginx module</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启用redis module</span></span><br><span class="line">./metricbeat modules <span class="built_in">enable</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改redis module配置</span></span><br><span class="line">vim modules.d/nginx.yml</span><br></pre></td></tr></table></figure>
<p>然后修改下面的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Module: nginx</span></span><br><span class="line"><span class="comment"># Docs: https://www.elastic.co/guide/en/beats/metricbeat/6.5/metricbeat-modulenginx.</span></span><br><span class="line">html</span><br><span class="line">  - module: nginx</span><br><span class="line"><span class="comment">#metricsets:</span></span><br><span class="line"><span class="comment"># - stubstatus</span></span><br><span class="line">  period: 10s</span><br><span class="line"><span class="comment"># Nginx hosts</span></span><br><span class="line">  hosts: [<span class="string">&quot;http://127.0.0.1&quot;</span>]</span><br><span class="line"><span class="comment"># Path to server status. Default server-status</span></span><br><span class="line">  server_status_path: <span class="string">&quot;nginx-status&quot;</span></span><br><span class="line"><span class="comment">#username: &quot;user&quot;</span></span><br><span class="line"><span class="comment">#password: &quot;secret&quot;</span></span><br></pre></td></tr></table></figure>
<p>修改完成后，启动nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">./metricbeat -e</span><br></pre></td></tr></table></figure>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>我们能看到，我们的nginx数据已经成功的采集到我们的系统中了</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095419.png" alt="image-20200924173058267"></p>
<p>可以看到，nginx的指标数据已经写入到了Elasticsearch。</p>
<p>更多的Module使用参见官方文档：</p>
<p><a href="https://www.elastic.co/guide/en/beats/metricbeat/current/metricbeat-modules.html">https://www.elastic.co/guide/en/beats/metricbeat/current/metricbeat-modules.html</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://www.cnblogs.com/cjsblog/p/9495024.html">Filebeat 模块与配置</a></p>
<p><a href="https://www.bilibili.com/video/BV1iJ411c7Az">Elastic Stack（ELK）从入门到实践</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>ELK</category>
        <category>Beats</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>Beats</tag>
      </tags>
  </entry>
  <entry>
    <title>nacos集群环境搭建</title>
    <url>/2021/01/07/nacos%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="预备环境准备"><a href="#预备环境准备" class="headerlink" title="预备环境准备"></a>预备环境准备</h2><p>Nacos 依赖 <a href="https://docs.oracle.com/cd/E19182-01/820-7851/inst_cli_jdk_javahome_t/">Java</a> 环境来运行。如果您是从代码开始构建并运行Nacos，还需要为此配置 <a href="https://maven.apache.org/index.html">Maven</a>环境，请确保是在以下版本环境中安装使用:</p>
<ol>
<li>64 bit OS，支持 Linux/Unix/Mac/Windows，推荐选用 Linux/Unix/Mac。</li>
<li>64 bit JDK 1.8+；<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">下载</a> &amp; <a href="https://docs.oracle.com/cd/E19182-01/820-7851/inst_cli_jdk_javahome_t/">配置</a>。</li>
<li>Maven 3.2.x+；<a href="https://maven.apache.org/download.cgi">下载</a> &amp; <a href="https://maven.apache.org/settings.html">配置</a>。</li>
</ol>
<h2 id="下载nacos安装包"><a href="#下载nacos安装包" class="headerlink" title="下载nacos安装包"></a>下载nacos安装包</h2><p><a href="https://github.com/alibaba/nacos/releases/tag/1.4.0">https://github.com/alibaba/nacos/releases/tag/1.4.0</a></p>
<blockquote>
<p> <img src="https://img-blog.csdnimg.cn/20201130205557917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ0ODU5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<p>linux选择第一个</p>
<p>windows选择第二个</p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><h3 id="集群模式部署"><a href="#集群模式部署" class="headerlink" title="集群模式部署"></a>集群模式部署</h3><p>这个快速开始手册是帮忙您快速在你的电脑上，下载安装并使用Nacos，部署生产使用的集群模式。</p>
<h3 id="集群部署架构图"><a href="#集群部署架构图" class="headerlink" title="集群部署架构图"></a>集群部署架构图</h3><p><img src="https://img-blog.csdnimg.cn/20201130205609797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ0ODU5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>VIP:虚拟ip</p>
<p>因此开源的时候推荐用户把所有服务列表放到一个vip下面，然后挂到一个域名下面</p>
<p><a href="http://ip1/">http://ip1</a>:port/openAPI 直连ip模式，机器挂则需要修改ip才可以使用。</p>
<p><a href="http://vip/">http://VIP</a>:port/openAPI 挂载VIP模式，直连vip即可，下面挂server真实ip，可读性不好。</p>
<p><a href="http://nacos.com/">http://nacos.com</a>:port/openAPI 域名 + VIP模式，可读性好，而且换ip方便，推荐模式</p>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>该目录存放nacos集群</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/nacos</span><br></pre></td></tr></table></figure>
<h3 id="上传nacos"><a href="#上传nacos" class="headerlink" title="上传nacos"></a>上传nacos</h3><blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201130205630233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ0ODU5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="解压nacos"><a href="#解压nacos" class="headerlink" title="解压nacos"></a>解压nacos</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf nacos-server-1.4.0.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="创建nacos持久化数据库"><a href="#创建nacos持久化数据库" class="headerlink" title="创建nacos持久化数据库"></a>创建nacos持久化数据库</h3><p>首先使用navicat连接mysql数据库，然后创建数据库</p>
<p><img src="https://img-blog.csdnimg.cn/20201130205643439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ0ODU5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>新建查询后导入SQL脚本即可</p>
<p><img src="https://img-blog.csdnimg.cn/20201130205705669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ0ODU5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>红色框选那栏填写你的SQL脚本位置，SQL脚本在nacos文件夹下的conf下</p>
<h3 id="nacos文件夹改名"><a href="#nacos文件夹改名" class="headerlink" title="nacos文件夹改名"></a>nacos文件夹改名</h3><p>将文件夹名改为nacos3333代表这个nacos的端口号是3333</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mv nacos nacos3333</span><br></pre></td></tr></table></figure>
<h3 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h3><p>首先进入到配置目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nacos/nacos3333/conf</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020113020572431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ0ODU5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<p>在更改配置之前先备份配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp application.properties application.properties.example</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp cluster.conf.example cluster.conf</span><br></pre></td></tr></table></figure>
<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim cluster.conf</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201130205739435.png" alt="在这里插入图片描述"></p>
</blockquote>
<blockquote>
<p>注意这里不能填写localhost 或者127.0.0.1，这里如果是在本机搭建可以查看本机ip后填写</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;hostname -i</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201130205749116.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="nacos配置"><a href="#nacos配置" class="headerlink" title="nacos配置"></a>nacos配置</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim application.properties</span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#*************** Spring Boot Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### Default web context path:</span></span><br><span class="line"><span class="meta">server.servlet.contextPath</span>=<span class="string">/nacos</span></span><br><span class="line"><span class="comment">### Default web server port:</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">3333</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#*************** Network Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### If prefer hostname over ip for Nacos server addresses in cluster.conf:</span></span><br><span class="line"><span class="comment"># nacos.inetutils.prefer-hostname-over-ip=false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Specify local server&#x27;s IP:</span></span><br><span class="line"><span class="comment"># nacos.inetutils.ip-address=</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#*************** Config Module Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### If use MySQL as datasource:</span></span><br><span class="line"> <span class="meta">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Count of DB:</span></span><br><span class="line"> <span class="meta">db.num</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Connect URL of DB:</span></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string">123456</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#*************** Naming Module Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### Data dispatch task execution period in milliseconds:</span></span><br><span class="line"><span class="comment"># nacos.naming.distro.taskDispatchPeriod=200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Data count of batch sync task:</span></span><br><span class="line"><span class="comment"># nacos.naming.distro.batchSyncKeyCount=1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Retry delay in milliseconds if sync task failed:</span></span><br><span class="line"><span class="comment"># nacos.naming.distro.syncRetryDelay=5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### If enable data warmup. If set to false, the server would accept request without local data preparation:</span></span><br><span class="line"><span class="comment"># nacos.naming.data.warmup=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### If enable the instance auto expiration, kind like of health check of instance:</span></span><br><span class="line"><span class="comment"># nacos.naming.expireInstance=true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">nacos.naming.empty-service.auto-clean</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">nacos.naming.empty-service.clean.initial-delay-ms</span>=<span class="string">50000</span></span><br><span class="line"><span class="meta">nacos.naming.empty-service.clean.period-time-ms</span>=<span class="string">30000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#*************** CMDB Module Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### The interval to dump external CMDB in seconds:</span></span><br><span class="line"><span class="comment"># nacos.cmdb.dumpTaskInterval=3600</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### The interval of polling data change event in seconds:</span></span><br><span class="line"><span class="comment"># nacos.cmdb.eventTaskInterval=10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### The interval of loading labels in seconds:</span></span><br><span class="line"><span class="comment"># nacos.cmdb.labelTaskInterval=300</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### If turn on data loading task:</span></span><br><span class="line"><span class="comment"># nacos.cmdb.loadDataAtStart=false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#*************** Metrics Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### Metrics for prometheus</span></span><br><span class="line"><span class="comment">#management.endpoints.web.exposure.include=*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Metrics for elastic search</span></span><br><span class="line"><span class="meta">management.metrics.export.elastic.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#management.metrics.export.elastic.host=http://localhost:9200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Metrics for influx</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#management.metrics.export.influx.db=springboot</span></span><br><span class="line"><span class="comment">#management.metrics.export.influx.uri=http://localhost:8086</span></span><br><span class="line"><span class="comment">#management.metrics.export.influx.auto-create-db=true</span></span><br><span class="line"><span class="comment">#management.metrics.export.influx.consistency=one</span></span><br><span class="line"><span class="comment">#management.metrics.export.influx.compressed=true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#*************** Access Log Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### If turn on the access log:</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.enabled</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### The access log pattern:</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.pattern</span>=<span class="string">%h %l %u %t &quot;%r&quot; %s %b %D %&#123;User-Agent&#125;i %&#123;Request-Source&#125;i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### The directory of access log:</span></span><br><span class="line"><span class="meta">server.tomcat.basedir</span>=<span class="string"></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#*************** Access Control Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### If enable spring security, this option is deprecated in 1.2.0:</span></span><br><span class="line"><span class="comment">#spring.security.enabled=false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### The ignore urls of auth, is deprecated in 1.2.0:</span></span><br><span class="line"><span class="meta">nacos.security.ignore.urls</span>=<span class="string">/,/error,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/**,/v1/console/health/**,/actuator/**,/v1/console/server/**</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### The auth system to use, currently only &#x27;nacos&#x27; is supported:</span></span><br><span class="line"><span class="meta">nacos.core.auth.system.type</span>=<span class="string">nacos</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### If turn on auth system:</span></span><br><span class="line"><span class="meta">nacos.core.auth.enabled</span>=<span class="string">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### The token expiration in seconds:</span></span><br><span class="line"><span class="meta">nacos.core.auth.default.token.expire.seconds</span>=<span class="string">18000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### The default token:</span></span><br><span class="line"><span class="meta">nacos.core.auth.default.token.secret.key</span>=<span class="string">SecretKey012345678901234567890123456789012345678901234567890123456789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Turn on/off caching of auth information. By turning on this switch, the update of auth information would have a 15 seconds delay.</span></span><br><span class="line"><span class="meta">nacos.core.auth.caching.enabled</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#*************** Istio Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### If turn on the MCP server:</span></span><br><span class="line"><span class="meta">nacos.istio.mcp.server.enabled</span>=<span class="string">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###*************** Add from 1.3.0 ***************###</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#*************** Core Related Configurations ***************#</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### set the WorkerID manually</span></span><br><span class="line"><span class="comment"># nacos.core.snowflake.worker-id=</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Member-MetaData</span></span><br><span class="line"><span class="comment"># nacos.core.member.meta.site=</span></span><br><span class="line"><span class="comment"># nacos.core.member.meta.adweight=</span></span><br><span class="line"><span class="comment"># nacos.core.member.meta.weight=</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### MemberLookup</span></span><br><span class="line"><span class="comment">### Addressing pattern category, If set, the priority is highest</span></span><br><span class="line"><span class="comment"># nacos.core.member.lookup.type=[file,address-server]</span></span><br><span class="line"><span class="comment">## Set the cluster list with a configuration file or command-line argument</span></span><br><span class="line"><span class="comment"># nacos.member.list=192.168.16.101:8847?raft_port=8807,192.168.16.101?raft_port=8808,192.168.16.101:8849?raft_port=8809</span></span><br><span class="line"><span class="comment">## for AddressServerMemberLookup</span></span><br><span class="line"><span class="comment"># Maximum number of retries to query the address server upon initialization</span></span><br><span class="line"><span class="comment"># nacos.core.address-server.retry=5</span></span><br><span class="line"><span class="comment">## Server domain name address of [address-server] mode</span></span><br><span class="line"><span class="comment"># address.server.domain=jmenv.tbsite.net</span></span><br><span class="line"><span class="comment">## Server port of [address-server] mode</span></span><br><span class="line"><span class="comment"># address.server.port=8080</span></span><br><span class="line"><span class="comment">## Request address of [address-server] mode</span></span><br><span class="line"><span class="comment"># address.server.url=/nacos/serverlist</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#*************** JRaft Related Configurations ***************#</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Sets the Raft cluster election timeout, default value is 5 second</span></span><br><span class="line"><span class="comment"># nacos.core.protocol.raft.data.election_timeout_ms=5000</span></span><br><span class="line"><span class="comment">### Sets the amount of time the Raft snapshot will execute periodically, default is 30 minute</span></span><br><span class="line"><span class="comment"># nacos.core.protocol.raft.data.snapshot_interval_secs=30</span></span><br><span class="line"><span class="comment">### raft internal worker threads</span></span><br><span class="line"><span class="comment"># nacos.core.protocol.raft.data.core_thread_num=8</span></span><br><span class="line"><span class="comment">### Number of threads required for raft business request processing</span></span><br><span class="line"><span class="comment"># nacos.core.protocol.raft.data.cli_service_thread_num=4</span></span><br><span class="line"><span class="comment">### raft linear read strategy. Safe linear reads are used by default, that is, the Leader tenure is confirmed by heartbeat</span></span><br><span class="line"><span class="comment"># nacos.core.protocol.raft.data.read_index_type=ReadOnlySafe</span></span><br><span class="line"><span class="comment">### rpc request timeout, default 5 seconds</span></span><br><span class="line"><span class="comment"># nacos.core.protocol.raft.data.rpc_request_timeout_ms=5000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是我的整个application.properties文件,其中主要修改的地方有两处</p>
<p>修改端口号</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### Default web server port:</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">3333</span></span><br></pre></td></tr></table></figure>
<p>修改数据库为mysql并配置mysql的url</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#*************** Config Module Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### If use MySQL as datasource:</span></span><br><span class="line"> <span class="meta">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Count of DB:</span></span><br><span class="line"> <span class="meta">db.num</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Connect URL of DB:</span></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>
<p>这时候配置就差不多啦可以开始启动服务了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入到nacos3333的bin目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nacos/nacos3333/bin</span><br><span class="line"><span class="comment"># 执行启动脚本 因为nacos启动脚本默认就是使用集群模式所以不用更改</span></span><br><span class="line">./startup.sh</span><br></pre></td></tr></table></figure>
<p>这时候我们可以查看nacos的启动状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nacos</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201130205818481.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>这时候我们应该就可以通过 服务器ip:3333/nacos访问到nacos</p>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201130205828641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ0ODU5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<p>成功的访问到了nacos代表成功了。</p>
<h3 id="nacos集群启动"><a href="#nacos集群启动" class="headerlink" title="nacos集群启动"></a>nacos集群启动</h3><p>这时候我们就可以回到nacos目录下拷贝之前的nacos3333文件夹来启动nacos4444和nacos5555</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nacos</span><br><span class="line"><span class="comment"># cp -r 代表递归拷贝</span></span><br><span class="line">cp -r nacos3333 nacos4444</span><br><span class="line">cp -r nacos3333 nacos5555</span><br></pre></td></tr></table></figure>
<p>这时候再分别将nacos4444和nacos5555文件夹下的conf目录中的application.properties中的server.port更改为3333、4444然后再启动，这里我就不再演示了，和之前配置一样。</p>
<p>随后我们再依次启动nacos4444，nacos5555</p>
<p>###########################################################################</p>
<p>启动后发现问题，nacos5555启动不起来，查看日志得到发现内存不足，nacos脚本默认给的最大内存是2G，我们可以去改小一点。</p>
<p><img src="https://img-blog.csdnimg.cn/20201130205845619.png" alt="在这里插入图片描述"></p>
<p>原红框中限制的内存是2g 最小1g 适当该小一点[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传<br><img src="https://img-blog.csdnimg.cn/20201130205903628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ0ODU5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>然后再依次启动三个服务</p>
<p>登录任意一个nacos可以看到如下页面即集群启动成功</p>
<h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><p>这配置nginx负载均衡访问nacos</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/conf</span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    #配置刚刚搭建好的nacos集群</span><br><span class="line">    upstream cluster&#123;                                                        </span><br><span class="line">	    server 127.0.0.1:3333;</span><br><span class="line">	    server 127.0.0.1:4444;</span><br><span class="line">	    server 127.0.0.1:5555;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       1111;</span><br><span class="line">        server_name  nacos_cluster;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            #root   html;</span><br><span class="line">            #index  index.html index.htm;</span><br><span class="line">            #将所有访问&#x2F;的都映射到配置好的集群</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;cluster;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              &#x2F;404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#39;s document root</span><br><span class="line">        # concurs with nginx&#39;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ &#x2F;\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location &#x2F; &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location &#x2F; &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="nginx启动"><a href="#nginx启动" class="headerlink" title="nginx启动"></a>nginx启动</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/sbin</span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure>
<p>这时候我们就可以通过服务器ip地址:1111/nacos 来访问nacos集群了</p>
<p><img src="https://img-blog.csdnimg.cn/20201130205927229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ0ODU5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>关于使用NACOS集群遇到问题 – CODE:503 MSG: SERVER IS STARTING NOW, PLEASE TRY AGAIN LATER!</p>
<p>这时又出现了问题……在服务提供者注册服务时会报错</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2020-11-30 00:36:59.492 ERROR 13140 --- [  restartedMain] c.a.c.n.registry.NacosServiceRegistry    : nacos registry, nacos-payment-provider register failed...NacosRegistration&#123;nacosDiscoveryProperties=NacosDiscoveryProperties&#123;serverAddr=&#x27;wsy.oopsw.top:1111&#x27;, endpoint=&#x27;&#x27;, namespace=&#x27;&#x27;, watchDelay=30000, logName=&#x27;&#x27;, service=&#x27;nacos-payment-provider&#x27;, weight=1.0, clusterName=&#x27;DEFAULT&#x27;, namingLoadCacheAtStart=&#x27;false&#x27;, metadata=&#123;preserved.register.source=SPRING_CLOUD&#125;, registerEnabled=true, ip=&#x27;10.175.6.100&#x27;, networkInterface=&#x27;&#x27;, port=9002, secure=false, accessKey=&#x27;&#x27;, secretKey=&#x27;&#x27;&#125;&#125;,</span><br><span class="line"></span><br><span class="line">java.lang.IllegalStateException: failed to req API:/nacos/v1/ns/instance after all servers([wsy.oopsw.top:1111]) tried: failed to req API:wsy.oopsw.top:1111/nacos/v1/ns/instance. code:503 msg: server is DOWN now, please try again later!</span><br><span class="line">	at com.alibaba.nacos.client.naming.net.NamingProxy.reqAPI(NamingProxy.java:464) ~[nacos-client-1.1.1.jar:na]</span><br><span class="line">	at com.alibaba.nacos.client.naming.net.NamingProxy.reqAPI(NamingProxy.java:386) ~[nacos-client-1.1.1.jar:na]</span><br><span class="line">	at com.alibaba.nacos.client.naming.net.NamingProxy.registerService(NamingProxy.java:188) ~[nacos-client-1.1.1.jar:na]</span><br><span class="line">	at com.alibaba.nacos.client.naming.NacosNamingService.registerInstance(NacosNamingService.java:205) ~[nacos-client-1.1.1.jar:na]</span><br><span class="line">	at com.alibaba.nacos.client.naming.NacosNamingService.registerInstance(NacosNamingService.java:184) ~[nacos-client-1.1.1.jar:na]</span><br><span class="line">	at com.alibaba.cloud.nacos.registry.NacosServiceRegistry.register(NacosServiceRegistry.java:61) ~[spring-cloud-alibaba-nacos-discovery-2.1.0.RELEASE.jar:2.1.0.RELEASE]</span><br><span class="line">	at org.springframework.cloud.client.serviceregistry.AbstractAutoServiceRegistration.register(AbstractAutoServiceRegistration.java:239) [spring-cloud-commons-2.2.1.RELEASE.jar:2.2.1.RELEASE]</span><br><span class="line">	at com.alibaba.cloud.nacos.registry.NacosAutoServiceRegistration.register(NacosAutoServiceRegistration.java:74) [spring-cloud-alibaba-nacos-discovery-2.1.0.RELEASE.jar:2.1.0.RELEASE]</span><br><span class="line">	at org.springframework.cloud.client.serviceregistry.AbstractAutoServiceRegistration.start(AbstractAutoServiceRegistration.java:138) [spring-cloud-commons-2.2.1.RELEASE.jar:2.2.1.RELEASE]</span><br><span class="line">	at org.springframework.cloud.client.serviceregistry.AbstractAutoServiceRegistration.bind(AbstractAutoServiceRegistration.java:101) [spring-cloud-commons-2.2.1.RELEASE.jar:2.2.1.RELEASE]</span><br><span class="line">	at org.springframework.cloud.client.serviceregistry.AbstractAutoServiceRegistration.onApplicationEvent(AbstractAutoServiceRegistration.java:88) [spring-cloud-commons-2.2.1.RELEASE.jar:2.2.1.RELEASE]</span><br><span class="line">	at org.springframework.cloud.client.serviceregistry.AbstractAutoServiceRegistration.onApplicationEvent(AbstractAutoServiceRegistration.java:47) [spring-cloud-commons-2.2.1.RELEASE.jar:2.2.1.RELEASE]</span><br><span class="line">	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) [spring-context-5.2.2.RELEASE.jar:5.2.2.RELEASE]</span><br><span class="line">	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) [spring-context-5.2.2.RELEASE.jar:5.2.2.RELEASE]</span><br><span class="line">	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) [spring-context-5.2.2.RELEASE.jar:5.2.2.RELEASE]</span><br><span class="line">	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:403) [spring-context-5.2.2.RELEASE.jar:5.2.2.RELEASE]</span><br><span class="line">	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:360) [spring-context-5.2.2.RELEASE.jar:5.2.2.RELEASE]</span><br><span class="line">	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.finishRefresh(ServletWebServerApplicationContext.java:165) [spring-boot-2.2.2.RELEASE.jar:2.2.2.RELEASE]</span><br><span class="line">	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:553) [spring-context-5.2.2.RELEASE.jar:5.2.2.RELEASE]</span><br><span class="line">	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:141) [spring-boot-2.2.2.RELEASE.jar:2.2.2.RELEASE]</span><br><span class="line">	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747) [spring-boot-2.2.2.RELEASE.jar:2.2.2.RELEASE]</span><br><span class="line">	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) [spring-boot-2.2.2.RELEASE.jar:2.2.2.RELEASE]</span><br><span class="line">	at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) [spring-boot-2.2.2.RELEASE.jar:2.2.2.RELEASE]</span><br><span class="line">	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) [spring-boot-2.2.2.RELEASE.jar:2.2.2.RELEASE]</span><br><span class="line">	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) [spring-boot-2.2.2.RELEASE.jar:2.2.2.RELEASE]</span><br><span class="line">	at com.wsy.springcloud.AlibabaProviderApplication.main(AlibabaProviderApplication.java:15) [classes/:na]</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_73]</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_73]</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_73]</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:497) ~[na:1.8.0_73]</span><br><span class="line">	at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) [spring-boot-devtools-2.2.2.RELEASE.jar:2.2.2.RELEASE]</span><br></pre></td></tr></table></figure>
<p>像阿里云、腾讯云这种云服务器, 会提供一个外网ip和内网ip, 访问外网ip时会指向对应的内网ip来访问到该服务器, 由于nacos集群内部是指定的使用网卡ip地址来进行通信,但是由于三台服务器各自的内网ip不在同一网段, 所以造成无法通信, 也会造成以下问题</p>
<p>注册服务:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code:503 msg: server is STARTING now, please try again later!</span><br></pre></td></tr></table></figure>
<p>naming-raft.log 日志:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-05-15 00:02:00,000 WARN [IS LEADER] no leader is available now!</span><br></pre></td></tr></table></figure>
<p>这时只要修改启动参数, 设置本机ip地址就可以了<br>修改 nacos/bin/startup.sh 文件<br>找到 JVM Configuration 这部分, 在集群参数里增加 -Dnacos.server.ip=xx</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#===========================================================================================</span></span><br><span class="line"><span class="comment"># JVM Configuration</span></span><br><span class="line"><span class="comment">#===========================================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单机模式对应的启动参数</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;MODE&#125;</span>&quot;</span> == <span class="string">&quot;standalone&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -Xms512m -Xmx512m -Xmn256m&quot;</span></span><br><span class="line">    JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -Dnacos.standalone=true&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment"># 集群模式对应的启动参数</span></span><br><span class="line">    JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms2g -Xmx2g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span></span><br><span class="line">    JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:-OmitStackTraceInFastThrow -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=<span class="variable">$&#123;BASE_DIR&#125;</span>/logs/java_heapdump.hprof&quot;</span></span><br><span class="line">    JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:-UseLargePages&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># *新增以下参数设置本机ip地址*</span></span><br><span class="line">    JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -Dnacos.server.ip=本机ip&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;FUNCTION_MODE&#125;</span>&quot;</span> == <span class="string">&quot;config&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -Dnacos.functionMode=config&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [[ <span class="string">&quot;<span class="variable">$&#123;FUNCTION_MODE&#125;</span>&quot;</span> == <span class="string">&quot;naming&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -Dnacos.functionMode=naming&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考博客：<a href="https://www.freesion.com/article/33101142210/">https://www.freesion.com/article/33101142210/</a></p>
<p>服务注册时报BadRequest400 问题暂时还未解决</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">com.alibaba.nacos.api.exception.NacosException: failed to req API:/nacos/v1/ns/instance after all servers([wsy.oopsw.top:1111]) tried: ErrCode:400, ErrMsg:&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;&lt;div id=&#x27;created&#x27;&gt;Mon Nov 30 01:33:45 CST 2020&lt;/div&gt;&lt;div&gt;There was an unexpected error (type=Bad Request, status=400).&lt;/div&gt;&lt;div&gt;receive invalid redirect request from peer 172.20.9.153&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>#############################################################</p>
<p>问题已解决，是nacos版本的问题，据群里老哥解释说是nacos需要使用与之对应的SpringCloudAlibaba的版本，不然就会报错，我更换版本到1.3.2问题解决服务注册正常</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>SpringCloudAlibaba</tag>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>排序学习笔记</title>
    <url>/2021/01/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-排序算法"><a href="#1-排序算法" class="headerlink" title="1.排序算法"></a>1.排序算法</h2><h3 id="1-1排序算法的介绍"><a href="#1-1排序算法的介绍" class="headerlink" title="1.1排序算法的介绍"></a>1.1排序算法的介绍</h3><p>排序也称排序算法(Sort Algorithm)，排序是将<strong>一组数据</strong>，依<strong>指定的顺序</strong>进行<strong>排列</strong>的<strong>过程</strong>。</p>
<h3 id="1-2排序的分类："><a href="#1-2排序的分类：" class="headerlink" title="1.2排序的分类："></a>1.2排序的分类：</h3><ol>
<li><p>内部排序: 指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。 </p>
</li>
<li><p>外部排序法： 数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序。 </p>
</li>
<li><p>常见的排序算法分类(见下图):</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182104.png" alt="image-20210108172259536"></p>
</li>
</ol>
<h3 id="1-3算法的时间复杂度"><a href="#1-3算法的时间复杂度" class="headerlink" title="1.3算法的时间复杂度"></a>1.3算法的时间复杂度</h3><h4 id="1-3-1度量一个程序-算法-执行时间的两种方法"><a href="#1-3-1度量一个程序-算法-执行时间的两种方法" class="headerlink" title="1.3.1度量一个程序(算法)执行时间的两种方法"></a>1.3.1度量一个程序(算法)执行时间的两种方法</h4><ol>
<li><p>事后统计的方法 这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所 得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比 </p>
</li>
<li><p>事前估算的方法 通过分析某个算法的<strong>时间复杂度</strong>来判断哪个算法更优.</p>
</li>
</ol>
<h4 id="1-3-2时间频度"><a href="#1-3-2时间频度" class="headerlink" title="1.3.2时间频度"></a>1.3.2时间频度</h4><ul>
<li><p>基本介绍</p>
<p>时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间 就多。一个算法中的语句执行次数称为语句频度或时间频度。记为 T(n)。[举例说明] </p>
</li>
<li><p>举例说明-基本案例</p>
<p> 比如计算 1-100 所有数字之和, 我们设计两种算法：</p>
</li>
</ul>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182105.png" alt="image-20210108172533069"></p>
<ul>
<li><p>举例说明-忽略常数项</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182106.png" alt="image-20210108172548099"></p>
</li>
</ul>
<blockquote>
<p>结论: </p>
<ol>
<li><p>2n+20 和 2n 随着 n 变大，执行曲线无限接近, 20 可以忽略</p>
</li>
<li><p>3n+10 和 3n 随着 n 变大，执行曲线无限接近, 10 可以忽略</p>
</li>
</ol>
</blockquote>
<ul>
<li><p>举例说明-忽略低次项</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182107.png" alt="image-20210108172617468"></p>
</li>
</ul>
<blockquote>
<p>结论: </p>
<ol>
<li><p>2n^2+3n+10 和 2n^2 随着 n 变大, 执行曲线无限接近, 可以忽略 3n+10 </p>
</li>
<li><p>n^2+5n+20 和 n^2 随着 n 变大,执行曲线无限接近, 可以忽略 5n+20</p>
</li>
</ol>
</blockquote>
<ul>
<li><p>举例说明-忽略系数</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182108.png" alt="image-20210108172652112"></p>
<blockquote>
<p>结论: </p>
<ol>
<li><p>随着 n 值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明 这种情况下, 5 和 3 可以忽略。 </p>
</li>
<li><p>而 n^3+5n 和 6n^3+4n ，执行曲线分离，说明多少次方式关键</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="1-3-3时间复杂度"><a href="#1-3-3时间复杂度" class="headerlink" title="1.3.3时间复杂度"></a>1.3.3时间复杂度</h4><ol>
<li><p>一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T(n)表示，若有某个辅 助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数。 记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。 </p>
</li>
<li><p>T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的 T(n) 不同，但时间复杂 度相同，都为 O(n²)。 </p>
</li>
<li><p>计算时间复杂度的方法：</p>
<ul>
<li>用常数 1 代替运行时间中的所有加法常数 T(n)=n²+7n+6 =&gt; T(n)=n²+7n+1 </li>
<li>修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 =&gt; T(n) = n² </li>
<li>去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²)</li>
</ul>
</li>
</ol>
<h4 id="1-3-4常见的时间复杂度"><a href="#1-3-4常见的时间复杂度" class="headerlink" title="1.3.4常见的时间复杂度"></a>1.3.4常见的时间复杂度</h4><ol>
<li><p>常数阶 O(1) </p>
</li>
<li><p>对数阶 O(log2n) </p>
</li>
<li><p>线性阶 O(n) </p>
</li>
<li><p>线性对数阶 O(nlog2n)  </p>
</li>
<li><p>平方阶 O(n^2) </p>
</li>
<li><p>立方阶 O(n^3) </p>
</li>
<li><p>k 次方阶 O(n^k) </p>
</li>
<li><p>指数阶 O(2^n)</p>
</li>
</ol>
<p>常见的时间复杂度对应的图:</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182109.png" alt="image-20210108173000288"></p>
<p><strong>说明：</strong></p>
<ol>
<li>常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜ Ο(2n) ，随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低 </li>
<li>从图中可见，我们应该尽可能避免使用指数阶的算法</li>
</ol>
<ol>
<li><p>常数阶 O(1)</p>
<p>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就是O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">int</span> m = i + j;</span><br></pre></td></tr></table></figure>
<p>上述代码在执行的时候，它小号的时候并不随着某个变量的增长而增长，那么无论这代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。</p>
</li>
</ol>
<ol start="2">
<li><p>对数阶O(log2n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n) &#123;</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182110.png" alt="image-20210108175210768"></p>
</li>
<li><p>线性阶 O(n）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">    j = i;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182111.png" alt="image-20210108175314799"></p>
</li>
<li><p>线性对数阶 O(nlogN)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(m=<span class="number">1</span>; m&lt;n; m++) &#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n) &#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182112.png" alt="image-20210108175419234"></p>
</li>
<li><p>平方阶 O(n²)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(m=<span class="number">1</span>; m&lt;n; m++) &#123;</span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">1</span>; k&lt;=n; k++) &#123;</span><br><span class="line">        j = k;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182113.png" alt="image-20210108175514195"></p>
</li>
<li><p>立方阶 O(n³)、K 次方阶 O(n^k)</p>
<p>说明：参考上面的 O(n²) 去理解就好了，O(n³)相当于三层 n 循环，其它的类似</p>
</li>
</ol>
<h4 id="1-3-5平均时间复杂度和最坏时间复杂度"><a href="#1-3-5平均时间复杂度和最坏时间复杂度" class="headerlink" title="1.3.5平均时间复杂度和最坏时间复杂度"></a>1.3.5平均时间复杂度和最坏时间复杂度</h4><ol>
<li><p>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。 </p>
</li>
<li><p>最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的 原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会 比最坏情况更长。 </p>
</li>
<li><p>平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。</p>
</li>
</ol>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182114.png" alt="image-20210108175606298"></p>
<h3 id="1-4算法的空间复杂度简介"><a href="#1-4算法的空间复杂度简介" class="headerlink" title="1.4算法的空间复杂度简介"></a>1.4算法的空间复杂度简介</h3><h4 id="1-4-1基本介绍"><a href="#1-4-1基本介绍" class="headerlink" title="1.4.1基本介绍"></a>1.4.1基本介绍</h4><ol>
<li><p>类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是 问题规模 n 的函数。 </p>
</li>
<li><p>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的 临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例 如<strong>快速排序</strong>和<strong>归并排序算法</strong>, <strong>基数排序</strong>就属于这种情况 </p>
</li>
<li><p>在做算法分析时，主要讨论的是时间复杂度。<strong>从用户使用体验上看，更看重的程序执行的速度。</strong>一些缓存产品 (redis, memcache)和算法(基数排序)<strong>本质就是用空间换时间.</strong></p>
</li>
</ol>
<h3 id="1-5冒泡排序"><a href="#1-5冒泡排序" class="headerlink" title="1.5冒泡排序"></a>1.5冒泡排序</h3><h4 id="1-5-1基本介绍"><a href="#1-5-1基本介绍" class="headerlink" title="1.5.1基本介绍"></a>1.5.1基本介绍</h4><p>冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,<strong>依次比较 相邻元素的值，若发现逆序则交换，</strong>使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒</p>
<p>优化：</p>
<p> 因为排序的过程中，各元素不断接近自己的位置，<strong>如果一趟比较下来没有进行过交换，就说明序列有序，</strong>因此要在 排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排 序写好后，在进行)</p>
<h4 id="1-5-2演示冒泡过程的例子-图解"><a href="#1-5-2演示冒泡过程的例子-图解" class="headerlink" title="1.5.2演示冒泡过程的例子(图解)"></a>1.5.2演示冒泡过程的例子(图解)</h4><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182115.png" alt="image-20210108175818086"></p>
<p>小结上面的图解过程: </p>
<p>(1) 一共进行 数组的大小-1 次 大的循环 </p>
<p>(2)每一趟排序的次数在逐渐的减少 </p>
<p>(3) 如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化</p>
<h4 id="1-5-3冒泡排序应用实例"><a href="#1-5-3冒泡排序应用实例" class="headerlink" title="1.5.3冒泡排序应用实例"></a>1.5.3冒泡排序应用实例</h4><p>我们举一个具体的案例来说明冒泡法。我们将五个无序的数：3, 9, -1, 10, -2 使用冒泡排序法将其排成一个从小 到大的有序数列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-03 9:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="comment">//随机生成80000个数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="keyword">int</span>)(Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序</span></span><br><span class="line"><span class="comment">     * 冒泡排序因需要使用两重循环 所以时间复杂度为O(n^2)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义临时变量</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//标识此次循环是否进行了排序 默认为false</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//需要进行数组长度-1次排序 每次都确定后面元素的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//需要比较的元素 因为每次都会确定后面一个位置的元素 所以还需要-i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="comment">//升序排序</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>] ) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot; + (i + 1) +&quot;次排序的结果是&quot; + Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6选择排序"><a href="#1-6选择排序" class="headerlink" title="1.6选择排序"></a>1.6选择排序</h3><h4 id="1-6-1基本介绍"><a href="#1-6-1基本介绍" class="headerlink" title="1.6.1基本介绍"></a>1.6.1基本介绍</h4><p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到 排序的目的。</p>
<h4 id="1-6-2选择排序思想"><a href="#1-6-2选择排序思想" class="headerlink" title="1.6.2选择排序思想"></a>1.6.2选择排序思想</h4><p>选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从 arr[0]<del>arr[n-1]中选取最小值， 与 arr[0]交换，第二次从 arr[1]</del>arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]<del>arr[n-1]中选取最小值，与 arr[2] 交换，…，第 i 次从 arr[i-1]</del>arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值， 与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。</p>
<h4 id="1-6-3选择排序思路分析图"><a href="#1-6-3选择排序思路分析图" class="headerlink" title="1.6.3选择排序思路分析图"></a>1.6.3选择排序思路分析图</h4><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182116.png" alt="image-20210108180055495"></p>
<p>对一个数组的选择排序再进行讲解</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182117.png" alt="image-20210108180108018"></p>
<h4 id="1-6-4选择排序应用实例"><a href="#1-6-4选择排序应用实例" class="headerlink" title="1.6.4选择排序应用实例:"></a>1.6.4选择排序应用实例:</h4><p>有一群牛 , 颜值分别是 101, 34, 119, 1 请使用选择排序从低到高进行排序 [101, 34, 119, 1]</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182118.png" alt="image-20210108180138750"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-03 9:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        selectSort(arr);</span><br><span class="line">        System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择排序</span></span><br><span class="line"><span class="comment">     * 因为也是嵌套两个循环所以时间复杂度也是O(n^2)</span></span><br><span class="line"><span class="comment">     * 但是通过测试可以发现 80000数据 选择排序花费的时间只有5秒左右 但是冒泡排序需要花费20秒左右</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//设置默认最小值下标</span></span><br><span class="line">            min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最小值不是默认值 就需要交换</span></span><br><span class="line">            <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">                arr[i] = arr[min];</span><br><span class="line">                arr[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot; + (i + 1) + &quot;次排序&quot; + Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-7插入排序"><a href="#1-7插入排序" class="headerlink" title="1.7插入排序"></a>1.7插入排序</h3><h4 id="1-7-1插入排序法介绍"><a href="#1-7-1插入排序法介绍" class="headerlink" title="1.7.1插入排序法介绍"></a>1.7.1插入排序法介绍</h4><p>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。</p>
<h4 id="1-7-2插入排序法思想"><a href="#1-7-2插入排序法思想" class="headerlink" title="1.7.2插入排序法思想"></a>1.7.2插入排序法思想</h4><p>插入排序（Insertion Sorting）的基本思想是：<strong>把 n 个待排序的元素看成为一个有序表和一个无序表，</strong>开始时<strong>有序表中只包含一个元素，</strong>无序表中包含有 <strong>n-1 个元素，</strong>排序过程中每次从无序表中取出第一个元素，把它的排 序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p>
<h4 id="1-7-3插入排序思路图"><a href="#1-7-3插入排序思路图" class="headerlink" title="1.7.3插入排序思路图"></a>1.7.3插入排序思路图</h4><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182119.png" alt="image-20210108180326474"></p>
<h4 id="1-7-4插入排序法应用实例"><a href="#1-7-4插入排序法应用实例" class="headerlink" title="1.7.4插入排序法应用实例"></a>1.7.4插入排序法应用实例</h4><p>有一群小牛, 考试成绩分别是 101, 34, 119, 1 请从小到大排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-03 9:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 插入排序</span></span><br><span class="line"><span class="comment"> * 插入排序是从第二个数开始插入 第一个数保留在数组中 用来组成有序列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//&#123;101, 43, 34, 119, 1, -1&#125;</span></span><br><span class="line">        <span class="comment">//第一轮 有序列表&#123;43,101&#125; 无序列表&#123;34,119,1,-1&#125;</span></span><br><span class="line">        <span class="comment">//第二轮 有序列表&#123;34,43,101&#125; 无序列表&#123;119,1,-1&#125;</span></span><br><span class="line">        <span class="comment">//第三轮 有序列表&#123;34,43,101,119&#125; 无序列表&#123;1,-1&#125;</span></span><br><span class="line">        <span class="comment">//第四轮 有序列表&#123;1,34,43,101,119&#125; 无序列表&#123;-1&#125;</span></span><br><span class="line">        <span class="comment">//第五轮 有序列表&#123;-1,1,34,43,101,119&#125; 无序列表&#123;&#125;</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入排序</span></span><br><span class="line"><span class="comment">     * 时间复杂度O(n^2) 但是执行速度比冒泡排序和选择排序快</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//arr[0]默认是已经有序的 因为只有一个元素 所以i从1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//保存需要插入的值</span></span><br><span class="line">            <span class="keyword">int</span> insertVal = arr[i];</span><br><span class="line">            <span class="comment">//需要判断的插入位置的值 第一个判断的就是当前需要插入的值下标的前一个数</span></span><br><span class="line">            <span class="keyword">int</span> insertIndex = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//判断insertIndex 不能越界 然后判断arr[insertIndex]代表当前判断的位置的值 如果大于需要插入的值的话就需要往前继续判断</span></span><br><span class="line">            <span class="comment">//将arr[insertIndex] 移动到arr[insertIndex+1] 后移一位</span></span><br><span class="line">            <span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; arr[insertIndex] &gt; insertVal) &#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (insertIndex != i) &#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-8希尔排序"><a href="#1-8希尔排序" class="headerlink" title="1.8希尔排序"></a>1.8希尔排序</h3><h4 id="1-8-1简单插入排序存在的问题"><a href="#1-8-1简单插入排序存在的问题" class="headerlink" title="1.8.1简单插入排序存在的问题"></a>1.8.1简单插入排序存在的问题</h4><p>我们看简单的插入排序可能存在的问题. </p>
<p>数组 arr = {2,3,4,5,6,1} 这时需要插入的数 <strong>1(最小),</strong> 这样的过程是： </p>
<p>{2,3,4,5,6,6} </p>
<p>{2,3,4,5,5,6} </p>
<p>{2,3,4,4,5,6} </p>
<p>{2,3,3,4,5,6} </p>
<p>{2,2,3,4,5,6} </p>
<p>{1,2,3,4,5,6}</p>
<p><strong>结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响</strong></p>
<h4 id="1-8-2希尔排序法介绍"><a href="#1-8-2希尔排序法介绍" class="headerlink" title="1.8.2希尔排序法介绍"></a>1.8.2希尔排序法介绍</h4><p>希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种<strong>插入排序，</strong>它是简单插入排序经过改进之后的一个<strong>更高效的版本，</strong>也称为<strong>缩小增量排序。</strong></p>
<h4 id="1-8-3希尔排序法基本思想"><a href="#1-8-3希尔排序法基本思想" class="headerlink" title="1.8.3希尔排序法基本思想"></a>1.8.3希尔排序法基本思想</h4><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含 的关键词越来越多，<strong>当增量减至 1 时，</strong>整个文件恰被分成一组，算法便终止</p>
<h4 id="1-8-4希尔排序法的示意图"><a href="#1-8-4希尔排序法的示意图" class="headerlink" title="1.8.4希尔排序法的示意图"></a>1.8.4希尔排序法的示意图</h4><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182120.png" alt="image-20210108180726319"></p>
<h4 id="1-8-5希尔排序法应用实例"><a href="#1-8-5希尔排序法应用实例" class="headerlink" title="1.8.5希尔排序法应用实例:"></a>1.8.5希尔排序法应用实例:</h4><p>有一群小牛, 考试成绩分别是 {8,9,1,7,2,3,5,4,6,0} 请从小到大排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-03 9:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        selectSort(arr);</span><br><span class="line">        System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择排序</span></span><br><span class="line"><span class="comment">     * 因为也是嵌套两个循环所以时间复杂度也是O(n^2)</span></span><br><span class="line"><span class="comment">     * 但是通过测试可以发现 80000数据 选择排序花费的时间只有5秒左右 但是冒泡排序需要花费20秒左右</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//设置默认最小值下标</span></span><br><span class="line">            min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最小值不是默认值 就需要交换</span></span><br><span class="line">            <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">                arr[i] = arr[min];</span><br><span class="line">                arr[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;第&quot; + (i + 1) + &quot;次排序&quot; + Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-9快速排序"><a href="#1-9快速排序" class="headerlink" title="1.9快速排序"></a>1.9快速排序</h3><h4 id="1-9-1快速排序法介绍"><a href="#1-9-1快速排序法介绍" class="headerlink" title="1.9.1快速排序法介绍"></a>1.9.1快速排序法介绍</h4><p>快速排序（Quicksort）是对<strong>冒泡排序</strong>的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两 部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排 序，<strong>整个排序过程可以递归进行，</strong>以此达到整个数据变成有序序列</p>
<h4 id="1-9-2快速排序法示意图"><a href="#1-9-2快速排序法示意图" class="headerlink" title="1.9.2快速排序法示意图"></a>1.9.2快速排序法示意图</h4><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182121.png" alt="image-20210108180905067"></p>
<h4 id="1-9-3快速排序法应用实例"><a href="#1-9-3快速排序法应用实例" class="headerlink" title="1.9.3快速排序法应用实例"></a>1.9.3快速排序法应用实例</h4><p>要求: 对 [-9,78,0,23,-567,70] 进行从小到大的排序，要求使用快速排序法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-03 16:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//快速排序处理1000000个数排序需要时间2-3秒</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">10000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序</span></span><br><span class="line"><span class="comment">     * 快速排序是通过一个基准值来将所有小于基准值的数都放到基准值的左边 将所有大于基准值的数放到基准值的右边</span></span><br><span class="line"><span class="comment">     * 然后通过递归来实现排序的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 找寻基准数据的正确索引</span></span><br><span class="line">            <span class="keyword">int</span> index = getIndex(arr, left, right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行迭代对index之前和之后的数组进行相同的操作使整个数组变成有序</span></span><br><span class="line">            <span class="comment">//quickSort(arr, 0, index - 1); 之前的版本，这种姿势有很大的性能问题，谢谢大家的建议</span></span><br><span class="line">            <span class="comment">//index 是基准数的位置</span></span><br><span class="line">            <span class="comment">//分别再为基准数左边和右边进行递归快速排序</span></span><br><span class="line">            quickSort(arr, left, index - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, index + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得索引位置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        <span class="comment">//以下标left的作为基准数</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//当right方向的值大于等于基准值时使right向前移</span></span><br><span class="line">            <span class="comment">//判断与基准值大小的时候必须带上= 因为如果不带上的话如果排序数组中有重复的数的话就会出现死循环</span></span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt;= temp &amp;&amp; left &lt; right) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当退出循环时则是right方向的值有小于等于temp值的 或者left &lt;= right了</span></span><br><span class="line">            <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">                arr[left] = arr[right];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当right方向的值小于等于基准值时使left向后移</span></span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt;= temp &amp;&amp; left &lt; right) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当退出循环时则是left方向的值有大于等于temp值的 或者left &lt;= right了</span></span><br><span class="line">            <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">                arr[right] = arr[left];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//跳出循环时left == right 此时这里就是temp的位置 就是基准值的位置</span></span><br><span class="line">        <span class="comment">//此时是arr[left]或arr[right]都没关系 因为是相等的</span></span><br><span class="line">        arr[left] = temp;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-10归并排序"><a href="#1-10归并排序" class="headerlink" title="1.10归并排序"></a>1.10归并排序</h3><h4 id="1-10-1归并排序介绍"><a href="#1-10-1归并排序介绍" class="headerlink" title="1.10.1归并排序介绍"></a>1.10.1归并排序介绍</h4><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的<strong>分治（divide-and-conquer） 策略</strong>（分治法将问题分(divide)成一些<strong>小的问题然后递归求解，</strong>而治(conquer)的阶段则将分的阶段得到的各答案”修 补”在一起，即分而治之)。</p>
<h4 id="1-10-2归并排序思想示意图-1-基本思想"><a href="#1-10-2归并排序思想示意图-1-基本思想" class="headerlink" title="1.10.2归并排序思想示意图 1-基本思想:"></a>1.10.2归并排序思想示意图 1-基本思想:</h4><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182122.png" alt="image-20210108181127341"></p>
<h4 id="1-10-3归并排序思想示意图-2-合并相邻有序子序列"><a href="#1-10-3归并排序思想示意图-2-合并相邻有序子序列" class="headerlink" title="1.10.3归并排序思想示意图 2-合并相邻有序子序列:"></a>1.10.3归并排序思想示意图 2-合并相邻有序子序列:</h4><p>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将 [4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182123.png" alt="image-20210108181157413"></p>
<h4 id="1-10-4归并排序的应用实例"><a href="#1-10-4归并排序的应用实例" class="headerlink" title="1.10.4归并排序的应用实例"></a>1.10.4归并排序的应用实例</h4><p>给你一个数组, val arr = Array(8, 4, 5, 7, 1, 3, 6, 2 ), 请使用归并排序完成排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-04 8:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 归并排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分治算法的分解操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp  临时数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//定义中间下标</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            System.out.println(left + <span class="string">&quot; &quot;</span> + right);</span><br><span class="line">            <span class="comment">//向左递归进行分解</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            <span class="comment">//向右递归进行分解</span></span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">//分解结束后开始合并</span></span><br><span class="line">            merge(arr, left, right, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行两个有序数组的合并</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp  临时数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(arr) + <span class="string">&quot;=========&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//右边下标为中间下标的下一个开始</span></span><br><span class="line">        <span class="keyword">int</span> r = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//临时数组下标</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将两个有序数组按照规则依次填入temp数组</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[l] &lt; arr[r]) &#123;</span><br><span class="line">                temp[t++] = arr[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = arr[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出上一个循环时代表已经有一个数组为空了 现在应该将另一个数组的值传入到temp中</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid) &#123;</span><br><span class="line">            temp[t++] = arr[l++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (r &lt;= right) &#123;</span><br><span class="line">            temp[t++] = arr[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这时候temp已经填入好 现在需要将temp数组拷贝到arr数组</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tempLeft = left;</span><br><span class="line">        <span class="comment">//将temp数组中的元素一个个遍历到left 到right下标</span></span><br><span class="line">        <span class="keyword">while</span> (tempLeft &lt;= right) &#123;</span><br><span class="line">            arr[tempLeft++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-11基数排序"><a href="#1-11基数排序" class="headerlink" title="1.11基数排序"></a>1.11基数排序</h3><h4 id="1-11-1基数排序-桶排序-介绍"><a href="#1-11-1基数排序-桶排序-介绍" class="headerlink" title="1.11.1基数排序(桶排序)介绍"></a>1.11.1基数排序(桶排序)介绍</h4><ol>
<li><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾 名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用 </p>
</li>
<li><p>基数排序法是属于稳定性的排序，基数排序法的是效率高的<strong>稳定性</strong>排序法 </p>
</li>
<li><p>基数排序(Radix Sort)是桶排序的扩展 4) 基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个 位数分别比较。</p>
</li>
</ol>
<h4 id="1-11-2基数排序基本思想"><a href="#1-11-2基数排序基本思想" class="headerlink" title="1.11.2基数排序基本思想"></a>1.11.2基数排序基本思想</h4><ol>
<li><p>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
</li>
<li><p>这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤</p>
</li>
</ol>
<h4 id="1-11-3基数排序图文说明"><a href="#1-11-3基数排序图文说明" class="headerlink" title="1.11.3基数排序图文说明"></a>1.11.3基数排序图文说明</h4><p>将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182124.png" alt="image-20210108181421233"></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182125.png" alt="image-20210108181427173"></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182126.png" alt="image-20210108181433022"></p>
<h4 id="1-11-4基数排序代码实现"><a href="#1-11-4基数排序代码实现" class="headerlink" title="1.11.4基数排序代码实现"></a>1.11.4基数排序代码实现</h4><p>要求：将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-04 9:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 基数排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>,<span class="number">4142</span>,<span class="number">2314</span>,<span class="number">3415</span>&#125;;</span><br><span class="line">        radixSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基数排序</span></span><br><span class="line"><span class="comment">     * 原理是创建10个桶 执行数组中最大值的位数次循环</span></span><br><span class="line"><span class="comment">     * 然后分别将每个数中的个、十、百……放入桶中 然后再依次取出来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//防止最坏的情况出现出现下标越界 全部在同一个桶中</span></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="comment">//创建每个桶中的数据个数</span></span><br><span class="line">        <span class="keyword">int</span>[] bucketElementCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//获得最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得最大值的长度</span></span><br><span class="line">        <span class="keyword">int</span> maxLength = (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">                <span class="comment">//取得需要放入桶的数</span></span><br><span class="line">                <span class="keyword">int</span> bucketNum = value / n % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">//将该数放入桶中</span></span><br><span class="line">                bucket[bucketNum][bucketElementCount[bucketNum]++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时桶中已经存放好数据 再一次从桶中取出数据</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//遍历桶</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(bucketElementCount[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果桶中的数不为空的话就从桶中取出数</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketElementCount[j]; k++) &#123;</span><br><span class="line">                        arr[index++] = bucket[j][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//从桶中取出后需要将桶元素的个数置0 不然会出现问题</span></span><br><span class="line">                    bucketElementCount[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-11-5基数排序的说明"><a href="#1-11-5基数排序的说明" class="headerlink" title="1.11.5基数排序的说明"></a>1.11.5基数排序的说明</h4><ol>
<li><p>基数排序是对传统桶排序的扩展，速度很快. </p>
</li>
<li><p>基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。 </p>
</li>
<li><p>基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些 记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且 r[i]在 r[j]之前，而在排序后的序列中，r[i]仍在 r[j]之前， 则称这种排序算法是稳定的；否则称为不稳定的] </p>
</li>
<li><p>有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考: <a href="https://code.i-harness.com/zh-CN/q/e98fa9">https://code.i-harness.com/zh-CN/q/e98fa9</a></p>
</li>
</ol>
<h3 id="1-12常用排序算法总结和对比"><a href="#1-12常用排序算法总结和对比" class="headerlink" title="1.12常用排序算法总结和对比"></a>1.12常用排序算法总结和对比</h3><h4 id="1-12-1一张排序算法的比较图"><a href="#1-12-1一张排序算法的比较图" class="headerlink" title="1.12.1一张排序算法的比较图"></a>1.12.1一张排序算法的比较图</h4><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108182127.png" alt="image-20210108181557287"></p>
<h4 id="1-12-2相关术语解释"><a href="#1-12-2相关术语解释" class="headerlink" title="1.12.2相关术语解释"></a>1.12.2相关术语解释</h4><ol>
<li><p>稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面； </p>
</li>
<li><p>不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面； </p>
</li>
<li><p>内排序：所有排序操作都在内存中完成； </p>
</li>
<li><p>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； </p>
</li>
<li><p>时间复杂度： 一个算法执行所耗费的时间。 </p>
</li>
<li><p>空间复杂度：运行完一个程序所需内存的大小。 </p>
</li>
<li><p>n: 数据规模 </p>
</li>
<li><p>k: “桶”的个数 </p>
</li>
<li><p>In-place: 不占用额外内存 </p>
</li>
<li><p>Out-place: 占用额外内存</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
        <category>Sort</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>栈学习笔记</title>
    <url>/2021/01/08/%E6%A0%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-栈"><a href="#1-栈" class="headerlink" title="1.栈"></a>1.栈</h2><h3 id="1-1栈的一个实际需求"><a href="#1-1栈的一个实际需求" class="headerlink" title="1.1栈的一个实际需求"></a>1.1栈的一个实际需求</h3><p>请输入一个表达式 计算式:[7<em>2</em>2-5+1-5+3-3] 点击计算【如下图】</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108131329.png" alt="image-20210108125921937"></p>
<p>请问: 计算机底层是如何运算得到结果的？ 注意不是简单的把算式列出运算,因为我们看这个算式 7 * 2 * 2 - 5, 但是计算机怎么理解这个算式的(对计算机而言，它接收到的就是一个字符串)，我们讨论的是这个问题。-&gt; 栈</p>
<h3 id="1-2栈的介绍"><a href="#1-2栈的介绍" class="headerlink" title="1.2栈的介绍"></a>1.2栈的介绍</h3><ol>
<li><p>栈的英文为(stack) </p>
</li>
<li><p>栈是一个先入后出(FILO-First In Last Out)的有序列表。 </p>
</li>
<li><p>栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的 一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。 </p>
</li>
<li><p>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元 素最先删除，最先放入的元素最后删除 </p>
</li>
<li><p>图解方式说明出栈(pop)和入栈(push)的概念</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108131330.png" alt="image-20210108130034224"></p>
</li>
</ol>
<h3 id="1-3栈的应用场景"><a href="#1-3栈的应用场景" class="headerlink" title="1.3栈的应用场景"></a>1.3栈的应用场景</h3><ol>
<li><p>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以 回到原来的程序中。 </p>
</li>
<li><p>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆 栈中。 </p>
</li>
<li><p>表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。 </p>
</li>
<li><p>二叉树的遍历。 </p>
</li>
<li><p>图形的深度优先(depth 一 first)搜索法。</p>
</li>
</ol>
<h3 id="1-4栈的快速入门"><a href="#1-4栈的快速入门" class="headerlink" title="1.4栈的快速入门"></a>1.4栈的快速入门</h3><ol>
<li><p>用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容， 下面我们就用数组模拟栈的出栈，入栈等操作。 </p>
</li>
<li><p>实现思路分析,并画出示意图</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108131331.png" alt="image-20210108130241540"></p>
</li>
</ol>
<h4 id="1-4-1数组栈"><a href="#1-4-1数组栈" class="headerlink" title="1.4.1数组栈"></a>1.4.1数组栈</h4><p>ArrayStack</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-29 16:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 数组模拟栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] stack;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack[++top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈是空的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack[top--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">showTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈是空的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stack[&quot;</span> + i + <span class="string">&quot;]&quot;</span> + <span class="string">&quot;:&quot;</span> + stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayStackDemo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-29 16:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStackDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试一下ArrayStack 是否正确</span></span><br><span class="line">        <span class="comment">//先创建一个ArrayStack对象-&gt;表示栈</span></span><br><span class="line">        ArrayStack stack = <span class="keyword">new</span> ArrayStack(<span class="number">4</span>);</span><br><span class="line">        String key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>; <span class="comment">//控制是否退出菜单</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;show: 表示显示栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit: 退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;push: 表示添加数据到栈(入栈)&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;pop: 表示从栈取出数据(出栈)&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入你的选择&quot;</span>);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        stack.showStack();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    stack.push(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = stack.pop();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;出栈的数据是 %d\n&quot;</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序退出~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-2链表栈"><a href="#1-4-2链表栈" class="headerlink" title="1.4.2链表栈"></a>1.4.2链表栈</h4><p>LinkedListStack</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-29 17:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 链式栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> StackNode head = <span class="keyword">new</span> StackNode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈顶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> StackNode top = head;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getLength() == maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(StackNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使新添加的节点插入到head后 成为第一个节点 并连接上后面的节点 也就是栈顶</span></span><br><span class="line">        node.next = head.next;</span><br><span class="line">        <span class="comment">//使head连接上新节点</span></span><br><span class="line">        head.next = node;</span><br><span class="line">        <span class="comment">//将栈顶指针指向node</span></span><br><span class="line">        top = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StackNode <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        StackNode node = top;</span><br><span class="line">        top = top.next;</span><br><span class="line">        head.next = top;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        StackNode cur = top;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StackNode cur = head.next;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinkedListStackDemo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-29 18:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStackDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedListStack stack = <span class="keyword">new</span> LinkedListStack(<span class="number">3</span>);</span><br><span class="line">        StackNode stackNode1 = <span class="keyword">new</span> StackNode(<span class="number">1</span>);</span><br><span class="line">        StackNode stackNode2 = <span class="keyword">new</span> StackNode(<span class="number">2</span>);</span><br><span class="line">        StackNode stackNode3 = <span class="keyword">new</span> StackNode(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        stack.push(stackNode1);</span><br><span class="line">        stack.push(stackNode2);</span><br><span class="line">        stack.push(stackNode3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原节点&quot;</span>);</span><br><span class="line">        stack.showStack();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;出栈：&quot;</span> + stack.pop());</span><br><span class="line">        System.out.println(<span class="string">&quot;现节点&quot;</span>);</span><br><span class="line">        stack.showStack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5栈实现综合计算器-中缀表达式"><a href="#1-5栈实现综合计算器-中缀表达式" class="headerlink" title="1.5栈实现综合计算器(中缀表达式)"></a>1.5栈实现综合计算器(中缀表达式)</h3><p>使用栈来实现综合计算器</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108131332.png" alt="image-20210108130515371"></p>
<p>思路分析(图解)</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108131333.png" alt="image-20210108130533615"></p>
<p>代码实现[1. 先实现一位数的运算， 2. 扩展到多位数的运算]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-30 9:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 计算器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用栈完成表达式的计算 思路</span></span><br><span class="line"><span class="comment">     * 1. 通过一个 index  值（索引），来遍历我们的表达式</span></span><br><span class="line"><span class="comment">     * 2. 如果我们发现是一个数字, 就直接入数栈</span></span><br><span class="line"><span class="comment">     * 3. 如果发现扫描到是一个符号,  就分如下情况</span></span><br><span class="line"><span class="comment">     * 3.1 如果发现当前的符号栈为 空，就直接入栈</span></span><br><span class="line"><span class="comment">     * 3.2 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符，</span></span><br><span class="line"><span class="comment">     * 就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，</span></span><br><span class="line"><span class="comment">     * 然后将当前的操作符入符号栈， 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.</span></span><br><span class="line"><span class="comment">     * 4. 当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.</span></span><br><span class="line"><span class="comment">     * 5. 最后在数栈只有一个数字，就是表达式的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String expression = <span class="string">&quot;30+2*6-2&quot;</span>;</span><br><span class="line">        ArrayStack numStack = <span class="keyword">new</span> ArrayStack(<span class="number">10</span>);</span><br><span class="line">        ArrayStack operStack = <span class="keyword">new</span> ArrayStack(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ch = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> oper = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        StringBuilder num = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//获取当前遍历的值</span></span><br><span class="line">            ch = expression.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (isOper(ch)) &#123;</span><br><span class="line">                <span class="comment">//是符号   压入numStack</span></span><br><span class="line">                numStack.push(Integer.parseInt(num.toString()));</span><br><span class="line">                <span class="comment">//清空num</span></span><br><span class="line">                num.delete(<span class="number">0</span>,num.length());</span><br><span class="line">                <span class="keyword">if</span> (!operStack.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">//符号栈不为空 如果当前的操作符的优先级小于或者等于栈中的操作符</span></span><br><span class="line">                    <span class="keyword">if</span> (priority(ch) &lt;= priority(operStack.showTop())) &#123;</span><br><span class="line">                        <span class="comment">//当前的操作符的优先级小于或者等于栈中的操作符</span></span><br><span class="line">                        <span class="comment">// 3.2 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符，</span></span><br><span class="line">                        <span class="comment">// 就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，</span></span><br><span class="line">                        <span class="comment">// 然后将当前的操作符入符号栈， 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.</span></span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        oper = operStack.pop();</span><br><span class="line">                        res = calculation(num1, num2, oper);</span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                operStack.push(ch);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//是数字就直接push到numStack</span></span><br><span class="line"><span class="comment">//                numStack.push(ch - 48);</span></span><br><span class="line">                <span class="comment">//解决数字为多位的情况    每次判断的是数字的时候就添加的StringBuild中 然后在是符号的时候就将值压入栈中并清空</span></span><br><span class="line">                num.append(ch-<span class="number">48</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个数字压栈</span></span><br><span class="line">        numStack.push(Integer.parseInt(num.toString()));</span><br><span class="line">        <span class="comment">//清空num</span></span><br><span class="line">        num.delete(<span class="number">0</span>,num.length());</span><br><span class="line">        <span class="comment">//遍历表达式结束</span></span><br><span class="line">        <span class="comment">//开始计算结果 循环结束条件为符号栈为空</span></span><br><span class="line">        <span class="keyword">while</span> (!operStack.isEmpty()) &#123;</span><br><span class="line">            num1 = numStack.pop();</span><br><span class="line">            num2 = numStack.pop();</span><br><span class="line">            oper = operStack.pop();</span><br><span class="line">            res = calculation(num1, num2, oper);</span><br><span class="line">            numStack.push(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算结束后num剩下最后一个数 则是结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;表达式：&quot;</span> + expression + <span class="string">&quot; 的结果是：&quot;</span> + numStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否是符号  暂定只有加减乘除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ch 判断的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true：是 false：不是</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(<span class="keyword">int</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span> || ch == <span class="string">&#x27;*&#x27;</span> || ch == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断优先级</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ch 判断的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回值越大优先级越高</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">int</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;*&#x27;</span> || ch == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">int</span> oper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">// res 用于存放计算的结果</span></span><br><span class="line">        <span class="keyword">switch</span> (oper) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                res = num2 - num1;<span class="comment">// 注意顺序</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                res = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                res = num2 / num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6逆波兰计算器"><a href="#1-6逆波兰计算器" class="headerlink" title="1.6逆波兰计算器"></a>1.6逆波兰计算器</h3><p>我们完成一个逆波兰计算器，要求完成如下任务:</p>
<ol>
<li><p>输入一个逆波兰表达式(后缀表达式)，使用栈(Stack), 计算其结果 </p>
</li>
<li><p>支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。 </p>
</li>
<li><p>思路分析</p>
</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:</span><br><span class="line">1．从左至右扫描，将 3 和 4 压入堆栈；</span><br><span class="line">2．遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈；</span><br><span class="line">3．将 5 入栈；</span><br><span class="line">4．接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈；</span><br><span class="line">5．将 6 入栈；</span><br><span class="line">6．最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-30 10:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 逆波兰计算器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成将一个中缀表达式转成后缀表达式的功能</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 1+((2+3)×4)-5 =&gt; 转成  1 2 3 + 4 × + 5 –</span></span><br><span class="line">        <span class="comment">//2. 因为直接对str 进行操作，不方便，因此 先将  &quot;1+((2+3)×4)-5&quot; =》 中缀的表达式对应的List</span></span><br><span class="line">        <span class="comment">//   即 &quot;1+((2+3)×4)-5&quot; =&gt; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line">        <span class="comment">//3. 将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line">        <span class="comment">//   即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  =》 ArrayList [1,2,3,+,4,*,+,5,–]</span></span><br><span class="line">        <span class="comment">//中缀表达式</span></span><br><span class="line">        String Expression = <span class="string">&quot;10+((23+33)*41)-5&quot;</span>;</span><br><span class="line">        <span class="comment">//字符串转换成List</span></span><br><span class="line">        List&lt;String&gt; list = stringParseList(Expression);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//转换成后缀表达式的list</span></span><br><span class="line">        list = parseSuffixExpression(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(calculation(list));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        //定义一个后缀表达式</span></span><br><span class="line"><span class="comment">//        String suffixExpression = &quot;3 4 + 5 * 6 -&quot;;</span></span><br><span class="line"><span class="comment">//        //将后缀表达式分割成一个List</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; list = splitString(suffixExpression);</span></span><br><span class="line"><span class="comment">//        System.out.println(list);</span></span><br><span class="line"><span class="comment">//        int res = calculation(list);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;结果是：&quot; + res);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中缀表达式转后缀表达式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 中缀表达式list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 后缀表达式list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSuffixExpression</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1) 初始化两个栈：运算符栈s1和储存中间结果的栈s2；</span></span><br><span class="line">        <span class="comment">//2) 从左至右扫描中缀表达式；</span></span><br><span class="line">        <span class="comment">//3) 遇到操作数时，将其压s2；</span></span><br><span class="line">        <span class="comment">//4) 遇到运算符时，比较其与s1栈顶运算符的优先级：</span></span><br><span class="line">        <span class="comment">//1.如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</span></span><br><span class="line">        <span class="comment">//2.否则，若优先级比栈顶运算符的高，也将运算符压入s1；</span></span><br><span class="line">        <span class="comment">//3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；</span></span><br><span class="line">        <span class="comment">//5) 遇到括号时：(1) 如果是左括号“(”，则直接压入s1(2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">        <span class="comment">//6) 重复步骤2至5，直到表达式的最右边</span></span><br><span class="line">        <span class="comment">//7) 将s1中剩余的运算符依次弹出并压入s2</span></span><br><span class="line">        <span class="comment">//8)  依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//可以使用List来代替第二个栈，因为第二个栈没有出栈操作</span></span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//开始扫描表达式</span></span><br><span class="line">        <span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//匹配为数字直接加入到res</span></span><br><span class="line">                res.add(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果为左括号直接压栈到stack</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;)&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果是右括号 则依次从符号栈中弹出元素并加入到res 直到弹出元素为(时结束</span></span><br><span class="line">                String temp;</span><br><span class="line">                <span class="keyword">while</span> (!(temp = stack.pop()).equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                    res.add(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//item为运算符</span></span><br><span class="line">                <span class="comment">//4) 遇到运算符时，比较其与s1栈顶运算符的优先级：</span></span><br><span class="line">                <span class="comment">//1.如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</span></span><br><span class="line">                <span class="comment">//2.否则，若优先级比栈顶运算符的高，也将运算符压入s1；</span></span><br><span class="line">                <span class="comment">//3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stack.isEmpty() || stack.peek().equals(<span class="string">&quot;(&quot;</span>) || Operation.getValue(item) &gt; Operation.getValue(stack.peek())) &#123;</span><br><span class="line">                        stack.push(item);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.add(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将栈中剩余符号添加到res</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            res.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组转List</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expression 表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">stringParseList</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = expression.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch &gt;= <span class="number">48</span> &amp;&amp; ch &lt;= <span class="number">57</span>) &#123;</span><br><span class="line">                sb.append(ch);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sb.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(sb.toString());</span><br><span class="line">                sb.delete(<span class="number">0</span>, sb.length());</span><br><span class="line">                list.add((ch + <span class="string">&quot;&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list.add(ch + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(sb.toString());</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算后缀表达式</span></span><br><span class="line"><span class="comment">     * 30 4 + 5 × 6</span></span><br><span class="line"><span class="comment">     * 1.遍历表达式list 先将30 、 4 压入栈</span></span><br><span class="line"><span class="comment">     * 2.遇到符号后出栈两个数</span></span><br><span class="line"><span class="comment">     * 3.计算结果后将结果压入栈中</span></span><br><span class="line"><span class="comment">     * 4.遍历结束后栈中剩下最后一个数 就是结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 后缀表达式的list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculation</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果是数字则直接压栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="comment">//符号</span></span><br><span class="line">                <span class="keyword">switch</span> (item) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                        res = num1 + num2;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                        res = num2 - num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                        res = num1 * num2;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                        res = num2 / num1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将结果压栈</span></span><br><span class="line">                stack.push(res + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分割表达式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> suffixExpression 后缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分割后的list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">splitString</span><span class="params">(String suffixExpression)</span> </span>&#123;</span><br><span class="line">        String[] str = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(str));</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个类 Operation 可以返回一个运算符 对应的优先级</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ADD = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SUB = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MUL = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DIV = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，返回对应的优先级数字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(String operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;不存在该运算符&quot;</span> + operation);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-7中缀表达式转换为后缀表达式"><a href="#1-7中缀表达式转换为后缀表达式" class="headerlink" title="1.7中缀表达式转换为后缀表达式"></a>1.7中缀表达式转换为后缀表达式</h3><p>大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发 中，我们需要将 中缀表达式转成后缀表达式。</p>
<h4 id="1-7-1具体步骤如下："><a href="#1-7-1具体步骤如下：" class="headerlink" title="1.7.1具体步骤如下："></a>1.7.1具体步骤如下：</h4><ol>
<li><p>初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2； </p>
</li>
<li><p>从左至右扫描中缀表达式； </p>
</li>
<li><p>遇到操作数时，将其压 s2； </p>
</li>
<li><p>遇到运算符时，比较其与 s1 栈顶运算符的优先级：</p>
</li>
</ol>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108131334.png" alt="image-20210108130859020"></p>
<h4 id="1-7-2举例说明"><a href="#1-7-2举例说明" class="headerlink" title="1.7.2举例说明"></a>1.7.2举例说明</h4><p>将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下 </p>
<p>因此结果为 :”1 2 3 + 4 × + 5 –”</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108131335.png" alt="image-20210108130927103"></p>
<h4 id="1-7-3代码实现中缀表达式转为后缀表达式"><a href="#1-7-3代码实现中缀表达式转为后缀表达式" class="headerlink" title="1.7.3代码实现中缀表达式转为后缀表达式"></a>1.7.3代码实现中缀表达式转为后缀表达式</h4><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210108131231.png" alt="image-20210108130943629"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中缀表达式转后缀表达式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 中缀表达式list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 后缀表达式list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSuffixExpression</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1) 初始化两个栈：运算符栈s1和储存中间结果的栈s2；</span></span><br><span class="line">    <span class="comment">//2) 从左至右扫描中缀表达式；</span></span><br><span class="line">    <span class="comment">//3) 遇到操作数时，将其压s2；</span></span><br><span class="line">    <span class="comment">//4) 遇到运算符时，比较其与s1栈顶运算符的优先级：</span></span><br><span class="line">    <span class="comment">//1.如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</span></span><br><span class="line">    <span class="comment">//2.否则，若优先级比栈顶运算符的高，也将运算符压入s1；</span></span><br><span class="line">    <span class="comment">//3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；</span></span><br><span class="line">    <span class="comment">//5) 遇到括号时：(1) 如果是左括号“(”，则直接压入s1(2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">    <span class="comment">//6) 重复步骤2至5，直到表达式的最右边</span></span><br><span class="line">    <span class="comment">//7) 将s1中剩余的运算符依次弹出并压入s2</span></span><br><span class="line">    <span class="comment">//8)  依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</span></span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">//可以使用List来代替第二个栈，因为第二个栈没有出栈操作</span></span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//开始扫描表达式</span></span><br><span class="line">    <span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//匹配为数字直接加入到res</span></span><br><span class="line">            res.add(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//如果为左括号直接压栈到stack</span></span><br><span class="line">            stack.push(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;)&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//如果是右括号 则依次从符号栈中弹出元素并加入到res 直到弹出元素为(时结束</span></span><br><span class="line">            String temp;</span><br><span class="line">            <span class="keyword">while</span> (!(temp = stack.pop()).equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                res.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//item为运算符</span></span><br><span class="line">            <span class="comment">//4) 遇到运算符时，比较其与s1栈顶运算符的优先级：</span></span><br><span class="line">            <span class="comment">//1.如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</span></span><br><span class="line">            <span class="comment">//2.否则，若优先级比栈顶运算符的高，也将运算符压入s1；</span></span><br><span class="line">            <span class="comment">//3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.peek().equals(<span class="string">&quot;(&quot;</span>) || Operation.getValue(item) &gt; Operation.getValue(stack.peek())) &#123;</span><br><span class="line">                    stack.push(item);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(stack.pop());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将栈中剩余符号添加到res</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        res.add(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
        <category>Stack</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义Spring IOC总结</title>
    <url>/2021/03/30/%E8%87%AA%E5%AE%9A%E4%B9%89Spring-IOC%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>该博客由我学习黑马程序员视频：<a href="https://www.bilibili.com/video/BV1Np4y1z7BU?p=154">https://www.bilibili.com/video/BV1Np4y1z7BU?p=154</a> 根据老师思路写的简单Spring的ioc容器做的自我理解和总结</p>
<h1 id="2-源码"><a href="#2-源码" class="headerlink" title="2. 源码"></a>2. 源码</h1><h2 id="2-1-BeanFactory"><a href="#2-1-BeanFactory" class="headerlink" title="2.1 BeanFactory"></a>2.1 BeanFactory</h2><p>该接口是IOC容器中的最上层接口，定义了IOC容器的规范，我们常用的实现类为<strong>ClassPathXmlApplicationContext</strong>和<strong>SystemFileApplication</strong>这两个实现类是<strong>ApplicationContext</strong>接口的实现类<strong>ApplicationContext</strong>是继承于<strong>BeanFactory</strong>接口的与<strong>BeanFactory</strong>不同的是<strong>ApplicationContext</strong>是直接将bean创建并添加到IOC容器中，而<strong>BeanFactory</strong>是在使用的时候才会添加到IOC容器中，<strong>ApplicationContext</strong>中定义了<strong>void refresh()**方法 就是该方法将所有的bean添加到IOC容器中。</strong>AbstractApplicationContext**类是实现了ApplicationContext接口的抽象类 可以在这里声明解析器 IOC容器 和 文件路径 并且实现部分方法</p>
<blockquote>
<p>注：和Spring中有出入 Spring中是ConfigurableApplicationContext接口声明的refresh方法 因只是按照视频中学习的代码进行总结，如和Spring源码有冲突欢迎指正 以后有时间我也会再去看源码</p>
</blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210330230048.png" alt="image-20210330230043356"></p>
<h2 id="2-2-BeanDefinition"><a href="#2-2-BeanDefinition" class="headerlink" title="2.2 BeanDefinition"></a>2.2 BeanDefinition</h2><p>该接口是用来存在从文件中解析出来的bean对象的属性的，在Spring源码中该接口有许多的实现类，暂时我不会去了解那么多，还是按照老师教的来，一个BeanDefinition实现类对象可以存放一个Bean 实现类对象中应该需要能够存放<property>标签中的属性所以需要一个对象来存放property的属性 所以有类 <strong>PropertyValue</strong>，因为一个bean可能有多个property标签 所以我们需要一个容器来存放PropertyValue所以我们有了MutablePropertyValues类，该类是一个PropertyValue的容器类，在下图中我们就可以看到它声明了一个集合泛型是PropertyValue<img src="https://gitee.com/Pink_oops/image/raw/master/20210330231639.png" alt="image-20210330231639297"></p>
<h2 id="2-3-BeanDefinitionRegistry"><a href="#2-3-BeanDefinitionRegistry" class="headerlink" title="2.3 BeanDefinitionRegistry"></a>2.3 BeanDefinitionRegistry</h2><p>该类是Bean的注册表接口，声明了接口的规范</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210330232122.png" alt="image-20210330232122109"></p>
<h3 id="2-3-1-SimpleBeanDefinitionRegistry"><a href="#2-3-1-SimpleBeanDefinitionRegistry" class="headerlink" title="2.3.1 SimpleBeanDefinitionRegistry"></a>2.3.1 SimpleBeanDefinitionRegistry</h3><p>该类是<strong>BeanDefinitionRegistry</strong>简单的一个实现类 声明了一个容器存放注册信息 等价于一个注册表，然后实现接口的方法就是在操作Map</p>
<blockquote>
<p>这里使用的是ConcurrentHashMap是考虑到了多线程的情况，等下我们自定义的Spring不会考虑多线程</p>
</blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210330232346.png" alt="image-20210330232346202"></p>
<h2 id="2-4-BeanDefinitionReader"><a href="#2-4-BeanDefinitionReader" class="headerlink" title="2.4 BeanDefinitionReader"></a>2.4 BeanDefinitionReader</h2><p>该接口是定义的解析模式，如我们常用的ClassPathXmlApplicationContext就是使用该接口的实现类XmlBeanDefinitionReader来解析的</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210330232745.png" alt="image-20210330232745463"></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210330232806.png" alt="image-20210330232806426"></p>
<h1 id="3-自定义Spring"><a href="#3-自定义Spring" class="headerlink" title="3. 自定义Spring"></a>3. 自定义Spring</h1><p><img src="https://gitee.com/Pink_oops/image/raw/master/20210330233224.png" alt="image-20210330233224820"></p>
<h2 id="3-1-beans"><a href="#3-1-beans" class="headerlink" title="3.1 beans"></a>3.1 beans</h2><p>BeanDefinition</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.spring.framework.beans;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/30 7:48 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MutablePropertyValues mutablePropertyValues;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mutablePropertyValues = <span class="keyword">new</span> MutablePropertyValues();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutablePropertyValues <span class="title">getMutablePropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mutablePropertyValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMutablePropertyValues</span><span class="params">(MutablePropertyValues mutablePropertyValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mutablePropertyValues = mutablePropertyValues;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处没有按照Spring框架使用的接口，因为我们只是要设计一个简单的Spring</p>
</blockquote>
<p>MutablePropertyValues</p>
<p>该对象实现了Iterable接口 实现了iterator方法 使用了设计模式中的行为型模式的迭代器模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.spring.framework.beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/29 5:19 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 存放PropertyValue对象的容器</span></span><br><span class="line"><span class="comment"> * 此类使用迭代器模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutablePropertyValues</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">PropertyValue</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放PropertyValue对象的容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PropertyValue&gt; propertyValues;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutablePropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.propertyValues = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutablePropertyValues</span><span class="params">(List&lt;PropertyValue&gt; propertyValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (propertyValues == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.propertyValues = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.propertyValues = propertyValues;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据name获取PropertyValue</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果不存在的话则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyValue <span class="title">getPropertyValue</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (PropertyValue propertyValue : propertyValues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.equals(propertyValue.getName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> propertyValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取全部的PropertyValue</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> PropertyValue[] getPropertyValues() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.propertyValues.toArray(<span class="keyword">new</span> PropertyValue[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加PropertyValue</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> propertyValue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回当前对象 为了实现链式编程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutablePropertyValues <span class="title">addPropertyValue</span><span class="params">(PropertyValue propertyValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否已经存在 如果已经存在则覆盖</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyValues.size(); i++) &#123;</span><br><span class="line">            PropertyValue currentPropertyValue = propertyValues.get(i);</span><br><span class="line">            <span class="comment">//相同</span></span><br><span class="line">            <span class="keyword">if</span> (currentPropertyValue.getName().equals(propertyValue.getName())) &#123;</span><br><span class="line">                propertyValues.set(i, propertyValue);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.propertyValues.add(propertyValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否已存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> propertyValue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsPropertyValue</span><span class="params">(PropertyValue propertyValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.containsPropertyValue(propertyValue.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否已存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsPropertyValue</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getPropertyValue(name) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 为空返回true 不为空返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.propertyValues.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现Iterable接口实现的方法</span></span><br><span class="line"><span class="comment">     * 返回迭代器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;PropertyValue&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.propertyValues.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PropertyValue</p>
<p>该对象使用了创建者模式中的建造者模式 提供了链式编程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.spring.framework.beans;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/29 5:15 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> *  PropertyValue存放的是bean标签内的子标签property中的属性</span></span><br><span class="line"><span class="comment"> *  name: bean对象中需要set的属性的变量名</span></span><br><span class="line"><span class="comment"> *  res: 引用的值 可以引用bean</span></span><br><span class="line"><span class="comment"> *  value: 如果是基本数据类型可以直接使用value属性进行注入</span></span><br><span class="line"><span class="comment"> *  &lt;bean id=&quot;user&quot; class=&quot;com.wsy.pojo.User&quot;&gt;</span></span><br><span class="line"><span class="comment"> *       &lt;property name=&quot;userName&quot; ref=&quot;userName&quot;&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment"> *       &lt;property name=&quot;userName&quot; value=&quot;wsy&quot;&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment"> *  &lt;/bean&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String ref;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertyValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertyValue</span><span class="params">(String name, String ref, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.ref = ref;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertyValue</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = builder.name;</span><br><span class="line">        <span class="keyword">this</span>.ref = builder.ref;</span><br><span class="line">        <span class="keyword">this</span>.value = builder.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String ref;</span><br><span class="line">        <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">name</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">ref</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.ref = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">value</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> PropertyValue <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PropertyValue(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRef</span><span class="params">(String ref)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ref = ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-context"><a href="#3-2-context" class="headerlink" title="3.2 context"></a>3.2 context</h2><h3 id="3-2-1-support"><a href="#3-2-1-support" class="headerlink" title="3.2.1 support"></a>3.2.1 support</h3><p>ApplicationContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.spring.framework.context.support;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.factory.BeanFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/30 8:45 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 立即加载Bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException, Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractApplicationContext</p>
<p>在这里使用了行为型模式中的模版方法模式 这里使用的getBean方法是依靠子类重写后实现的</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210330234043.png" alt="image-20210330234043344"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.spring.framework.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.beans.BeanDefinition;</span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.context.support.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.factory.support.BeanDefinitionReader;</span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.factory.support.BeanDefinitionRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/30 8:46 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bean解析器 这里值声明 不创建 在子类中创建实例</span></span><br><span class="line"><span class="comment">     * 因为可能加载的文件不同 实现的方式就也不同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> BeanDefinitionReader beanDefinitionReader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IOC容器 此处不考虑多线程问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件类路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> String configLocation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException, Exception </span>&#123;</span><br><span class="line">        <span class="comment">//加载BeanDefinition</span></span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionReader.loadBeanDefinitions(<span class="keyword">this</span>.configLocation);</span><br><span class="line">        <span class="comment">//初始化bean</span></span><br><span class="line">        finishBeanInitialization();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成bean的初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishBeanInitialization</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanDefinitionRegistry registry = <span class="keyword">this</span>.beanDefinitionReader.getRegistry();</span><br><span class="line">        String[] names = registry.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            BeanDefinition beanDefinition = registry.getBeanDefinition(name);</span><br><span class="line">            getBean(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ClassPathXmlApplicationContext</p>
<p>这里是IOC容器的最后实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.spring.framework.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.beans.BeanDefinition;</span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.beans.MutablePropertyValues;</span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.beans.PropertyValue;</span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.factory.support.BeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.factory.xml.XmlBeanDefinitionReader;</span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/30 9:06 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configLocation = configLocation;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader();</span><br><span class="line">        <span class="keyword">this</span>.refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//如果beanName存在则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.map.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.map.get(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// beanName不存在的话我们就需要通过反射来创建</span></span><br><span class="line">        BeanDefinitionRegistry registry = <span class="keyword">this</span>.beanDefinitionReader.getRegistry();</span><br><span class="line">        BeanDefinition beanDefinition = registry.getBeanDefinition(beanName);</span><br><span class="line">        <span class="comment">//如果在注册表中都不存在的话则代表当前需要获取的bean是没有被注册的</span></span><br><span class="line">        <span class="keyword">if</span> (beanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;找不到&quot;</span> + beanName + <span class="string">&quot;的实例对象&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过反射创建对象</span></span><br><span class="line">        String className = beanDefinition.getClassName();</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">        Object beanObject = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可能中间需要依赖注入(DI)</span></span><br><span class="line">        MutablePropertyValues mutablePropertyValues = beanDefinition.getMutablePropertyValues();</span><br><span class="line">        <span class="keyword">for</span> (PropertyValue propertyValue : mutablePropertyValues) &#123;</span><br><span class="line">            String name = propertyValue.getName();</span><br><span class="line">            String ref = propertyValue.getRef();</span><br><span class="line">            String value = propertyValue.getValue();</span><br><span class="line">            <span class="comment">//ref属性和value属性只会出现一个</span></span><br><span class="line">            <span class="keyword">if</span> (ref != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(ref)) &#123;</span><br><span class="line">                <span class="comment">//ref的话是引用ioc容器里的对象 递归引用</span></span><br><span class="line">                Object bean = <span class="keyword">this</span>.getBean(ref);</span><br><span class="line">                <span class="comment">//需要拼接方法名</span></span><br><span class="line">                String methodName = StringUtils.getMethodName(name);</span><br><span class="line">                <span class="comment">//这里因为如果要根据方法名获取方法对象的话还需要找到需要注入的属性的class字节码对象 所以直接遍历属性对象</span></span><br><span class="line"><span class="comment">//                clazz.getMethod(methodName, )</span></span><br><span class="line">                Method[] methods = clazz.getMethods();</span><br><span class="line">                <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (methodName.equals(method.getName())) &#123;</span><br><span class="line">                        <span class="comment">//调用setter方法</span></span><br><span class="line">                        method.invoke(beanObject, bean);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(value)) &#123;</span><br><span class="line">                <span class="comment">//需要拼接方法名</span></span><br><span class="line">                String methodName = StringUtils.getMethodName(name);</span><br><span class="line">                Method method = clazz.getMethod(methodName, String.class);</span><br><span class="line">                method.invoke(beanObject, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在返回之前将实例存入到map中 避免重复创建</span></span><br><span class="line">        <span class="keyword">this</span>.map.put(beanName, beanObject);</span><br><span class="line">        <span class="keyword">return</span> beanObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String beanName, Class&lt;? extends T&gt; clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object bean = <span class="keyword">this</span>.getBean(beanName);</span><br><span class="line">        <span class="keyword">return</span> clazz.cast(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StringUitls</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.spring.framework.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/30 9:15 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StringUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回setter方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 需要设置的成员变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> setXxx</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMethodName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;set&quot;</span> + name.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + name.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-factory"><a href="#3-3-factory" class="headerlink" title="3.3 factory"></a>3.3 factory</h2><h3 id="3-3-1-support"><a href="#3-3-1-support" class="headerlink" title="3.3.1 support"></a>3.3.1 support</h3><p>BeanDefinitionReader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.spring.framework.factory.support;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/30 8:07 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> bean的解析器 主要用来获取注册表以及解析文本并注册到注册器中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得注册表对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载所有的bean标签</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configLocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BeanDefinitionRegistry</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.spring.framework.factory.support;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.beans.BeanDefinition;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/30 7:47 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 注册表接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注册BeanDefinition对象到注册表中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从注册表中删除指定名称的BeanDefinition对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据名称从注册表中获取BeanDefinition对象</span></span><br><span class="line">    <span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    String[] getBeanDefinitionNames();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SimpleBeanDefinitionRegistry</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.spring.framework.factory.support;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.beans.BeanDefinition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/30 7:49 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 简单的BeanDefinitionRegistry实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBeanDefinitionRegistry</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinitionMap.containsKey(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinitionMap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanDefinitionNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinitionMap.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-xml"><a href="#3-3-2-xml" class="headerlink" title="3.3.2 xml"></a>3.3.2 xml</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.spring.framework.factory.xml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.beans.BeanDefinition;</span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.beans.MutablePropertyValues;</span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.beans.PropertyValue;</span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.factory.support.BeanDefinitionReader;</span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.factory.support.BeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> com.wsy.spring.framework.factory.support.SimpleBeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/30 8:09 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BeanDefinitionRegistry registry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registry = <span class="keyword">new</span> SimpleBeanDefinitionRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.registry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        InputStream is = XmlBeanDefinitionReader.class.getClassLoader().getResourceAsStream(configLocation);</span><br><span class="line">        Document document = reader.read(is);</span><br><span class="line">        <span class="comment">//获得根节点&lt;beans&gt;</span></span><br><span class="line">        Element rootElement = document.getRootElement();</span><br><span class="line">        <span class="comment">//获得所有的&lt;bean&gt;节点</span></span><br><span class="line">        List&lt;Element&gt; beans = rootElement.elements(<span class="string">&quot;bean&quot;</span>);</span><br><span class="line">        <span class="comment">//将xml中的所以bean都注册到registry中</span></span><br><span class="line">        <span class="keyword">for</span> (Element bean : beans) &#123;</span><br><span class="line">            String id = bean.attributeValue(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            String className = bean.attributeValue(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">            BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">            <span class="comment">//封装 beanDefinition</span></span><br><span class="line">            beanDefinition.setId(id);</span><br><span class="line">            beanDefinition.setClassName(className);</span><br><span class="line">            List&lt;Element&gt; properties = bean.elements(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">            MutablePropertyValues mutablePropertyValues = <span class="keyword">new</span> MutablePropertyValues();</span><br><span class="line">            <span class="comment">//解析property标签</span></span><br><span class="line">            <span class="keyword">for</span> (Element property : properties) &#123;</span><br><span class="line">                String name = property.attributeValue(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                String ref = property.attributeValue(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">                String value = property.attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                PropertyValue propertyValue = <span class="keyword">new</span> PropertyValue.Builder()</span><br><span class="line">                        .name(name)</span><br><span class="line">                        .ref(ref)</span><br><span class="line">                        .value(value)</span><br><span class="line">                        .builder();</span><br><span class="line">                mutablePropertyValues.addPropertyValue(propertyValue);</span><br><span class="line">            &#125;</span><br><span class="line">            beanDefinition.setMutablePropertyValues(mutablePropertyValues);</span><br><span class="line">            <span class="keyword">this</span>.registry.registerBeanDefinition(beanDefinition.getId(), beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.spring.framework.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/30 8:43 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String beanName, Class&lt;? extends T&gt; clazz)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h1><p><img src="https://gitee.com/Pink_oops/image/raw/master/20210330235350.png" alt="image-20210330235350247"></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210330235408.png" alt="image-20210330235408208"></p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>通过本次的自定义Spring IOC容器，巩固了我反射以及刚刚学习的设计模式的知识，并且让我了解到了Spring IOC容器大概的是怎么样实现的，但是在过程中很多时候都是想不到需要这样写的，脑子里还是没有那种使用设计模式的思路，唯一知道能够用的就只有单例模式，建造者模式和策略模式，以后还要在平时开发中不断思考能不能用到某种设计模式来更熟悉的利用设计模式来设计出更好的代码。</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习笔记</title>
    <url>/2021/02/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-二分查找算法-非递归"><a href="#1-二分查找算法-非递归" class="headerlink" title="1. 二分查找算法(非递归)"></a>1. 二分查找算法(非递归)</h2><h3 id="1-1二分查找算法-非递归-介绍"><a href="#1-1二分查找算法-非递归-介绍" class="headerlink" title="1.1二分查找算法(非递归)介绍"></a>1.1二分查找算法(非递归)介绍</h3><ol>
<li>前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式</li>
<li>二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找</li>
<li>二分查找法的运行时间为对数时间 O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n 步，假设从[0,99]的 队列(100 个数，即 n=100)中寻到目标数 30，则需要查找步数为㏒₂100 , 即最多需要查找 7 次( 2^6 &lt; 100 &lt; 2^7)</li>
</ol>
<h3 id="1-2二分查找算法-非递归-代码实现"><a href="#1-2二分查找算法-非递归-代码实现" class="headerlink" title="1.2二分查找算法(非递归)代码实现"></a>1.2二分查找算法(非递归)代码实现</h3><p>数组 {1,3, 8, 10, 11, 67, 100}, 编程实现二分查找， 要求使用非递归的方式完成. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.binarysearch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/31 11:49 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 二分查找非递归</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        System.out.println(binarySearch(arr, <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    源数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标值下标 如果没找到返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; arr[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; arr[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-分治算法"><a href="#2-分治算法" class="headerlink" title="2.分治算法"></a>2.分治算法</h2><h3 id="2-1分治算法介绍"><a href="#2-1分治算法介绍" class="headerlink" title="2.1分治算法介绍"></a>2.1分治算法介绍</h3><p>分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或 相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题 的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p>
<p>分治算法可以求解的一些经典问题</p>
<ul>
<li>二分搜索</li>
<li>大整数乘法</li>
<li>棋盘覆盖</li>
<li>合并排序</li>
<li>快速排序</li>
<li>线性时间选择</li>
<li>最接近点对问题</li>
<li>循环赛日程表</li>
<li>汉诺塔</li>
</ul>
<h3 id="2-2分治算法的基本步骤"><a href="#2-2分治算法的基本步骤" class="headerlink" title="2.2分治算法的基本步骤"></a>2.2分治算法的基本步骤</h3><p><strong>分治法在每一层递归上都有三个步骤：</strong> </p>
<ol>
<li><strong>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题</strong></li>
<li><strong>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</strong></li>
<li><strong>合并：将各个子问题的解合并为原问题的解。</strong></li>
</ol>
<h3 id="2-3分治-Divide-and-Conquer-P-算法设计模式如下："><a href="#2-3分治-Divide-and-Conquer-P-算法设计模式如下：" class="headerlink" title="2.3分治(Divide-and-Conquer(P))算法设计模式如下："></a>2.3分治(Divide-and-Conquer(P))算法设计模式如下：</h3><p><img src="https://gitee.com/Pink_oops/image/raw/master/20210207141341.png" alt="image-20210207141334627"></p>
<h3 id="2-4分治算法最佳实践-汉诺塔"><a href="#2-4分治算法最佳实践-汉诺塔" class="headerlink" title="2.4分治算法最佳实践-汉诺塔"></a>2.4分治算法最佳实践-汉诺塔</h3><p>汉诺塔的传说 </p>
<p>汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金 刚石柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小 顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
<p>假如每秒钟一次，共需多长时间呢？移完这些金片需要 5845.54 亿年以上，太阳系的预期寿命据说也就是数百 亿年。真的过了 5845.54 亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。</p>
<p>汉诺塔游戏的演示和思路分析:</p>
<ol>
<li>如果是有一个盘， A-&gt;C 如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘</li>
<li>先把最上面的盘 A-&gt;B</li>
<li>把最下边的盘 A-&gt;C</li>
<li>把 B 塔的所有盘 从 B-&gt;C</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.dac;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/2/5 2:36 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 汉诺塔</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hanoitower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        hanoitower(<span class="number">3</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 汉诺塔</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 盘子数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a   a塔</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b   b塔</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c   c塔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoitower</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">char</span> a, <span class="keyword">char</span> b, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + num + <span class="string">&quot;个盘子 &quot;</span> + a + <span class="string">&quot;=&gt;&quot;</span> + c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将盘子分为上下两个盘子 上：除了最下面一个盘子的所有盘子 下：最下面的盘子</span></span><br><span class="line">            <span class="comment">//1.将上面的盘子移动到b塔 期间可能需要借助到c塔</span></span><br><span class="line">            hanoitower(num - <span class="number">1</span>, a, c, b);</span><br><span class="line">            <span class="comment">//2.将最下面的盘子移动到c塔</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + num + <span class="string">&quot;个盘子 &quot;</span> + a + <span class="string">&quot;=&gt;&quot;</span> + c);</span><br><span class="line">            <span class="comment">//3.将b塔的盘子移动到c塔 期间可能需要借助到a塔</span></span><br><span class="line">            hanoitower(num - <span class="number">1</span>, b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-动态规划算法"><a href="#3-动态规划算法" class="headerlink" title="3.动态规划算法"></a>3.动态规划算法</h2><h3 id="3-1应用场景-背包问题"><a href="#3-1应用场景-背包问题" class="headerlink" title="3.1应用场景-背包问题"></a>3.1应用场景-背包问题</h3><p><img src="https://gitee.com/Pink_oops/image/raw/master/20210207141558.png" alt="image-20210207141558240"></p>
<ol>
<li>要求达到的目标为装入的背包的总价值最大，并且重量不超出 </li>
<li>要求装入的物品不能重复</li>
</ol>
<h3 id="3-2-动态规划算法介绍"><a href="#3-2-动态规划算法介绍" class="headerlink" title="3.2 动态规划算法介绍"></a>3.2 动态规划算法介绍</h3><ol>
<li>动态规划(Dynamic Programming)算法的核心思想是：将<strong>大问题划分为小问题</strong>进行解决，从而一步步获取最优解的处理算法</li>
<li>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 </li>
<li>与分治法不同的是，适合于用动态规划求解的问题，经分解得到<strong>子问题往往不是互相独立的</strong>。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 ) </li>
<li>动态规划可以通过填表的方式来逐步推进，得到最优解.</li>
</ol>
<h3 id="3-3动态规划算法最佳实践-背包问题"><a href="#3-3动态规划算法最佳实践-背包问题" class="headerlink" title="3.3动态规划算法最佳实践-背包问题"></a>3.3动态规划算法最佳实践-背包问题</h3><p><img src="https://gitee.com/Pink_oops/image/raw/master/20210207141718.png" alt="image-20210207141718215"></p>
<ol>
<li>要求达到的目标为装入的背包的总价值最大，并且重量不超出 </li>
<li>要求装入的物品不能重复</li>
</ol>
<p>思路分析</p>
<ol>
<li>背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价 值最大。其中又分 <strong>01</strong> <strong>背包</strong>和<strong>完全背包</strong>(完全背包指的是：每种物品都有无限件可用) </li>
<li>这里的问题属于 <strong>01</strong> <strong>背包</strong>，即每个物品最多放一个。而无限背包可以转化为 01 背包。</li>
<li>算法的主要思想，利用动态规划来解决。每次遍历到的第 i 个物品，根据 w[i]和 v[i]来确定是否需要将该物品 放入背包中。即对于给定的 n 个物品，设 v[i]、w[i]分别为第 i 个物品的价值和重量，C 为背包的容量。再令 v[i][j] 表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值。则我们有下面的结果： </li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(1) v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是 0 </span><br><span class="line">(2) 当 w[i]&gt; j 时：v[i][j]=v[i-1][j] // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个 单元格的装入策略 </span><br><span class="line">(3) 当 j&gt;=w[i]时： v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125; </span><br><span class="line">// 当 准备加入的新增的商品的容量小于等于当前背包的容量, </span><br><span class="line">// 装入的方式: </span><br><span class="line">v[i-1][j]： 就是上一个单元格的装入的最大值 </span><br><span class="line">v[i] : 表示当前商品的价值 v[i-1][j-w[i]] ： 装入 i-1 商品，到剩余空间 j-w[i]的最大值 </span><br><span class="line">当 j&gt;=w[i]时： v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125; :</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210207141915.png" alt="image-20210207141915132"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.dynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/2/5 6:26 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 背包问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapsackProblem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个物品所占的容量</span></span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">//每个物品的价格</span></span><br><span class="line">        <span class="keyword">int</span>[] value = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;;</span><br><span class="line">        <span class="comment">//背包的容量</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//创建二维数组 v[i][j] 表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值</span></span><br><span class="line">        <span class="keyword">int</span>[][] v = <span class="keyword">new</span> <span class="keyword">int</span>[w.length + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//为了记录放入商品的情况，我们定一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[v.length + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        (1) v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是 0</span></span><br><span class="line"><span class="comment">        (2) 当 w[i]&gt; j 时：v[i][j]=v[i-1][j] // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个 单元格的装入策略</span></span><br><span class="line"><span class="comment">        (3) 当 j&gt;=w[i]时： v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125;</span></span><br><span class="line"><span class="comment">        // 当 准备加入的新增的商品的容量小于等于当前背包的容量,</span></span><br><span class="line"><span class="comment">        // 装入的方式: v[i-1][j]： 就是上一个单元格的装入的最大值 v[i] :</span></span><br><span class="line"><span class="comment">        表示当前商品的价值 v[i-1][j-w[i]] ： 装入 i-1 商品，到剩余空间 j-w[i]的最大值</span></span><br><span class="line"><span class="comment">        当 j&gt;=w[i]时： v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125; :</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//初始化二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            v[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            v[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历v数组 计算出每个方案的价格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; v[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="comment">//如果需要放进去的商品的容量大于当前背包的容量</span></span><br><span class="line">                <span class="keyword">if</span> (w[i - <span class="number">1</span>] &gt; j) &#123;</span><br><span class="line">                    v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//放进去的商品的容量小于等于背包的容量</span></span><br><span class="line">                    <span class="keyword">if</span> (v[i - <span class="number">1</span>][j] &lt; (value[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][m - w[i - <span class="number">1</span>]])) &#123;</span><br><span class="line">                        v[i][j] = (value[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][m - w[i - <span class="number">1</span>]]);</span><br><span class="line">                        path[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(v[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = path.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//行的最大下标</span></span><br><span class="line">        <span class="keyword">int</span> j = path[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//列的最大下标</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//从 path 的最后开始找</span></span><br><span class="line">            <span class="keyword">if</span> (path[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;第%d 个商品放入到背包\n&quot;</span>, i);</span><br><span class="line">                j -= w[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-KMP算法"><a href="#4-KMP算法" class="headerlink" title="4.KMP算法"></a>4.KMP算法</h2><h3 id="4-1应用场景-字符串匹配问题"><a href="#4-1应用场景-字符串匹配问题" class="headerlink" title="4.1应用场景-字符串匹配问题"></a>4.1应用场景-字符串匹配问题</h3><p>字符串匹配问题</p>
<ol>
<li>有一个字符串 str1= “”硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好””，和一个子串 str2=”尚硅谷你尚硅你” </li>
<li>现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</li>
</ol>
<h3 id="4-2暴力匹配算法"><a href="#4-2暴力匹配算法" class="headerlink" title="4.2暴力匹配算法"></a>4.2暴力匹配算法</h3><p>如果用暴力匹配的思路，并假设现在 str1 匹配到 i 位置，子串 str2 匹配到 j 位置，则有:</p>
<ol>
<li>如果当前字符匹配成功（即 str1[i] == str2[j]），则 i++，j++，继续匹配下一个字符</li>
<li>如果失配（即 str1[i]! = str2[j]），令 i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为 0。</li>
<li>用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!) </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.kmp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/2/7 9:50 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 暴力匹配算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViolenceMatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;尚硅谷你尚硅你&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;s1 &quot;</span> + str1.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;s2 &quot;</span> + str2.length());</span><br><span class="line">        <span class="keyword">int</span> index = violenceMatch(str1, str2);</span><br><span class="line">        System.out.println(<span class="string">&quot;index=&quot;</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暴力匹配算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1 字符串1 主串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2 字符串2 子串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回第一个匹配到的下表 如果没有匹配到则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">violenceMatch</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s1.length() &amp;&amp; j &lt; s1.length()) &#123;</span><br><span class="line">            <span class="comment">//保留最开始的下标</span></span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">while</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(j == s2.length()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j!= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//代表匹配失败 重新设置i 和 j</span></span><br><span class="line">                i = i - (j - <span class="number">1</span>);</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3KMP-算法介绍"><a href="#4-3KMP-算法介绍" class="headerlink" title="4.3KMP 算法介绍"></a>4.3KMP 算法介绍</h3><ol>
<li>KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法</li>
<li>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的 出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的 姓氏命名此算法.</li>
<li>KMP 方法算法就利用之前判断过信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次 回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间 </li>
<li>参考资料：<a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html">https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</a> </li>
</ol>
<h3 id="4-4KMP-算法最佳应用-字符串匹配问题"><a href="#4-4KMP-算法最佳应用-字符串匹配问题" class="headerlink" title="4.4KMP 算法最佳应用-字符串匹配问题"></a>4.4KMP 算法最佳应用-字符串匹配问题</h3><ol>
<li>有一个字符串 str1= “BBC ABCDAB ABCDABCDABDE”，和一个子串 str2=”ABCDABD” </li>
<li>现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</li>
<li>要求：使用 <strong>KMP</strong> <strong>算法完成</strong>判断，不能使用简单的暴力匹配算法. </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.kmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/2/7 11:55 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;ABCDABD&quot;</span>;</span><br><span class="line">        <span class="comment">//String str2 = &quot;BBC&quot;;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] next = kmpNext(<span class="string">&quot;ABCDABD&quot;</span>); <span class="comment">//[0, 1, 2, 0]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;next=&quot;</span> + Arrays.toString(next));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = kmpSearch(str1, str2, next);</span><br><span class="line">        System.out.println(<span class="string">&quot;index=&quot;</span> + index); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 源字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 子串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 子串的部分匹配表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果匹配成功返回第一个下标的值 如果失败饭不会-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmpSearch</span><span class="params">(String str1, String str2, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//KMP算法的核心</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == str2.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取字符串的部分匹配表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dest 字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字符串的部分匹配表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] kmpNext(String dest) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[dest.length()];</span><br><span class="line">        <span class="comment">//第一个字符串的部分匹配表一定是0</span></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; dest.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//kmp算法的核心 处理dest.charAt(i) != dest.charAt(j 的情况</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dest.charAt(i) == dest.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-贪心算法"><a href="#5-贪心算法" class="headerlink" title="5.贪心算法"></a>5.贪心算法</h2><h3 id="5-1应用场景-集合覆盖问题"><a href="#5-1应用场景-集合覆盖问题" class="headerlink" title="5.1应用场景-集合覆盖问题"></a>5.1应用场景-集合覆盖问题</h3><p>假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区 都可以接收到信号 </p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210207191410.png" alt="image-20210207191402710"></p>
<h3 id="5-2贪心算法介绍"><a href="#5-2贪心算法介绍" class="headerlink" title="5.2贪心算法介绍"></a>5.2贪心算法介绍</h3><ol>
<li>婪算法(贪心算法)是指在对问题进行求解时，<strong>在每一步选择中都采取最好或者最优</strong>(<strong>即最有利</strong>)<strong>的选择</strong>，从而 希望能够导致结果是最好或者最优的算法 </li>
<li>贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</li>
</ol>
<h3 id="5-3贪心算法最佳应用-集合覆盖"><a href="#5-3贪心算法最佳应用-集合覆盖" class="headerlink" title="5.3贪心算法最佳应用-集合覆盖"></a>5.3贪心算法最佳应用-集合覆盖</h3><ol>
<li><p>假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号 <img src="https://gitee.com/Pink_oops/image/raw/master/20210207191521.png" alt="image-20210207191521128"></p>
</li>
<li><p>思路分析</p>
<p>如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假 设总的有 n 个广播台，则广播台的组合总共有 2ⁿ -1 个,假设每秒可以计算 10 个子集， 如图:<img src="https://gitee.com/Pink_oops/image/raw/master/20210207191604.png" alt="image-20210207191604290"></p>
</li>
</ol>
<p>使用贪婪算法，效率高：</p>
<ol>
<li>目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择 策略上，因为需要覆盖全部地区的最小集合:</li>
<li>遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系）</li>
<li>将这个电台加入到一个集合中(比如 ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。</li>
<li>重复第 1 步<strong>直到覆盖了全部的</strong>地区</li>
</ol>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210207191649.png" alt="image-20210207191649631"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.greedy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/2/7 4:21 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 贪心算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreedyAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建广播电台,放入到Map</span></span><br><span class="line">        HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> HashMap&lt;String, HashSet&lt;String&gt;&gt;();</span><br><span class="line">        <span class="comment">//将各个电台放入到broadcasts</span></span><br><span class="line">        HashSet&lt;String&gt; hashSet1 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        hashSet1.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet2 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        hashSet2.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        hashSet2.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        hashSet2.add(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet3 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        hashSet3.add(<span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        hashSet3.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet3.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet4 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        hashSet4.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet4.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet5 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        hashSet5.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        hashSet5.add(<span class="string">&quot;大连&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入到map</span></span><br><span class="line">        broadcasts.put(<span class="string">&quot;K1&quot;</span>, hashSet1);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K2&quot;</span>, hashSet2);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K3&quot;</span>, hashSet3);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K4&quot;</span>, hashSet4);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K5&quot;</span>, hashSet5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//allAreas 存放所有的地区</span></span><br><span class="line">        HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        allAreas.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;大连&quot;</span>);</span><br><span class="line">        <span class="comment">//创建一个集合存放选择的电台</span></span><br><span class="line">        List&lt;String&gt; selects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//只要没有覆盖全部区域就继续循环</span></span><br><span class="line">        <span class="keyword">while</span>(allAreas.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String maxKey = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//遍历所有电台找出覆盖的最大的电台</span></span><br><span class="line">            <span class="keyword">for</span> (String key : broadcasts.keySet()) &#123;</span><br><span class="line">                HashSet&lt;String&gt; areas = broadcasts.get(key);</span><br><span class="line">                <span class="comment">//进行交集运算 并将结果返回给areas</span></span><br><span class="line">                areas.retainAll(allAreas);</span><br><span class="line">                <span class="keyword">if</span>(maxKey == <span class="keyword">null</span> || areas.size() &gt; broadcasts.get(maxKey).size()) &#123;</span><br><span class="line">                    maxKey = key;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将maxKey添加到selects</span></span><br><span class="line">            selects.add(maxKey);</span><br><span class="line">            <span class="comment">//删除allAreas中已被选择的区域</span></span><br><span class="line">            allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;得到的结果是：&quot;</span> + selects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表学习笔记</title>
    <url>/2021/01/07/%E9%93%BE%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-链表"><a href="#1-链表" class="headerlink" title="1.链表"></a>1.链表</h2><h3 id="1-1链表-Linked-List-介绍"><a href="#1-1链表-Linked-List-介绍" class="headerlink" title="1.1链表(Linked List)介绍"></a>1.1链表(Linked List)介绍</h3><p>链表是有序的列表，但是它在内存中是存储如下</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107184303.png" alt="image-20210107183050360"></p>
<ol>
<li><p>链表是以节点的方式来存储,是链式存储 </p>
</li>
<li><p>每个节点包含 data 域， next 域：指向下一个节点. </p>
</li>
<li><p>如图：发现链表的各个节点不一定是连续存储. </p>
</li>
<li><p>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</p>
</li>
</ol>
<ul>
<li><p>单链表(带头结点) 逻辑结构示意图如下</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107184304.png" alt="image-20210107183204753"></p>
</li>
</ul>
<h3 id="1-2单链表的实例"><a href="#1-2单链表的实例" class="headerlink" title="1.2单链表的实例"></a>1.2单链表的实例</h3><p>使用带 head 头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作， 注: 删除和修改,查找 可以考虑学员独立完成，也可带学员完成 </p>
<ol>
<li>第一种方法在添加英雄时，直接添加到链表的尾部 思路分析示意图：</li>
</ol>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107184305.png" alt="image-20210107183257300"></p>
<ol start="2">
<li>第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示) 思路的分析示意图:</li>
</ol>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107184306.png" alt="image-20210107183315923"></p>
<ol start="3">
<li><p>修改节点功能：思路1、先找到该节点，通过遍历 2、 temp.name = newHeroNode.name ; temp.nickname= newHeroNode.nickname</p>
</li>
<li><p>删除节点 思路分析的示意图:</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107184307.png" alt="image-20210107183428446"></p>
</li>
</ol>
<p>HeroNode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-28 19:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 英雄节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 称号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickname=&#x27;&quot;</span> + nickname + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>SingleLinkedList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-28 19:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 单链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建空值的头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleLinkedList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加（创建）</span></span><br><span class="line"><span class="comment">     * 1. 先创建一个head 头节点， 作用就是表示单链表的头</span></span><br><span class="line"><span class="comment">     * 2. 后面我们每添加一个节点，就直接加入到  链表的最后</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先需要创建一个临时节点，需要移动到链表的最后，然后将需要添加的节点链接上</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//如果temp的next不为null的话代表有下一个节点 需要往后移</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出时代表temp的next已经为null了 可以连接上需要添加的node节点了</span></span><br><span class="line">        temp.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要按照编号的顺序添加</span></span><br><span class="line"><span class="comment">     * 1. 首先找到新添加的节点的位置, 是通过辅助变量(指针), 通过遍历来搞定</span></span><br><span class="line"><span class="comment">     * 2. 新的节点.next = temp.next</span></span><br><span class="line"><span class="comment">     * 3. 将temp.next = 新的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrderByNode</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先需要创建一个临时节点，需要移动到链表的最后，然后将需要添加的节点链接上</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//flag代表是否相同 默认为false</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//如果temp的next不为null的话代表有下一个节点 需要往后移</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果下一个节点的no大于新添加的no的话就代表需要插入到当前temp的后一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; node.no) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == node.no) &#123;</span><br><span class="line">                <span class="comment">//如果编号相同则改变flag为true</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前需要插入的节点：&quot;</span> + node + <span class="string">&quot;  编号已存在无法插入！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.next = temp.next;</span><br><span class="line">            temp.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新节点 根据no来更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newHeroNode 需要更新的节点的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//flag标识是否找到 默认为false</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前编号：&quot;</span> + newHeroNode.no + <span class="string">&quot; 未找到！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从单链表中删除一个节点的思路</span></span><br><span class="line"><span class="comment">     * 1.  我们先找到 需要删除的这个节点的前一个节点 temp</span></span><br><span class="line"><span class="comment">     * 2.  temp.next = temp.next.next</span></span><br><span class="line"><span class="comment">     * 3. 被删除的节点，将不会有其它引用指向，会被垃圾回收机制回收</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表是空的！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//在这里temp是在判断的节点前一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">                <span class="comment">//如果匹配到了no就直接退出并将flag标识为true</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找不到编号为：&quot;</span> + no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得链表长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 链表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode crr = head.next;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (crr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            crr = crr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取倒数第index个节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 倒数的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取倒数第index个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLastIndexNode</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断index是否超出链表长度或不合法</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; <span class="keyword">this</span>.getLength()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;index超出链表长度或不合法&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode crr = head.next;</span><br><span class="line">        <span class="comment">//获取倒数第index个可以获取到从第一个节点到第倒数第index个节点需要的次数 链表长度-index = 需要的次数</span></span><br><span class="line">        <span class="comment">//例如：链表长度为4 index = 1 这里i小于3 执行i = 0 1 2三次 crr可以从第一个节点执行到第四个节点 就到达了倒数第一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.getLength() - index; i++) &#123;</span><br><span class="line">            crr = crr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> crr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思路:</span></span><br><span class="line"><span class="comment">     * 1. 先定义一个节点 reverseHead = new HeroNode();</span></span><br><span class="line"><span class="comment">     * 2. 从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端.</span></span><br><span class="line"><span class="comment">     * 3. 原来的链表的head.next = reverseHead.next</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果没有节点或只有一个节点则不需要反转</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//临时节点指向第一个节点</span></span><br><span class="line">        HeroNode crr = head.next;</span><br><span class="line">        <span class="comment">//临时节点的后一个节点</span></span><br><span class="line">        HeroNode next = <span class="keyword">null</span>;</span><br><span class="line">        HeroNode reverseHead = <span class="keyword">new</span> HeroNode();</span><br><span class="line">        <span class="keyword">while</span> (crr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//首先保存crr.next</span></span><br><span class="line">            next = crr.next;</span><br><span class="line">            <span class="comment">//将crr这个节点取出并将crr的next赋值为反转节点的第一个节点</span></span><br><span class="line">            crr.next = reverseHead.next;</span><br><span class="line">            <span class="comment">//将反转节点的第一个节点赋值为刚刚取过来的crr节点</span></span><br><span class="line">            reverseHead.next = crr;</span><br><span class="line">            <span class="comment">//将之前保存的next节点赋值给crr</span></span><br><span class="line">            crr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将head赋值为reverseNode</span></span><br><span class="line">        head = reverseHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 逆序打印思路</span></span><br><span class="line"><span class="comment">     * 1. 上面的题的要求就是逆序打印单链表.</span></span><br><span class="line"><span class="comment">     * 2. 方式1： 先将单链表进行反转操作，然后再遍历即可，这样的做的问题是会破坏原来的单链表的结构，不建议</span></span><br><span class="line"><span class="comment">     * 3. 方式2：可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果.</span></span><br><span class="line"><span class="comment">     * 举例演示栈的使用 Stack</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表是空的！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建临时节点</span></span><br><span class="line">        HeroNode crr = head.next;</span><br><span class="line">        Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (crr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//进行压栈操作</span></span><br><span class="line">            stack.push(crr);</span><br><span class="line">            crr = crr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并两个有序的链表 合并后仍然有序</span></span><br><span class="line"><span class="comment">     * 1.新建一个头结点 存放合并后的链表</span></span><br><span class="line"><span class="comment">     * 2.判断第一个链表的节点和第二个链表的节点 哪个小就从哪个取出节点放入新头结点</span></span><br><span class="line"><span class="comment">     * 3.返回新头结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 链表1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 链表2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">mergeList</span><span class="params">(HeroNode head1, HeroNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head1.next == <span class="keyword">null</span> &amp;&amp; head2.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;两个链表都为空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head1.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果第一个链表为空则直接返回第二个链表</span></span><br><span class="line">            <span class="keyword">return</span> head2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head2.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head1;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode head = <span class="keyword">new</span> HeroNode();</span><br><span class="line">        <span class="comment">//临时节点0 head的临时节点</span></span><br><span class="line">        HeroNode crr0 = head;</span><br><span class="line">        <span class="comment">//临时节点一</span></span><br><span class="line">        HeroNode crr1 = head1.next;</span><br><span class="line">        <span class="comment">//next节点一</span></span><br><span class="line">        HeroNode next1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//临时节点二</span></span><br><span class="line">        HeroNode crr2 = head2.next;</span><br><span class="line">        <span class="comment">//next节点二</span></span><br><span class="line">        HeroNode next2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//只要有一个链表到了null就代表没有节点了 则直接将另一个链表的剩余节点赋值给头结点</span></span><br><span class="line">        <span class="keyword">while</span> (crr1 != <span class="keyword">null</span> &amp;&amp; crr2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (crr1.no &lt; crr2.no) &#123;</span><br><span class="line">                <span class="comment">//将crr1的节点赋值给新链表</span></span><br><span class="line">                crr0.next = crr1;</span><br><span class="line">                <span class="comment">//将crr1后移</span></span><br><span class="line">                crr1 = crr1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//将crr2的节点赋值给新链表</span></span><br><span class="line">                crr0.next = crr2;</span><br><span class="line">                <span class="comment">//将crr2后移</span></span><br><span class="line">                crr2 = crr2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//crr0往后移</span></span><br><span class="line">            crr0 = crr0.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(crr1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            crr0.next = crr2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(crr2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            crr0.next = crr1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历：</span></span><br><span class="line"><span class="comment">     * 1.  通过一个辅助变量遍历，帮助遍历整个链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先需要创建一个临时节点,来遍历整个链表</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//如果temp的next不为null的话代表有下一个节点可以往后移之后输出数据</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="comment">//输出当前节点</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SingleLinkedListDemo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-28 19:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//进行测试</span></span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        HeroNode hero1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode hero2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode hero3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode hero4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建要给链表</span></span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入</span></span><br><span class="line"><span class="comment">//        singleLinkedList.addNode(hero1);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.addNode(hero4);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.addNode(hero2);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.addNode(hero3);</span></span><br><span class="line">        <span class="comment">//加入</span></span><br><span class="line">        singleLinkedList.addOrderByNode(hero1);</span><br><span class="line">        singleLinkedList.addOrderByNode(hero4);</span><br><span class="line">        singleLinkedList.addOrderByNode(hero2);</span><br><span class="line">        singleLinkedList.addOrderByNode(hero3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HeroNode newHeroNode = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;宋江update&quot;</span>, <span class="string">&quot;及时雨update&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出原链表</span></span><br><span class="line">        singleLinkedList.showList();</span><br><span class="line"></span><br><span class="line">        singleLinkedList.update(newHeroNode);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;update=====================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出更新后链表</span></span><br><span class="line">        singleLinkedList.showList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除节点</span></span><br><span class="line">        singleLinkedList.del(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;delete=====================================================&quot;</span>);</span><br><span class="line">        singleLinkedList.showList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试获取链表长度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;length=====================================================&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前链表长度为：&quot;</span> + singleLinkedList.getLength());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试获得倒数第index个节点</span></span><br><span class="line">        System.out.println(<span class="string">&quot;lastIndex=====================================================&quot;</span>);</span><br><span class="line">        System.out.println(singleLinkedList.getLastIndexNode(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;reverseList=====================================================&quot;</span>);</span><br><span class="line">        singleLinkedList.reverseList();</span><br><span class="line">        singleLinkedList.showList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试逆序输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;reversePrint=====================================================&quot;</span>);</span><br><span class="line">        singleLinkedList.reversePrint();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试合并两个有序的链表</span></span><br><span class="line">        SingleLinkedList list1 = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HeroNode hero5 = <span class="keyword">new</span> HeroNode(<span class="number">5</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode hero10 = <span class="keyword">new</span> HeroNode(<span class="number">10</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode hero8 = <span class="keyword">new</span> HeroNode(<span class="number">8</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode hero7 = <span class="keyword">new</span> HeroNode(<span class="number">7</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list1.addOrderByNode(hero5);</span><br><span class="line">        list1.addOrderByNode(hero10);</span><br><span class="line">        list1.addOrderByNode(hero8);</span><br><span class="line">        list1.addOrderByNode(hero7);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;list1=====================================================&quot;</span>);</span><br><span class="line">        list1.showList();</span><br><span class="line"></span><br><span class="line">        SingleLinkedList list2 = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HeroNode hero1t = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;sb&quot;</span>, <span class="string">&quot;zxc&quot;</span>);</span><br><span class="line">        HeroNode hero8t = <span class="keyword">new</span> HeroNode(<span class="number">8</span>, <span class="string">&quot;zxc&quot;</span>, <span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        HeroNode hero5t = <span class="keyword">new</span> HeroNode(<span class="number">5</span>, <span class="string">&quot;asd&quot;</span>, <span class="string">&quot;asd&quot;</span>);</span><br><span class="line">        HeroNode hero28 = <span class="keyword">new</span> HeroNode(<span class="number">28</span>, <span class="string">&quot;avv&quot;</span>, <span class="string">&quot;qwe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list2.addOrderByNode(hero1t);</span><br><span class="line">        list2.addOrderByNode(hero8t);</span><br><span class="line">        list2.addOrderByNode(hero5t);</span><br><span class="line">        list2.addOrderByNode(hero28);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;list2=====================================================&quot;</span>);</span><br><span class="line">        list2.showList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        System.out.println(<span class="string">&quot;mergeList=====================================================&quot;</span>);</span><br><span class="line">        HeroNode head = SingleLinkedList.mergeList(list1.getHead(), list2.getHead());</span><br><span class="line">        SingleLinkedList mergeList = <span class="keyword">new</span> SingleLinkedList(head);</span><br><span class="line">        mergeList.showList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3双向链表应用实例"><a href="#1-3双向链表应用实例" class="headerlink" title="1.3双向链表应用实例"></a>1.3双向链表应用实例</h3><p>管理单向链表的缺点分析</p>
<ol>
<li><p>单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。</p>
</li>
<li><p>单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除 时节点，总是找到 temp,temp 是待删除节点的前一个节点(认真体会). </p>
</li>
<li><p>分析了双向链表如何完成遍历，添加，修改和删除的思路<img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107184308.png" alt="image-20210107183643754"></p>
</li>
</ol>
<p>对上图的说明: 分析 双向链表的遍历，添加，修改，删除的操作思路===》代码实现</p>
<ol>
<li><p>遍历 方和 单链表一样，只是可以向前，也可以向后查找 </p>
</li>
<li><p>添加 (默认添加到双向链表的最后) </p>
</li>
</ol>
<p>(1) 先找到双向链表的最后这个节点 </p>
<p>(2) temp.next = newHeroNode </p>
<p>(3) newHeroNode.pre = temp; </p>
<ol start="3">
<li><p>修改 思路和 原来的单向链表一样. </p>
</li>
<li><p>删除</p>
</li>
</ol>
<p>(1) 因为是双向链表，因此，我们可以实现自我删除某个节点</p>
<p>(2) 直接找到要删除的这个节点，比如 temp </p>
<p>(3) temp.pre.next = temp.next </p>
<p>(4) temp.next.pre = temp.pre;</p>
<p>双向链表的实现</p>
<p>HeroNode2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-29 9:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroNode2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 称号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  指向前一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 pre;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode2</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickname=&#x27;&quot;</span> + nickname + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>DoubleLinkedList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-29 9:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 双向链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建空值的头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode2 head = <span class="keyword">new</span> HeroNode2();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode2 <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(HeroNode2 head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleLinkedList</span><span class="params">(HeroNode2 head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加（创建）</span></span><br><span class="line"><span class="comment">     * 1. 先创建一个head 头节点， 作用就是表示单链表的头</span></span><br><span class="line"><span class="comment">     * 2. 后面我们每添加一个节点，就直接加入到  链表的最后</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(HeroNode2 node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先需要创建一个临时节点，需要移动到链表的最后，然后将需要添加的节点链接上</span></span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="comment">//如果temp的next不为null的话代表有下一个节点 需要往后移</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出时代表temp的next已经为null了 可以连接上需要添加的node节点了</span></span><br><span class="line">        temp.next = node;</span><br><span class="line">        <span class="comment">//设置前一个节点</span></span><br><span class="line">        node.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按顺序添加（创建）</span></span><br><span class="line"><span class="comment">     * 1. 先创建一个head 头节点， 作用就是表示单链表的头</span></span><br><span class="line"><span class="comment">     * 2. 后面我们每添加一个节点，就直接加入到  链表的最后</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrderByNode</span><span class="params">(HeroNode2 node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先需要创建一个临时节点，需要移动</span></span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="comment">//如果temp的next不为null的话代表有下一个节点 需要往后移</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//比较temp的后一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next.no &gt; node.no) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出时代表temp已到达需要插入的节点的位置的</span></span><br><span class="line">        <span class="comment">//插入节点的下一个节点为temp的下一个节点</span></span><br><span class="line">        node.next = temp.next;</span><br><span class="line">        <span class="comment">//将temp的下一个节点更改为新插入的节点</span></span><br><span class="line">        temp.next = node;</span><br><span class="line">        <span class="comment">//设置插入节点的上一个节点</span></span><br><span class="line">        node.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新节点 根据no来更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newHeroNode2 需要更新的节点的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode2 newHeroNode2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="comment">//flag标识是否找到 默认为false</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode2.no) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode2.name;</span><br><span class="line">            temp.nickname = newHeroNode2.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前编号：&quot;</span> + newHeroNode2.no + <span class="string">&quot; 未找到！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表是空的！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//在这里temp是在判断的节点前一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (temp.no == no) &#123;</span><br><span class="line">                <span class="comment">//如果匹配到了no就直接退出并将flag标识为true</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找不到编号为：&quot;</span> + no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历：</span></span><br><span class="line"><span class="comment">     * 1.  通过一个辅助变量遍历，帮助遍历整个链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先需要创建一个临时节点,来遍历整个链表</span></span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="comment">//如果temp的next不为null的话代表有下一个节点可以往后移之后输出数据</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="comment">//输出当前节点</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DoubleLinkedListDemo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.linkedlist;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-29 9:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;双向链表的测试&quot;</span>);</span><br><span class="line">        <span class="comment">// 先创建节点</span></span><br><span class="line">        HeroNode2 hero1 = <span class="keyword">new</span> HeroNode2(<span class="number">5</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode2 hero2 = <span class="keyword">new</span> HeroNode2(<span class="number">1</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode2 hero3 = <span class="keyword">new</span> HeroNode2(<span class="number">2</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode2 hero4 = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一个双向链表</span></span><br><span class="line">        DoubleLinkedList doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line">        doubleLinkedList.addOrderByNode(hero1);</span><br><span class="line">        doubleLinkedList.addOrderByNode(hero2);</span><br><span class="line">        doubleLinkedList.addOrderByNode(hero3);</span><br><span class="line">        doubleLinkedList.addOrderByNode(hero4);</span><br><span class="line"></span><br><span class="line">        doubleLinkedList.showList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改</span></span><br><span class="line">        HeroNode2 newHeroNode = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">&quot;公孙胜&quot;</span>, <span class="string">&quot;入云龙&quot;</span>);</span><br><span class="line">        doubleLinkedList.update(newHeroNode);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的链表情况&quot;</span>);</span><br><span class="line">        doubleLinkedList.showList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        doubleLinkedList.del(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后的链表情况~~&quot;</span>);</span><br><span class="line">        doubleLinkedList.showList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4单向环形链表应用场景"><a href="#1-4单向环形链表应用场景" class="headerlink" title="1.4单向环形链表应用场景"></a>1.4单向环形链表应用场景</h3><p>Josephu(约瑟夫、约瑟夫环) 问题 </p>
<p>Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从 1 开始报数，数 到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由 此产生一个出队编号的序列。</p>
<p>提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结 点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直 到最后一个结点从链表中删除算法结束。</p>
<h3 id="1-5单向环形链表介绍"><a href="#1-5单向环形链表介绍" class="headerlink" title="1.5单向环形链表介绍"></a>1.5单向环形链表介绍</h3><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107184309.png" alt="image-20210107183902646"></p>
<h3 id="1-6Josephu-问题"><a href="#1-6Josephu-问题" class="headerlink" title="1.6Josephu 问题"></a>1.6Josephu 问题</h3><p>约瑟夫问题的示意图:</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107184310.png" alt="image-20210107183921652"></p>
<h4 id="1-6-1Josephu-问题"><a href="#1-6-1Josephu-问题" class="headerlink" title="1.6.1Josephu 问题"></a>1.6.1Josephu 问题</h4><p>Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此 产生一个出队编号的序列。</p>
<h4 id="1-6-2提示"><a href="#1-6-2提示" class="headerlink" title="1.6.2提示"></a>1.6.2提示</h4><p>用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开 始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个 尚硅谷 Java 数据结构和算法 更多 Java –大数据 –前端 –python 人工智能 -区块链资料下载，可访问百度：尚硅谷官网 第 55页 结点从链表中删除算法结束。</p>
<h4 id="1-6-3约瑟夫问题-创建环形链表的思路图解"><a href="#1-6-3约瑟夫问题-创建环形链表的思路图解" class="headerlink" title="1.6.3约瑟夫问题-创建环形链表的思路图解"></a>1.6.3约瑟夫问题-创建环形链表的思路图解</h4><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107184311.png" alt="image-20210107184021342"></p>
<h4 id="1-6-4约瑟夫问题-小孩出圈的思路分析图"><a href="#1-6-4约瑟夫问题-小孩出圈的思路分析图" class="headerlink" title="1.6.4约瑟夫问题-小孩出圈的思路分析图"></a>1.6.4约瑟夫问题-小孩出圈的思路分析图</h4><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107184312.png" alt="image-20210107184035914"></p>
<p>代码实现：</p>
<p>创建环形链表</p>
<p>CircleSingleLinkedList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-29 10:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一个节点</span></span><br><span class="line">    <span class="keyword">private</span> Boy first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个大小为num的单向环形链表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 单向环形链表的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;num值不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Boy cur = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            Boy node = <span class="keyword">new</span> Boy(i);</span><br><span class="line">            <span class="comment">//第一个节点创建需要特殊处理</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//第一个节点</span></span><br><span class="line">                first = node;</span><br><span class="line">                <span class="comment">//构成一个环形链表 使自己指向自己</span></span><br><span class="line">                first.next = first;</span><br><span class="line">                <span class="comment">//将辅助指针cur指向first</span></span><br><span class="line">                cur = first;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//另外的节点则使用cur来连接新节点</span></span><br><span class="line">                cur.next = node;</span><br><span class="line">                <span class="comment">//使新添加的节点的next赋值为第一个节点first</span></span><br><span class="line">                node.next = first;</span><br><span class="line">                <span class="comment">//将新添加的节点赋值给cur</span></span><br><span class="line">                cur = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Boy cur = first;</span><br><span class="line">        <span class="comment">//循环遍历  判断是否遍历完的条件是 cur的下一个节点是否是第一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(cur);</span><br><span class="line">            <span class="keyword">if</span> (cur.next == first) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNo  表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> countNum 表示数几下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums     表示最初有多少小孩在圈中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">joseph</span><span class="params">(<span class="keyword">int</span> startNo, <span class="keyword">int</span> countNum, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先对数据进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;参数输入有误， 请重新输入&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建节点</span></span><br><span class="line">        <span class="keyword">this</span>.add(nums);</span><br><span class="line">        <span class="comment">//创建辅助节点 跟在first节点的后面</span></span><br><span class="line">        Boy helper = first;</span><br><span class="line">        <span class="comment">//将helper移动到最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (helper.next != first) &#123;</span><br><span class="line">            helper = helper.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据startNo开始数 所以first和helper需要同时移动startNo-1次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startNo - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            helper = helper.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当first == helper时代表此时循环单链表中只剩下一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(first != helper) &#123;</span><br><span class="line">            <span class="comment">//根据需要叫的次数来移动次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;countNum ; i++) &#123;</span><br><span class="line">                first = first.next;</span><br><span class="line">                helper = helper.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//移动完后可以进行出圈操作</span></span><br><span class="line">            System.out.println(first + <span class="string">&quot;出圈&quot;</span>);</span><br><span class="line">            <span class="comment">//等价于删除操作</span></span><br><span class="line">            first = first.next;</span><br><span class="line">            helper.next = first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时只剩下最后一个节点 将它输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最后一个节点&quot;</span> + first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JosephDemo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-29 10:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JosephDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  创建循环单链表操作</span></span><br><span class="line"><span class="comment">//        CircleSingleLinkedList list = new CircleSingleLinkedList();</span></span><br><span class="line"><span class="comment">//        list.add(25);</span></span><br><span class="line"><span class="comment">//        list.showList();</span></span><br><span class="line">        CircleSingleLinkedList list = <span class="keyword">new</span> CircleSingleLinkedList();</span><br><span class="line">        list.joseph(<span class="number">10</span>,<span class="number">20</span>,<span class="number">125</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
        <category>LinkedList</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka学习笔记</title>
    <url>/2021/08/02/kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Kafka学习笔记"><a href="#Kafka学习笔记" class="headerlink" title="Kafka学习笔记"></a>Kafka学习笔记</h2><h3 id="下载kafka"><a href="#下载kafka" class="headerlink" title="下载kafka"></a>下载kafka</h3><p>到官网kafka.apache.org下载kafka压缩包</p>
<h3 id="安装kafka"><a href="#安装kafka" class="headerlink" title="安装kafka"></a>安装kafka</h3><p>解压kafka并更改配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">broker.id</span>=<span class="string">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://localhost:9092</span></span><br><span class="line"></span><br><span class="line"><span class="meta">num.network.threads</span>=<span class="string">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">num.io.threads</span>=<span class="string">8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">socket.send.buffer.bytes</span>=<span class="string">102400</span></span><br><span class="line"></span><br><span class="line"><span class="meta">socket.receive.buffer.bytes</span>=<span class="string">102400</span></span><br><span class="line"></span><br><span class="line"><span class="meta">socket.request.max.bytes</span>=<span class="string">104857600</span></span><br><span class="line"><span class="comment"># 消息存储的位置</span></span><br><span class="line"><span class="meta">log.dirs</span>=<span class="string">/Users/wsy/tools/kafka/kafka/kafka-logs-9092</span></span><br><span class="line"></span><br><span class="line"><span class="meta">num.partitions</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">num.recovery.threads.per.data.dir</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">offsets.topic.replication.factor</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">transaction.state.log.replication.factor</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">transaction.state.log.min.isr</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消息存储的时间</span></span><br><span class="line"><span class="meta">log.retention.hours</span>=<span class="string">168</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log.segment.bytes</span>=<span class="string">1073741824</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log.retention.check.interval.ms</span>=<span class="string">300000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">zookeeper.connect</span>=<span class="string">localhost:2181</span></span><br><span class="line"></span><br><span class="line"><span class="meta">zookeeper.connection.timeout.ms</span>=<span class="string">18000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">group.initial.rebalance.delay.ms</span>=<span class="string">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="kafka基础架构"><a href="#kafka基础架构" class="headerlink" title="kafka基础架构"></a>kafka基础架构</h3><p><img src="https://gitee.com/Pink_oops/image/raw/master/20210801095718.png" alt="image-20210801095712606"></p>
<ol>
<li>Producer :消息生产者，就是向 kafka broker 发消息的客户端;</li>
<li>Consumer :消息消费者，向 kafka broker 取消息的客户端;</li>
<li>Consumer Group (CG):消费者组，由多个 consumer 组成。消费者组内每个消费者负 责消费不同分区的数据，一个分区只能由一个组内消费者消费;消费者组之间互不影响。所 有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</li>
<li>Broker :一台 kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic。</li>
<li>Topic :可以理解为一个队列，生产者和消费者面向的都是一个 topic; </li>
<li>Partition:为了实现扩展性，一个非常大的 topic 可以分布到多个 broker(即服务器)上， 一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列; </li>
<li>Replica:副本，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 kafka 仍然能够继续工作，kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本， 一个 leader 和若干个 follower。</li>
<li>leader:每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对 象都是 leader。</li>
<li>follower:每个分区多个副本中的“从”，实时从 leader 中同步数据，保持和 leader 数据 的同步。leader 发生故障时，某个 follower 会成为新的 follower。</li>
</ol>
<h3 id="编写集群启动脚本"><a href="#编写集群启动脚本" class="headerlink" title="编写集群启动脚本"></a>编写集群启动脚本</h3><blockquote>
<p>注意：启动kafka需要提前开启zookeeper，如果kafka启动失败的话可以进入到logs目录下查看server.log文件</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line"><span class="string">&quot;start&quot;</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> 9092 9093 9094</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;************<span class="variable">$i</span>*************&quot;</span></span><br><span class="line">		/Users/wsy/tools/kafka/kafka/bin/kafka-server-start.sh -daemon /Users/wsy/tools/kafka/kafka/config/server<span class="variable">$i</span>.properties</span><br><span class="line">	<span class="keyword">done</span></span><br><span class="line">&#125;;;</span><br><span class="line"><span class="string">&quot;start&quot;</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> 9092 9093 9094</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;************<span class="variable">$i</span>*************&quot;</span></span><br><span class="line">		/Users/wsy/tools/kafka/kafka/bin/kafka-stop.sh /Users/wsy/tools/kafka/kafka/config/server<span class="variable">$i</span>.properties</span><br><span class="line">	<span class="keyword">done</span></span><br><span class="line">&#125;;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<h3 id="Kafka-命令行操作"><a href="#Kafka-命令行操作" class="headerlink" title="Kafka 命令行操作"></a>Kafka 命令行操作</h3><ol>
<li><p>查看当前服务器中的所有 topic</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper localhost:2181 --list</span><br></pre></td></tr></table></figure></li>
<li><p>创建 topic</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper hadoop102:2181 --create --replication-factor 3 --partitions 1 -- topic first</span><br></pre></td></tr></table></figure>
<blockquote>
<p>选项说明:<br> –topic 定义 topic 名 </p>
<p>–replication-factor 定义副本数 </p>
<p>–partitions 定义分区数</p>
</blockquote>
</li>
<li><p>删除 topic</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper hadoop102:2181 --delete --topic first</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要 server.properties 中设置 delete.topic.enable=true 否则只是标记删除。</p>
</blockquote>
</li>
<li><p>发送消息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker- list hadoop102:9092 --topic first</span><br><span class="line">&gt;hello world</span><br><span class="line">&gt;wsy</span><br></pre></td></tr></table></figure></li>
<li><p>消费消息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh \ --bootstrap-server hadoop102:9092 --topic first</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh \ --bootstrap-server hadoop102:9092 --from-beginning --topic first</span><br></pre></td></tr></table></figure>
<blockquote>
<p>–from-beginning:会把主题中以往所有的数据都读取出来。</p>
</blockquote>
</li>
<li><p>查看某个 Topic 的详情</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper hadoop102:2181 --describe --topic first</span><br></pre></td></tr></table></figure></li>
<li><p>修改分区数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper hadoop102:2181 --alter --topic first --partitions 6</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="Kafka架构深入"><a href="#Kafka架构深入" class="headerlink" title="Kafka架构深入"></a>Kafka架构深入</h3><h4 id="Kafka-工作流程及文件存储机制"><a href="#Kafka-工作流程及文件存储机制" class="headerlink" title="Kafka 工作流程及文件存储机制"></a>Kafka 工作流程及文件存储机制</h4><h5 id="Kafka-工作流程"><a href="#Kafka-工作流程" class="headerlink" title="Kafka 工作流程"></a>Kafka 工作流程</h5><p><img src="https://gitee.com/Pink_oops/image/raw/master/20210801110823.png" alt="image-20210801110823204"></p>
<p>Kafka 中消息是以 topic 进行分类的，生产者生产消息，消费者消费消息，都是面向 topic 的。</p>
<p>topic 是逻辑上的概念，而 partition 是物理上的概念，每个 partition 对应于一个 log 文 件，该 log 文件中存储的就是 producer 生产的数据。Producer 生产的数据会被不断追加到该 log 文件末端，且每条数据都有自己的 offset。消费者组中的每个消费者，都会实时记录自己 消费到了哪个 offset，以便出错恢复时，从上次的位置继续消费。</p>
<h5 id="Kafka文件存储机制"><a href="#Kafka文件存储机制" class="headerlink" title="Kafka文件存储机制"></a>Kafka文件存储机制</h5><p><img src="https://gitee.com/Pink_oops/image/raw/master/20210801110938.png" alt="image-20210801110938400"></p>
<p>由于生产者生产的消息会不断追加到 log 文件末尾，为防止 log 文件过大导致数据定位 效率低下，Kafka 采取了分片和索引机制，将每个 partition 分为多个 segment。每个 segment 对应两个文件——“.index”文件和“.log”文件。这些文件位于一个文件夹下，该文件夹的命名 规则为:topic 名称+分区序号。例如，first 这个 topic 有三个分区，则其对应的文件夹为 first- 0,first-1,first-2。</p>
<blockquote>
<p>00000000000000000000.index </p>
<p>00000000000000000000.log </p>
<p>00000000000000170410.index </p>
<p>00000000000000170410.log </p>
<p>00000000000000239430.index </p>
<p>00000000000000239430.log</p>
</blockquote>
<p>index 和 log 文件以当前 segment 的第一条消息的 offset 命名。下图为 index 文件和 log 文件的结构示意图。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210801111017.png" alt="image-20210801111017546"></p>
<p>“.index”文件存储大量的索引信息，“.log”文件存储大量的数据，索引文件中的元 数据指向对应数据文件中 message 的物理偏移地址。</p>
<h4 id="Kafka-生产者"><a href="#Kafka-生产者" class="headerlink" title="Kafka 生产者"></a>Kafka 生产者</h4><h5 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h5><ol>
<li><p>分区的原因</p>
<ol>
<li><p>方便在集群中扩展，每个 Partition 可以通过调整以适应它所在的机器，而一个 topic</p>
<p>又可以有多个 Partition 组成，因此整个集群就可以适应任意大小的数据了;</p>
</li>
<li><p>可以提高并发，因为可以以 Partition 为单位读写了。</p>
</li>
</ol>
</li>
<li><p>分区的原则</p>
<p>我们需要将 producer 发送的数据封装成一个 ProducerRecord 对象。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210801111202.png" alt="image-20210801111202210"></p>
<ol>
<li>指明 partition 的情况下，直接将指明的值直接作为 partiton 值;</li>
<li>没有指明 partition 值但有 key 的情况下，将 key 的 hash 值与 topic 的 partition 数进行取余得到 partition 值;</li>
<li>既没有 partition 值又没有 key 值的情况下，第一次调用时随机生成一个整数(后 面每次调用在这个整数上自增)，将这个值与 topic 可用的 partition 总数取余得到 partition 值，也就是常说的 round-robin 算法。</li>
</ol>
</li>
</ol>
<h5 id="数据可靠性保证"><a href="#数据可靠性保证" class="headerlink" title="数据可靠性保证"></a>数据可靠性保证</h5><p>为保证 producer 发送的数据，能可靠的发送到指定的 topic，topic 的每个 partition 收到 producer 发送的数据后，都需要向 producer 发送 ack(acknowledgement 确认收到)，如果 producer 收到 ack，就会进行下一轮的发送，否则重新发送数据。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210801111253.png" alt="image-20210801111253321"></p>
<ol>
<li><p>副本数据同步策略</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>半数以上完成同步，就发 送 ack</td>
<td>延迟低</td>
<td>选举新的 leader 时，容忍 n 台 节点的故障，需要 2n+1 个副 本</td>
</tr>
<tr>
<td>全部完成同步，才发送</td>
<td>选举新的 leader 时，容忍 n 台 节点的故障，需要 n+1 个副 本</td>
<td>延迟高</td>
</tr>
</tbody></table>
<p>Kafka 选择了第二种方案，原因如下:</p>
<ol>
<li>同样为了容忍 n 台节点的故障，第一种方案需要 2n+1 个副本，而第二种方案只需要 n+1 个副本，而 Kafka 的每个分区都有大量的数据，第一种方案会造成大量数据的冗余。</li>
<li>虽然第二种方案的网络延迟会比较高，但网络延迟对 Kafka 的影响较小。</li>
</ol>
</li>
<li><p>ISR</p>
<p>​    采用第二种方案之后，设想以下情景:leader 收到数据，所有 follower 都开始同步数据， 但有一个 follower，因为某种故障，迟迟不能与 leader 进行同步，那 leader 就要一直等下去， 直到它完成同步，才能发送 ack。这个问题怎么解决呢?</p>
<p>​    Leader 维护了一个动态的 in-sync replica set (ISR)，意为和 leader 保持同步的 follower 集 合。当 ISR 中的 follower 完成数据的同步之后，leader 就会给 follower 发送 ack。如果 follower 长时间未向 leader 同步数据，则该 follower 将被踢出 ISR，该时间阈值由replica.lag.time.max.ms 参数设定。Leader 发生故障之后，就会从 ISR 中选举新的 leader。</p>
</li>
<li><p>ack 应答机制</p>
<p>对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失， 所以没必要等 ISR 中的 follower 全部接收成功。</p>
<p>所以 Kafka 为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡， 选择以下的配置。</p>
<p><strong>acks 参数配置: acks:</strong></p>
<p>​    0:producer 不等待 broker 的 ack，这一操作提供了一个最低的延迟，broker 一接收到还 没有写入磁盘就已经返回，当 broker 故障时有可能丢失数据;</p>
<p>​    1:producer 等待 broker 的 ack，partition 的 leader 落盘成功后返回 ack，如果在 follower 同步成功之前 leader 故障，那么将会丢失数据;</p>
<p>​    acks = 1 数据丢失案例</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210801111532.png" alt="image-20210801111532487"></p>
<p>​    -1(all):producer 等待 broker 的 ack，partition 的 leader 和 follower 全部落盘成功后才 返回 ack。但是如果在 follower 同步完成后，broker 发送 ack 之前，leader 发生故障，那么会 造成数据重复。</p>
<p>acks = -1 数据重复案例</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210801111623.png" alt="image-20210801111623631"></p>
</li>
</ol>
<p>故障处理细节</p>
<p>Log文件中的HW和LEO</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210801111700.png" alt="image-20210801111700846"></p>
<p><strong>LEO:指的是每个副本最大的 offset;</strong> </p>
<p><strong>HW:指的是消费者能见到的最大的 offset，ISR 队列中最小的 LEO。</strong></p>
<ol>
<li><p>follower 故障</p>
<p>follower 发生故障后会被临时踢出 ISR，待该 follower 恢复后，follower 会读取本地磁盘 记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。 等该 follower 的 LEO 大于等于该 Partition 的 HW，即 follower 追上 leader 之后，就可以重 新加入 ISR 了。</p>
</li>
<li><p>leader 故障</p>
<p>leader 发生故障之后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的数据一致性，其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader 同步数据。</p>
<p><strong>注意:这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</strong></p>
</li>
</ol>
<h5 id="Exactly-Once-语义"><a href="#Exactly-Once-语义" class="headerlink" title="Exactly Once 语义"></a>Exactly Once 语义</h5><p>​    将服务器的 ACK 级别设置为-1，可以保证 Producer 到 Server 之间不会丢失数据，即 At Least Once 语义。相对的，将服务器 ACK 级别设置为 0，可以保证生产者每条消息只会被 发送一次，即 At Most Once 语义。</p>
<p>​    At Least Once 可以保证数据不丢失，但是不能保证数据不重复;相对的，At Least Once 可以保证数据不重复，但是不能保证数据不丢失。但是，对于一些非常重要的信息，比如说 交易数据，下游数据消费者要求数据既不重复也不丢失，即 Exactly Once 语义。在 0.11 版 本以前的 Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局 去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。</p>
<p>​    0.11 版本的 Kafka，引入了一项重大特性:幂等性。所谓的幂等性就是指 Producer 不论 向 Server 发送多少次重复数据，Server 端都只会持久化一条。幂等性结合 At Least Once 语 义，就构成了 Kafka 的 Exactly Once 语义。即:</p>
<p>​                                        <strong>At Least Once + 幂等性 = Exactly Once</strong></p>
<p>​    要启用幂等性，只需要将 Producer 的参数中 enable.idompotence 设置为 true 即可。Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的 Producer 在 初始化的时候会被分配一个 PID，发往同一 Partition 的消息会附带 Sequence Number。而 Broker 端会对&lt;PID, Partition, SeqNumber&gt;做缓存，当具有相同主键的消息提交时，Broker 只 会持久化一条。</p>
<p>​    但是 PID 重启就会变化，同时不同的 Partition 也具有不同主键，所以幂等性无法保证跨 分区跨会话的 Exactly Once。</p>
<h4 id="Kafka-消费者"><a href="#Kafka-消费者" class="headerlink" title="Kafka 消费者"></a>Kafka 消费者</h4><h5 id="消费方式"><a href="#消费方式" class="headerlink" title="消费方式"></a>消费方式</h5><p><strong>consumer 采用 pull(拉)模式从 broker 中读取数据。</strong></p>
<p><strong>push(推)模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的。</strong></p>
<p>它的目标是尽可能以最快速度传递消息，但是这样很容易造成 consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而 pull 模式则可以根据 consumer 的消费能力以适 当的速率消费消息。</p>
<p>pull 模式不足之处是，如果 kafka 没有数据，消费者可能会陷入循环中，一直返回空数据。针对这一点，Kafka 的消费者在消费数据时会传入一个时长参数 timeout，如果当前没有 数据可供消费，consumer 会等待一段时间之后再返回，这段时长即为 timeout。</p>
<h5 id="分区分配策略"><a href="#分区分配策略" class="headerlink" title="分区分配策略"></a>分区分配策略</h5><p>一个 consumer group 中有多个 consumer，一个 topic 有多个 partition，所以必然会涉及 到 partition 的分配问题，即确定那个 partition 由哪个 consumer 来消费。</p>
<p>Kafka 有两种分配策略，一是 RoundRobin，一是 Range。</p>
<ol>
<li><p>RoundRobin</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210801142407.png" alt="image-20210801142212820"></p>
</li>
<li><p>Range</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210801142407.png" alt="image-20210801142358087"></p>
</li>
</ol>
<h5 id="offset-的维护"><a href="#offset-的维护" class="headerlink" title="offset 的维护"></a>offset 的维护</h5><p>由于 consumer 在消费过程中可能会出现断电宕机等故障，consumer 恢复后，需要从故 障前的位置的继续消费，所以 consumer 需要实时记录自己消费到了哪个 offset，以便故障恢 复后继续消费。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210802104401.png" alt="image-20210802104401038"></p>
<p>Kafka 0.9 版本之前，consumer 默认将 offset 保存在 Zookeeper 中，从 0.9 版本开始， consumer 默认将 offset 保存在 Kafka 一个内置的 topic 中，该 topic 为__consumer_offsets。</p>
<ol>
<li><p>修改配置文件 consumer.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">exclude.internal.topics</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure></li>
<li><p>读取 offset</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --topic __consumer_offsets -- zookeeper localhost:2181 --formatter <span class="string">&quot;kafka.coordinator.group.GroupMetadataManager\$OffsetsMessageForm atter&quot;</span> --consumer.config config/consumer.properties --from- beginning</span><br></pre></td></tr></table></figure>
<h4 id="Kafka-高效读写数据"><a href="#Kafka-高效读写数据" class="headerlink" title="Kafka 高效读写数据"></a>Kafka 高效读写数据</h4></li>
<li><p>顺序写磁盘</p>
<p>Kafka 的 producer 生产数据，要写入到 log 文件中，写的过程是一直追加到文件末端， 为顺序写。官网有数据表明，同样的磁盘，顺序写能到 600M/s，而随机写只有 100K/s。这</p>
<p>与磁盘的机械机构有关，顺序写之所以快，是因为其省去了大量磁头寻址的时间。</p>
</li>
<li><p>零复制技术</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210802104549.png" alt="image-20210802104549625"></p>
</li>
</ol>
<h4 id="Zookeeper-在-Kafka-中的作用"><a href="#Zookeeper-在-Kafka-中的作用" class="headerlink" title="Zookeeper 在 Kafka 中的作用"></a>Zookeeper 在 Kafka 中的作用</h4><p>​    Kafka 集群中有一个 broker 会被选举为 Controller，负责管理集群 broker 的上下线，所 有 topic 的分区副本分配和 leader 选举等工作。</p>
<p>​    Controller 的管理工作都是依赖于 Zookeeper 的。</p>
<p>​    以下为 partition 的 leader 选举过程:</p>
<p>​    <img src="https://gitee.com/Pink_oops/image/raw/master/20210802104627.png" alt="image-20210802104627528"></p>
<h4 id="Kafka-事务"><a href="#Kafka-事务" class="headerlink" title="Kafka 事务"></a>Kafka 事务</h4><p>​    Kafka 从 0.11 版本开始引入了事务支持。事务可以保证 Kafka 在 Exactly Once 语义的基 础上，生产和消费可以跨分区和会话，要么全部成功，要么全部失败。</p>
<h5 id="Producer-事务"><a href="#Producer-事务" class="headerlink" title="Producer 事务"></a>Producer 事务</h5><p>​        为了实现跨分区跨会话的事务，需要引入一个全局唯一的 Transaction ID，并将 Producer 获得的 PID 和 Transaction ID 绑定。这样当 Producer 重启后就可以通过正在进行的 Transaction ID 获得原来的 PID。</p>
<p>​        为了管理 Transaction，Kafka 引入了一个新的组件 Transaction Coordinator。Producer 就 是通过和 Transaction Coordinator 交互获得 Transaction ID 对应的任务状态。Transaction Coordinator 还负责将事务所有写入 Kafka 的一个内部 Topic，这样即使整个服务重启，由于 事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。</p>
<h5 id="Consumer-事务"><a href="#Consumer-事务" class="headerlink" title="Consumer 事务"></a>Consumer 事务</h5><p>​        上述事务机制主要是从 Producer 方面考虑，对于 Consumer 而言，事务的保证就会相对较弱，尤其时无法保证 Commit 的信息被精确消费。这是由于 Consumer 可以通过 offset 访 问任意信息，而且不同的 Segment File 生命周期不同，同一事务的消息可能会出现重启后被删除的情况。</p>
<h3 id="Kafka-API"><a href="#Kafka-API" class="headerlink" title="Kafka API"></a>Kafka API</h3><h4 id="Producer-API"><a href="#Producer-API" class="headerlink" title="Producer API"></a>Producer API</h4><h5 id="消息发送流程"><a href="#消息发送流程" class="headerlink" title="消息发送流程"></a>消息发送流程</h5><p>​        Kafka 的 Producer 发送消息采用的是异步发送的方式。在消息发送的过程中，涉及到了 两个线程——main 线程和 Sender 线程，以及一个线程共享变量——RecordAccumulator。 main 线程将消息发送给 RecordAccumulator，Sender 线程不断从 RecordAccumulator 中拉取 消息发送到 Kafka broker。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210802104855.png" alt="image-20210802104855043"></p>
<blockquote>
<p><strong>相关参数：</strong></p>
<p>batch.size:只有数据积累到 batch.size 之后，sender 才会发送数据。 linger.ms:如果数据迟迟未达到 batch.size，sender 等待 linger.time 之后就会发送数据。</p>
</blockquote>
<h5 id="异步发送-API"><a href="#异步发送-API" class="headerlink" title="异步发送 API"></a>异步发送 API</h5><ol>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写代码</p>
<p>需要用到的类:</p>
<p>KafkaProducer:需要创建一个生产者对象，用来发送数据</p>
<p>ProducerConfig:获取所需的一系列配置参数</p>
<p>ProducerRecord:每条数据都要封装成一个 ProducerRecord 对象</p>
<ol>
<li>不带回调函数的 API</li>
</ol>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NotCallBackApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">    properties.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">    <span class="comment">//重试次数</span></span><br><span class="line">    properties.put(<span class="string">&quot;retries&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//批次大小</span></span><br><span class="line">    properties.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">16384</span>);</span><br><span class="line">    <span class="comment">//等待时间</span></span><br><span class="line">    properties.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//RecordAccumulator 缓冲区大小</span></span><br><span class="line">    properties.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line">    properties.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">    properties.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">    Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(properties);</span><br><span class="line">    <span class="comment">//写入100条消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;first&quot;</span>, Integer.toString(i), Integer.toString(i)));</span><br><span class="line">    &#125;</span><br><span class="line">    producer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>带回调函数的 API</p>
<p>回调函数会在 producer 收到 ack 时调用，为异步调用，该方法有两个参数，分别是</p>
<p>RecordMetadata 和 Exception，如果 Exception 为 null，说明消息发送成功，如果 Exception 不为 null，说明消息发送失败。</p>
<blockquote>
<p>注意:消息发送失败会自动重试，不需要我们在回调函数中手动重试。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callBackApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">//kafka 集群，broker-list</span></span><br><span class="line">    props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">    <span class="comment">// props.put(&quot;acks&quot;, &quot;all&quot;);</span></span><br><span class="line">    <span class="comment">//重试次数</span></span><br><span class="line">    props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//批次大小</span></span><br><span class="line">    props.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">16384</span>);</span><br><span class="line">    <span class="comment">//等待时间</span></span><br><span class="line">    props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//RecordAccumulator 缓 冲区大小</span></span><br><span class="line">    props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line">    props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">    <span class="comment">//创建生产者端</span></span><br><span class="line">    Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">&quot;first&quot;</span>, Integer.toString(i), Integer.toString(i)), (metadata, e) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;success:&quot;</span> + metadata.offset());</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    producer.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="同步发送-API"><a href="#同步发送-API" class="headerlink" title="同步发送 API"></a>同步发送 API</h5></li>
</ol>
<p>同步发送的意思就是，一条消息发送之后，会阻塞当前线程，直至返回 ack。</p>
<p>由于 send 方法返回的是一个 Future 对象，根据 Futrue 对象的特点，我们也可以实现同步发送的效果，只需在调用 Future 对象的 get 方发即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synchronizedApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">//kafka 集群，broker-list</span></span><br><span class="line">    props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">    <span class="comment">// props.put(&quot;acks&quot;, &quot;all&quot;);</span></span><br><span class="line">    <span class="comment">//重试次数</span></span><br><span class="line">    props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//批次大小</span></span><br><span class="line">    props.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">16384</span>);</span><br><span class="line">    <span class="comment">//等待时间</span></span><br><span class="line">    props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//RecordAccumulator 缓 冲区大小</span></span><br><span class="line">    props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line">    props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">    Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;first&quot;</span>,</span><br><span class="line">                                           Integer.toString(i), Integer.toString(i))).get();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    producer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Consumer-API"><a href="#Consumer-API" class="headerlink" title="Consumer API"></a>Consumer API</h4><p>Consumer 消费数据时的可靠性是很容易保证的，因为数据在 Kafka 中是持久化的，故 不用担心数据丢失问题。</p>
<p>由于 consumer 在消费过程中可能会出现断电宕机等故障，consumer 恢复后，需要从故 障前的位置的继续消费，所以 consumer 需要实时记录自己消费到了哪个 offset，以便故障恢复后继续消费。</p>
<p>所以 offset 的维护是 Consumer 消费数据是必须考虑的问题。</p>
<h5 id="自动提交-offset"><a href="#自动提交-offset" class="headerlink" title="自动提交 offset"></a>自动提交 offset</h5><ol>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写代码</p>
<p>需要用到的类:</p>
<p>KafkaConsumer:需要创建一个消费者对象，用来消费数据 </p>
<p>ConsumerConfig:获取所需的一系列配置参数</p>
<p>ConsuemrRecord:每条数据都要封装成一个 ConsumerRecord 对象</p>
<p>为了使我们能够专注于自己的业务逻辑，Kafka 提供了自动提交 offset 的功能。 </p>
<p>自动提交 offset 的相关参数:<br><strong>enable.auto.commit</strong>:是否开启自动提交 offset 功能 </p>
<p><strong>auto.commit.interval.ms</strong>:自动提交 offset 的时间间隔</p>
<p>以下为自动提交 offset 的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">autoCommitOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">    <span class="comment">//订阅first topic</span></span><br><span class="line">    consumer.subscribe(Arrays.asList(<span class="string">&quot;first&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">      <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(), record.value());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="手动提交-offset"><a href="#手动提交-offset" class="headerlink" title="手动提交 offset"></a>手动提交 offset</h5></li>
</ol>
<p>虽然自动提交 offset 十分简介便利，但由于其是基于时间提交的，开发人员难以把握 offset 提交的时机。因此 Kafka 还提供了手动提交 offset 的 API。</p>
<p>手动提交 offset 的方法有两种:分别是 <strong>commitSync(同步提交)**和 **commitAsync(异步 提交)**。两者的相同点是，都会将</strong>本次 poll 的一批数据最高的偏移量提交**;不同点是， commitSync 阻塞当前线程，一直到提交成功，并且会自动失败重试(由不可控因素导致， 也会出现提交失败);而 commitAsync 则没有失败重试机制，故有可能提交失败。</p>
<ol>
<li><p>同步提交 offset</p>
<p>由于同步提交 offset 有失败重试机制，故更加可靠，以下为同步提交 offset 的示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synchronizedCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">//Kafka 集群</span></span><br><span class="line">    props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">    <span class="comment">//消费者组，只要 group.id 相同，就属于同一个消费者组</span></span><br><span class="line">    props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="comment">//关闭自动提交 offset</span></span><br><span class="line">    props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">    <span class="comment">//消费者订阅主题</span></span><br><span class="line">    consumer.subscribe(Arrays.asList(<span class="string">&quot;first&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">//消费者拉取数据</span></span><br><span class="line">      ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">      <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(), record.value());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//同步提交，当前线程会阻塞直到 offset 提交成功</span></span><br><span class="line">      consumer.commitSync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>异步提交 offset</p>
<p>虽然同步提交 offset 更可靠一些，但是由于其会阻塞当前线程，直到提交成功。因此吞吐量会收到很大的影响。因此更多的情况下，会选用异步提交 offset 的方式。 </p>
<p>以下为异步提交 offset 的示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">asynchronousCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">//Kafka 集群</span></span><br><span class="line">    props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">    <span class="comment">//消费者组，只要 group.id 相同，就属于同一个消费者组</span></span><br><span class="line">    props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="comment">//关闭自动提交 offset</span></span><br><span class="line">    props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">    <span class="comment">//消费者订阅主题</span></span><br><span class="line">    consumer.subscribe(Arrays.asList(<span class="string">&quot;first&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">//消费者拉取数据</span></span><br><span class="line">      ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">      <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(), record.value());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//异步提交</span></span><br><span class="line">      consumer.commitAsync((map, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(e != <span class="keyword">null</span>) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          System.out.println(map);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数据漏消费和重复消费分析</p>
<p>无论是同步提交还是异步提交 offset，都有可能会造成数据的漏消费或者重复消费。先提交 offset 后消费，有可能造成数据的漏消费;而先消费后提交 offset，有可能会造成数据 的重复消费。</p>
</li>
</ol>
<h5 id="自定义存储-offset"><a href="#自定义存储-offset" class="headerlink" title="自定义存储 offset"></a>自定义存储 offset</h5><p>Kafka 0.9 版本之前，offset 存储在 zookeeper，0.9 版本及之后，默认将 offset 存储在 Kafka 的一个内置的 topic 中。除此之外，Kafka 还可以选择自定义存储 offset。</p>
<p>offset 的维护是相当繁琐的，因为需要考虑到消费者的 Rebalace。</p>
<p><strong>当有新的消费者加入消费者组、已有的消费者推出消费者组或者所订阅的主题的分区发生变化，就会触发到分区的重新分配，重新分配的过程叫做 Rebalance。</strong></p>
<p>消费者发生 Rebalance 之后，每个消费者消费的分区就会发生变化。<strong>因此消费者要首先获取到自己被重新分配到的分区，并且定位到每个分区最近提交的 offset 位置继续消费</strong>。 要实现自定义存储 offset，需要借助 <strong>ConsumerRebalanceListener</strong>，以下为示例代码，其</p>
<p>中提交和获取 offset 的方法，需要根据所选的 offset 存储系统自行实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;TopicPartition, Long&gt; currentOffset = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建配置信息</span></span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">//Kafka 集群</span></span><br><span class="line">    props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop102:9092&quot;</span>);</span><br><span class="line">    <span class="comment">//消费者组，只要 group.id 相同，就属于同一个消费者组 props.put(&quot;group.id&quot;, &quot;test&quot;);</span></span><br><span class="line">    <span class="comment">//关闭自动提交 offset props.put(&quot;enable.auto.commit&quot;, &quot;false&quot;);</span></span><br><span class="line">    <span class="comment">//Key 和 Value 的反序列化类</span></span><br><span class="line">    props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    <span class="comment">//创建一个消费者</span></span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">    <span class="comment">//消费者订阅主题 consumer.subscribe(Arrays.asList(&quot;first&quot;),</span></span><br><span class="line">    <span class="keyword">new</span> ConsumerRebalanceListener() &#123;</span><br><span class="line">        <span class="comment">//该方法会在 Rebalance 之前调用</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123; </span><br><span class="line">          	commitOffset(currentOffset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//该方法会在 Rebalance 之后调用</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;</span><br><span class="line">          	currentOffset.clear();</span><br><span class="line">            <span class="keyword">for</span> (TopicPartition partition : partitions) &#123;</span><br><span class="line">            		consumer.seek(partition, getOffset(partition));<span class="comment">// 定位到最近提交的 offset 位置继续消费</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; ConsumerRecords&lt;String, String&gt;</span><br><span class="line">    records =consumer.poll(<span class="number">100</span>);<span class="comment">//消费者拉取数据</span></span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        currentOffset.put(<span class="keyword">new</span> TopicPartition(record.topic(),</span><br><span class="line">        record.partition()), record.offset()); &#125;</span><br><span class="line">        commitOffset(currentOffset);<span class="comment">//异步提交 &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取某分区的最新 offset</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getOffset</span><span class="params">(TopicPartition partition)</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提交该消费者所有分区的 offset</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commitOffset</span><span class="params">(Map&lt;TopicPartition, Long&gt; currentOffset)</span> </span>&#123;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义-Interceptor"><a href="#自定义-Interceptor" class="headerlink" title="自定义 Interceptor"></a>自定义 Interceptor</h4><h5 id="拦截器原理"><a href="#拦截器原理" class="headerlink" title="拦截器原理"></a>拦截器原理</h5><p>Producer 拦截器(interceptor)是在 Kafka 0.10 版本被引入的，主要用于实现 clients 端的定 制化控制逻辑。</p>
<p>对于 producer 而言，interceptor 使得用户在消息发送前以及 producer 回调逻辑前有机会 对消息做一些定制化需求，比如<strong>修改消息</strong>等。同时，producer 允许用户指定多个 interceptor 按序作用于同一条消息从而形成一个拦截链(interceptor chain)。Intercetpor 的实现接口是 <strong>org.apache.kafka.clients.producer.ProducerInterceptor</strong>，其定义的方法包括:</p>
<ol>
<li><p>configure(configs)</p>
<p>获取配置信息和初始化数据时调用。</p>
</li>
<li><p>onSend(ProducerRecord):</p>
<p>该方法封装进 KafkaProducer.send 方法中，即它运行在用户主线程中。Producer 确保在消息被序列化以及计算分区前调用该方法。<strong>用户可以在该方法中对消息做任何操作，但最好保证不要修改消息所属的 topic 和分区</strong>，否则会影响目标分区的计算。</p>
</li>
<li><p>onAcknowledgement(RecordMetadata, Exception):</p>
<p><strong>该方法会在消息从 RecordAccumulator 成功发送到 Kafka Broker 之后，或者在发送过程 中失败时调用。</strong>并且通常都是在 producer 回调逻辑触发之前。onAcknowledgement 运行在 producer 的 IO 线程中，因此不要在该方法中放入很重的逻辑，否则会拖慢 producer 的消息 发送效率。</p>
</li>
<li><p>close:</p>
<p><strong>关闭 interceptor，主要用于执行一些资源清理工作</strong></p>
<p>如前所述，interceptor 可能被运行在多个线程中，因此在具体实现时用户需要自行确保线程安全。<strong>另外倘若指定了多个 interceptor，则 producer 将按照指定顺序调用它们</strong>，并仅仅 是捕获每个 interceptor 可能抛出的异常记录到错误日志中而非在向上传递。这在使用过程中 要特别留意。</p>
</li>
</ol>
<h5 id="拦截器案例"><a href="#拦截器案例" class="headerlink" title="拦截器案例"></a>拦截器案例</h5><ol>
<li><p>需求:</p>
<p>实现一个简单的双 interceptor 组成的拦截链。第一个 interceptor 会在消息发送前将时间 戳信息加到消息 value 的最前部;第二个 interceptor 会在消息发送后更新成功发送消息数或 失败发送消息数。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210802120349.png" alt="image-20210802120349278"></p>
</li>
<li><p>案例实操</p>
<ol>
<li><p>增加时间戳拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.study.kafka.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.RecordMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/2 12:04 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimestampInterceptor</span> <span class="keyword">implements</span> <span class="title">ProducerInterceptor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerRecord&lt;String, String&gt; <span class="title">onSend</span><span class="params">(ProducerRecord&lt;String, String&gt; producerRecord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProducerRecord&lt;&gt;(producerRecord.topic(), producerRecord.partition(), producerRecord.timestamp(), producerRecord.key(), System.currentTimeMillis() + producerRecord.value());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; map)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>统计发送消息成功和发送失败消息数，并在 producer 关闭时打印这两个计数器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.study.kafka.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.RecordMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/2 12:09 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterInterceptor</span> <span class="keyword">implements</span> <span class="title">ProducerInterceptor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> errorCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> successCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerRecord&lt;String, String&gt; <span class="title">onSend</span><span class="params">(ProducerRecord&lt;String, String&gt; producerRecord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> producerRecord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == e) &#123;</span><br><span class="line">            successCounter++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            errorCounter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Successful send: &quot;</span> + successCounter);</span><br><span class="line">        System.out.println(<span class="string">&quot;error send &quot;</span> + errorCounter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; map)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.study.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Producer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/2 12:01 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaInterceptorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">        <span class="comment">//重试次数</span></span><br><span class="line">        properties.put(<span class="string">&quot;retries&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//批次大小</span></span><br><span class="line">        properties.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">16384</span>);</span><br><span class="line">        <span class="comment">//等待时间</span></span><br><span class="line">        properties.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//RecordAccumulator 缓冲区大小</span></span><br><span class="line">        properties.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        List&lt;String&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        interceptors.add(<span class="string">&quot;com.wsy.study.kafka.interceptor.TimestampInterceptor&quot;</span>);</span><br><span class="line">        interceptors.add(<span class="string">&quot;com.wsy.study.kafka.interceptor.CounterInterceptor&quot;</span>);</span><br><span class="line">        properties.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, interceptors);</span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(properties);</span><br><span class="line">        <span class="comment">// 3 发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;first&quot;</span>, <span class="string">&quot;message&quot;</span> + i);</span><br><span class="line">            producer.send(record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4 一定要关闭 producer，这样才会调用 interceptor 的 close 方法</span></span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
</li>
</ol>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210802121602.png" alt="image-20210802121602807"></p>
</li>
</ol>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210802121619.png" alt="image-20210802121619194"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security学习笔记</title>
    <url>/2021/01/07/spring%20security%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-SpringSecurity-框架简介"><a href="#1-SpringSecurity-框架简介" class="headerlink" title="1.SpringSecurity 框架简介"></a>1.SpringSecurity 框架简介</h2><h3 id="1-1-概要"><a href="#1-1-概要" class="headerlink" title="1.1 概要"></a>1.1 概要</h3><p>Spring 是非常流行和成功的 Java 应用开发框架，Spring Security 正是 Spring 家族中的 成员。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方 案。</p>
<p>正如你可能知道的关于安全方面的两个主要区域是“认证”和“授权”（或者访问控 制），一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权 （Authorization）两个部分，这两点也是 Spring Security 重要核心功能。</p>
<ul>
<li>用户认证指的是：验证某个用户是否为系统中的合法主体，也就是说用户能否访问 该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认 证过程。通俗点说就是系统认为用户是否能登录 </li>
<li>用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户 所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以 进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的 权限。通俗点讲就是系统判断用户是否有权限去做某些事情。</li>
</ul>
<h3 id="1-2-同款产品对比"><a href="#1-2-同款产品对比" class="headerlink" title="1.2 同款产品对比"></a>1.2 同款产品对比</h3><h4 id="1-2-1SpringSecurity"><a href="#1-2-1SpringSecurity" class="headerlink" title="1.2.1SpringSecurity"></a>1.2.1SpringSecurity</h4><p>Spring 技术栈的组成部分。 通过提供完整可扩展的认证和授权支持保护你的应用程序。 <a href="https://spring.io/projects/spring-security">https://spring.io/projects/spring-security</a> SpringSecurity 特点：</p>
<ul>
<li><p>和 Spring 无缝整合。 </p>
</li>
<li><p>全面的权限控制。 </p>
</li>
<li><p>专门为 Web 开发而设计。</p>
<ul>
<li> ◼旧版本不能脱离 Web 环境使用。 </li>
<li> ◼新版本对整个框架进行了分层抽取，分成了核心模块和 Web 模块。单独 引入核心模块就可以脱离 Web 环境。 </li>
</ul>
</li>
<li><p>重量级。</p>
</li>
</ul>
<h4 id="1-2-2-Shiro"><a href="#1-2-2-Shiro" class="headerlink" title="1.2.2 Shiro"></a>1.2.2 Shiro</h4><p>Apache 旗下的轻量级权限控制框架。 特点：</p>
<ul>
<li>轻量级。Shiro 主张的理念是把复杂的事情变简单。针对对性能有更高要求 的互联网应用有更好表现。</li>
<li>通用性。<ul>
<li> ◼好处：不局限于 Web 环境，可以脱离 Web 环境使用。</li>
<li> ◼缺陷：在 Web 环境下一些特定的需求需要手动编写代码定制</li>
</ul>
</li>
</ul>
<p>Spring Security 是 Spring 家族中的一个安全管理框架，实际上，在 Spring Boot 出现之 前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直 是 Shiro 的天下。 相对于 Shiro，在 SSM 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有 Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。 自从有了 Spring Boot 之后，Spring Boot 对于 Spring Security 提供了自动化配置方 案，可以使用更少的配置来使用 Spring Security。</p>
<h3 id="1-3模块划分"><a href="#1-3模块划分" class="headerlink" title="1.3模块划分"></a>1.3模块划分</h3><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094740.png" alt="image-20201203225522207"></p>
<h2 id="2-SpringBoot-对-Security-的自动配置"><a href="#2-SpringBoot-对-Security-的自动配置" class="headerlink" title="2 SpringBoot 对 Security 的自动配置"></a>2 SpringBoot 对 Security 的自动配置</h2><p><a href="https://docs.spring.io/spring-security/site/docs/5.3.4.RELEASE/reference/html5/#servlet-hello">https://docs.spring.io/spring-security/site/docs/5.3.4.RELEASE/reference/html5/#servlet-hello</a></p>
<h2 id="3-SpringSecurity-入门案例"><a href="#3-SpringSecurity-入门案例" class="headerlink" title="3.SpringSecurity 入门案例"></a>3.SpringSecurity 入门案例</h2><h3 id="3-1创建一个项目"><a href="#3-1创建一个项目" class="headerlink" title="3.1创建一个项目"></a>3.1创建一个项目</h3><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094741.png" alt="image-20201203225637468"></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094742.png" alt="image-20201203225632123"></p>
<h3 id="3-2改pom"><a href="#3-2改pom" class="headerlink" title="3.2改pom"></a>3.2改pom</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 导入springsecurity依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3创建application-yml文件"><a href="#3-3创建application-yml文件" class="headerlink" title="3.3创建application.yml文件"></a>3.3创建application.yml文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8011</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094743.png" alt="image-20201203230028148"></p>
</blockquote>
<h3 id="3-4创建controller接口"><a href="#3-4创建controller接口" class="headerlink" title="3.4创建controller接口"></a>3.4创建controller接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.springsecurity.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-03 23:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 测试控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello security&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-测试接口"><a href="#3-5-测试接口" class="headerlink" title="3.5 测试接口"></a>3.5 测试接口</h3><h4 id="3-5-1启动Application"><a href="#3-5-1启动Application" class="headerlink" title="3.5.1启动Application"></a>3.5.1启动Application</h4><h4 id="3-5-2访问接口"><a href="#3-5-2访问接口" class="headerlink" title="3.5.2访问接口"></a>3.5.2访问接口</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">localhost:8011/test/hello</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094744.png" alt="image-20201203230437681"></p>
<p>给我们的页面却是一个登录界面，需要我们登录。</p>
<p>默认用户名:user</p>
<p>密码在项目启动的时候在控制台会打印，<code>注意每次启动的时候密码都回发生变化！</code></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094745.png" alt="image-20201203231002485"></p>
<p>登录后自动跳转到了需要访问的路径</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094746.png" alt="image-20201203231038540"></p>
</blockquote>
<h2 id="4-SpringSecurity基本原理"><a href="#4-SpringSecurity基本原理" class="headerlink" title="4. SpringSecurity基本原理"></a>4. SpringSecurity基本原理</h2><p>SpringSecurity 本质是一个过滤器链： 从启动是可以获取到过滤器链：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter</span><br><span class="line">org.springframework.security.web.context.SecurityContextPersistenceFilter</span><br><span class="line">org.springframework.security.web.header.HeaderWriterFilter</span><br><span class="line">org.springframework.security.web.csrf.CsrfFilter</span><br><span class="line">org.springframework.security.web.authentication.logout.LogoutFilter</span><br><span class="line">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter</span><br><span class="line">org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter</span><br><span class="line">org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter</span><br><span class="line">org.springframework.security.web.savedrequest.RequestCacheAwareFilter</span><br><span class="line">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter</span><br><span class="line">org.springframework.security.web.authentication.AnonymousAuthenticationFilter</span><br><span class="line">org.springframework.security.web.session.SessionManagementFilter</span><br><span class="line">org.springframework.security.web.access.ExceptionTranslationFilter</span><br><span class="line">org.springframework.security.web.access.intercept.FilterSecurityInterceptor</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094747.png" alt="image-20201204003002108"></p>
</blockquote>
<p>代码底层流程：重点看三个过滤器： </p>
<p>FilterSecurityInterceptor：是一个方法级的权限过滤器, 基本位于过滤链的最底部。</p>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094748.png" alt="image-20201204001709655"></p>
<p>super.beforeInvocation(fi) 表示查看之前的 filter 是否通过。 fi.getChain().doFilter(fi.getRequest(), fi.getResponse());表示真正的调用后台的服务。</p>
</blockquote>
<p>ExceptionTranslationFilter：是个异常过滤器，用来处理在认证授权过程中抛出的异常</p>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094749.png" alt="image-20201204001838848"></p>
</blockquote>
<p>UsernamePasswordAuthenticationFilter ：对/login 的 POST 请求做拦截，校验表单中用户 名，密码。</p>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094750.png" alt="image-20201204001932106"></p>
</blockquote>
<p>两个重要的接口</p>
<p>UserDetailsService：当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中 账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。</p>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094751.png" alt="image-20201204011401664"></p>
<p>返回值 UserDetails：这个类是系统默认的用户“主体”</p>
</blockquote>
<p>PasswordEncoder：数据加密接口，用于返回User对象里面的密码加密</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示把参数按照特定的解析规则进行解析</span></span><br><span class="line"><span class="function">String <span class="title">encode</span><span class="params">(CharSequence rawPassword)</span></span>;</span><br><span class="line"><span class="comment">// 表示验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹</span></span><br><span class="line">配，则返回 <span class="keyword">true</span>；如果不匹配，则返回 <span class="keyword">false</span>。第一个参数表示需要被解析的密码。第二个</span><br><span class="line">参数表示存储的密码。</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span></span>;</span><br><span class="line"><span class="comment">// 表示如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回</span></span><br><span class="line"><span class="keyword">false</span>。默认返回 <span class="keyword">false</span>。</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">upgradeEncoding</span><span class="params">(String encodedPassword)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094752.png" alt="image-20201204011620814"></p>
<p>BCryptPasswordEncoder 是 Spring Security 官方推荐的密码解析器，平时多使用这个解析器。 BCryptPasswordEncoder 是对 bcrypt 强散列方法的具体实现。是基于 Hash 算法实现的单向加密。可以通过 strength 控制加密强度，默认 10.</p>
</blockquote>
<h3 id="4-1-实现用户名和密码的自定义"><a href="#4-1-实现用户名和密码的自定义" class="headerlink" title="4.1 实现用户名和密码的自定义"></a>4.1 实现用户名和密码的自定义</h3><p>实现自定义用户，首先先创建<code>UserDtailsService</code>的实现类，实现<code>loadUserByUsername</code>方法来加载自定义用户名和密码，返回值为Security包中提供的User对象,然后创建Security的配置类，继承<code>WebSecurityConfigurerAdapter</code>重写其中的configure方法</p>
<p>创建<code>UserDtailsServiceImp</code>l实现<code>UserDtailsService</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.springsecurity.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.AuthorityUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-04 1:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 设置登录的用户名和密码实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载用户名和密码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 可能为前台传入的用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 登录的用户名和密码对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UsernameNotFoundException 用户名未找到异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        List&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;wsy&quot;</span>, <span class="keyword">new</span> BCryptPasswordEncoder().encode(<span class="string">&quot;123456&quot;</span>), auths);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建<code>SecurityConfig</code>继承<code>WebSecurityConfigurerAdapter</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.springsecurity.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-04 0:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> Security配置类 配置登录时的用户名和密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityConfig</span><span class="params">(<span class="meta">@Qualifier(&quot;userDetailsServiceImpl&quot;)</span> UserDetailsService userDetailsService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDetailsService = userDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建PasswordEncoder对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> BCryptPasswordEncoder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">getPasswordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置认证的用户名和密码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth 认证</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//设置用户和密码加密对象</span></span><br><span class="line">        auth.userDetailsService(<span class="keyword">this</span>.userDetailsService).passwordEncoder(getPasswordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094753.png" alt="image-20201204012600477"></p>
</blockquote>
<h3 id="4-2-实现数据库认证来完成用户登录"><a href="#4-2-实现数据库认证来完成用户登录" class="headerlink" title="4.2 实现数据库认证来完成用户登录"></a>4.2 实现数据库认证来完成用户登录</h3><p>添加pom</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入Mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引入mysql --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引入lombok --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>yml文件添加数据库配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8011</span></span><br><span class="line"><span class="comment"># 配置数据库信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/security?serverTimezone=GMT%2B8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">wsy112233</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建实体类User</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.springsecurity.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-04 17:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 用户实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写UserMapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.springsecurity.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wsy.springsecurity.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-04 17:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 用户mapper</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名获得用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">User <span class="title">getUserByUsername</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写UserMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.wsy.springsecurity.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.wsy.springsecurity.entity.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wsy.springsecurity.entity.User&quot;</span>&gt;</span></span><br><span class="line">        select id, username, password</span><br><span class="line">        where users where username = #&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094754.png" alt="image-20201204174206039"></p>
</blockquote>
<p>修改UserDetailsServiceImpl类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.springsecurity.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wsy.springsecurity.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.AuthorityUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-04 1:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 设置登录的用户名和密码实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDetailsServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载用户名和密码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 前台传入的用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 登录的用户名和密码对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UsernameNotFoundException 用户名未找到异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        com.wsy.springsecurity.entity.User user = <span class="keyword">this</span>.userMapper.getUserByUsername(username);</span><br><span class="line">        <span class="comment">//如果用户名不存在则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == user) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">&quot;该用户名不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(user.getUsername(), <span class="keyword">new</span> BCryptPasswordEncoder().encode(user.getPassword()), auths);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-实现自定义登录页面"><a href="#4-3-实现自定义登录页面" class="headerlink" title="4.3 实现自定义登录页面"></a>4.3 实现自定义登录页面</h3><p>更改SecurityConfig配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.springsecurity.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-04 0:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> Security配置类 配置登录时的用户名和密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityConfig</span><span class="params">(<span class="meta">@Qualifier(&quot;userDetailsServiceImpl&quot;)</span> UserDetailsService userDetailsService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDetailsService = userDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建PasswordEncoder对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> BCryptPasswordEncoder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">getPasswordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置认证的用户名和密码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth 认证</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//设置用户和密码加密对象</span></span><br><span class="line">        auth.userDetailsService(<span class="keyword">this</span>.userDetailsService).passwordEncoder(getPasswordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以修改登录路径和设置访问白名单</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http HttpSecurity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//定义自己的登录页面</span></span><br><span class="line">        http.formLogin()</span><br><span class="line">                <span class="comment">//设置自己的登录页面</span></span><br><span class="line">                .loginPage(<span class="string">&quot;index.html&quot;</span>)</span><br><span class="line">                <span class="comment">//设置点击登录时提交的路径  不需要自己编写Security由提供</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/user/login&quot;</span>)</span><br><span class="line">                <span class="comment">//登录成功后自动跳转到/test/index</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/test/index&quot;</span>).permitAll()</span><br><span class="line">                .and().authorizeRequests()</span><br><span class="line">                <span class="comment">//设置不需要登录就可以访问的路径</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/test/hello&quot;</span>, <span class="string">&quot;/user/login&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">//对http所有的请求必须通过授权认证才可以访问</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                <span class="comment">//关闭csrf防护</span></span><br><span class="line">                .and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改TestController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.springsecurity.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-03 23:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 测试控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello security&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/index&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>添加index.html页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>login<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时可以直接访问localhost:8011/test/hello 不需要登录</p>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094755.png" alt="image-20201204183249656"></p>
</blockquote>
<p>访问localhost:8011/test/index 需要登录 因为在配置时我们没有配置该路径可以不用认证就可以访问</p>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094756.png" alt="image-20201204183329791"></p>
</blockquote>
<h3 id="4-4-基于角色或权限进行访问控制"><a href="#4-4-基于角色或权限进行访问控制" class="headerlink" title="4.4 基于角色或权限进行访问控制"></a>4.4 基于角色或权限进行访问控制</h3><h4 id="4-4-1-hasAuthority方法"><a href="#4-4-1-hasAuthority方法" class="headerlink" title="4.4.1 hasAuthority方法"></a>4.4.1 hasAuthority方法</h4><p>如果当前的主体具有指定的权限，则返回 true,否则返回 false</p>
<p>修改SecurityConfig配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以修改登录路径和设置访问白名单</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> http HttpSecurity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//定义自己的登录页面</span></span><br><span class="line">    http.formLogin()</span><br><span class="line">            <span class="comment">//设置自己的登录页面</span></span><br><span class="line">            .loginPage(<span class="string">&quot;/index.html&quot;</span>)</span><br><span class="line">            <span class="comment">//设置点击登录时提交的路径  不需要自己编写Security由提供</span></span><br><span class="line">            .loginProcessingUrl(<span class="string">&quot;/user/login&quot;</span>)</span><br><span class="line">            <span class="comment">//登录成功后自动跳转到/test/index</span></span><br><span class="line">            .defaultSuccessUrl(<span class="string">&quot;/test/index&quot;</span>).permitAll()</span><br><span class="line">            .and().authorizeRequests()</span><br><span class="line">            <span class="comment">//设置不需要登录就可以访问的路径</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/test/hello&quot;</span>, <span class="string">&quot;/user/login&quot;</span>).permitAll()</span><br><span class="line">            <span class="comment">//需要验证是否拥有admins这个权限</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/test/index&quot;</span>).hasAuthority(<span class="string">&quot;admins&quot;</span>)</span><br><span class="line">            <span class="comment">//对http所有的请求必须通过授权认证才可以访问</span></span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            <span class="comment">//关闭csrf防护</span></span><br><span class="line">            .and().csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这时候我们设置的权限是abc，而不是admins所以应该是无法访问的</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094757.png" alt="image-20201204205752397"></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094758.png" alt="image-20201204205847528"></p>
<p>这时候访问报错，提示403没有权限访问</p>
<p>这时候我们再将权限改为admins登录试一试</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094759.png" alt="image-20201204205933640"></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094800.png" alt="image-20201204205949253">访问成功</p>
</blockquote>
<h4 id="4-4-2-hasAnyAuthority-方法"><a href="#4-4-2-hasAnyAuthority-方法" class="headerlink" title="4.4.2  hasAnyAuthority 方法"></a>4.4.2  hasAnyAuthority 方法</h4><p>如果当前的主体有任何提供的角色（给定的作为一个逗号分隔的字符串列表）的话，返回 true.</p>
<p>修改SecurityConfig配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以修改登录路径和设置访问白名单</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http HttpSecurity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//定义自己的登录页面</span></span><br><span class="line">        http.formLogin()</span><br><span class="line">                <span class="comment">//设置自己的登录页面</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/index.html&quot;</span>)</span><br><span class="line">                <span class="comment">//设置点击登录时提交的路径  不需要自己编写Security由提供</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/user/login&quot;</span>)</span><br><span class="line">                <span class="comment">//登录成功后自动跳转到/test/index</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/test/index&quot;</span>).permitAll()</span><br><span class="line">                .and().authorizeRequests()</span><br><span class="line">                <span class="comment">//设置不需要登录就可以访问的路径</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/test/hello&quot;</span>, <span class="string">&quot;/user/login&quot;</span>).permitAll()</span><br><span class="line"><span class="comment">//                //需要验证是否拥有admins这个权限</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/test/index&quot;).hasAuthority(&quot;admins&quot;)</span></span><br><span class="line">                <span class="comment">//需要验证是否在这些权限之中</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/test/index&quot;</span>).hasAnyAuthority(<span class="string">&quot;admins&quot;</span>,<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                <span class="comment">//对http所有的请求必须通过授权认证才可以访问</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                <span class="comment">//关闭csrf防护</span></span><br><span class="line">                .and().csrf().disable();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时权限有admins或者user的就都可以访问该路径了，这里就不再截图演示了</p>
</blockquote>
<h4 id="4-4-3-hasRole-方法"><a href="#4-4-3-hasRole-方法" class="headerlink" title="4.4.3 hasRole 方法"></a>4.4.3 hasRole 方法</h4><p>如果用户具备给定角色就允许访问,否则出现 403。 如果当前主体具有指定的角色，则返回 true。 </p>
<p>底层源码：</p>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094801.png" alt="image-20201204214302849">在实现方法的地方发现返回的字符串前加了一个ROLE_这个前缀，所以我们在设置角色的时候也需要加上这个前缀</p>
</blockquote>
<p>修改UserDetailsServiceImpl</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094802.png" alt="image-20201204214459873"></p>
<p>修改SecurityConfig配置类</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094803.png" alt="image-20201204214532040"></p>
<p>修改配置文件： 注意配置文件中不需要添加”ROLE_“，因为上述的底层代码会自动添加与之进行匹配。</p>
<h4 id="4-4-4-hasAnyRole方法"><a href="#4-4-4-hasAnyRole方法" class="headerlink" title="4.4.4 hasAnyRole方法"></a>4.4.4 hasAnyRole方法</h4><p>表示用户具备任何一个条件都可以访问 这里与以上类似就不再做演示</p>
<h3 id="4-5-实现自定义403页面"><a href="#4-5-实现自定义403页面" class="headerlink" title="4.5 实现自定义403页面"></a>4.5 实现自定义403页面</h3><p>创建unauth.html页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>很抱歉您没有访问的权限！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改SecurityConfig配置类</p>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094804.png" alt="image-20201204215423083"></p>
<p>测试结果：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094805.png" alt="image-20201204215444779"></p>
</blockquote>
<h3 id="4-6-SpringSecurity-注解的使用"><a href="#4-6-SpringSecurity-注解的使用" class="headerlink" title="4.6  SpringSecurity 注解的使用"></a>4.6  SpringSecurity 注解的使用</h3><h4 id="4-6-1-Secured"><a href="#4-6-1-Secured" class="headerlink" title="4.6.1 @Secured"></a>4.6.1 @Secured</h4><p>首先在启动类上加上注解<code>@EnableGlobalMethodSecurity(securedEnabled = true)</code></p>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094806.png" alt="image-20201204220301281"></p>
</blockquote>
<p>修改TestController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello security&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/index&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Secured(&#123;&quot;ROLE_sale&quot;,&quot;ROLE_admin&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/update&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello update&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时访问localhost:8011/test/update时就会检查是否拥有注解配置的角色</p>
<h4 id="4-6-2-PreAuthorize"><a href="#4-6-2-PreAuthorize" class="headerlink" title="4.6.2  @PreAuthorize"></a>4.6.2  @PreAuthorize</h4><p>首先在启动类上加上注解<code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094807.png" alt="image-20201204221454216"></p>
<p>@PreAuthorize：注解适合进入方法前的权限验证， @PreAuthorize 可以将登录用户的 roles/permissions 参数传到方法中。</p>
<p>在TestController中添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyAuthority(&#x27;ROLE_sale&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/delete&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello delete&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-6-3-PostAuthorize"><a href="#4-6-3-PostAuthorize" class="headerlink" title="4.6.3 @PostAuthorize"></a>4.6.3 @PostAuthorize</h4><p>先开启注解功能： <code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code></p>
<p>@PostAuthorize 注解使用并不多，在方法执行后再进行权限验证，适合验证带有返回值 的权限.</p>
<p>在TestController中添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostAuthorize(&quot;hasAnyAuthority(&#x27;ROLE_sale1&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/delete1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">delete1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//没有权限时方法会执行，但是返回值无法返回</span></span><br><span class="line">    log.info(<span class="string">&quot;delete1 方法执行了-----------------&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello delete1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094808.png" alt="image-20201204221912894"></p>
<p>因为当前登录的用户没有ROLE_sale1这个权限所有返回的为自定义403页面</p>
<p>但是我们可以看到控制台打印了delete1方法中的日志</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094809.png" alt="image-20201204222021306"></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094810.png" alt="image-20201204222031255"></p>
</blockquote>
<h4 id="4-6-4-PostFilter"><a href="#4-6-4-PostFilter" class="headerlink" title="4.6.4 @PostFilter"></a>4.6.4 @PostFilter</h4><p>@PostFilter ：权限验证之后对数据进行过滤 留下用户名是 admin 的数据</p>
<p>在TestController中添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostFilter(&quot;filterObject.username == &#x27;admin&#x27;&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getUsers&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">&quot;user&quot;</span>,<span class="string">&quot;123456&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;111111&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094811.png" alt="image-20201204222458720"></p>
<p>可以看到在返回的值中没有第二条数据，是因为我们的注解<code>@PostFilter(&quot;filterObject.username == &#39;admin&#39;&quot;)</code>，这里是过滤判断是否返回值的username字段的值是否为’admin’，是的话才返回</p>
</blockquote>
<h4 id="4-6-5-PreFilter"><a href="#4-6-5-PreFilter" class="headerlink" title="4.6.5 @PreFilter"></a>4.6.5 @PreFilter</h4><p>@PreFilter: 进入控制器之前对数据进行过滤</p>
<p>在TestController中添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreFilter(&quot;filterObject.contains(&#x27;wsy&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/printInfo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printInfo</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;String&gt; info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String s : info) &#123;</span><br><span class="line">        log.info(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先访问localhost:8011/index.html登录</p>
<p>然后按F12键打开开发者工具</p>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094812.png" alt="image-20201204223229881"></p>
<p>将存入的cookie写入到postman的cookies中</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094813.png" alt="image-20201204223349365"></p>
</blockquote>
<p>这时候我们使用postman测试</p>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094814.png" alt="image-20201204225511012"></p>
<p>控制台输出：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094815.png" alt="image-20201204225524632"></p>
<p><code>@PreFilter(&quot;filterObject.contains(&#39;wsy&#39;)&quot;)</code>该注解为我们过滤了只要传入的参数里含有”wsy”该子串的数据</p>
</blockquote>
<h3 id="4-7-退出"><a href="#4-7-退出" class="headerlink" title="4.7 退出"></a>4.7 退出</h3><p>修改SecurityConfig配置类</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094816.png" alt="image-20201205122127514"></p>
<p>创建success.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    登陆成功</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/logout&quot;</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>登录成功后可以成功访问localhost:8011/test/index</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094817.png" alt="image-20201205122242200"></p>
<p>这时候我们点击退出后再访问试一试</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094818.png" alt="image-20201205122304640"></p>
<p>此时访问需要重新登陆</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094819.png" alt="image-20201205122318678"></p>
</blockquote>
<h3 id="4-8-自动登录"><a href="#4-8-自动登录" class="headerlink" title="4.8 自动登录"></a>4.8 自动登录</h3><h4 id="4-8-1-原理分析"><a href="#4-8-1-原理分析" class="headerlink" title="4.8.1 原理分析"></a>4.8.1 原理分析</h4><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094820.png" alt="image-20201205123553489"></p>
<h4 id="4-8-2-具体实现"><a href="#4-8-2-具体实现" class="headerlink" title="4.8.2 具体实现"></a>4.8.2 具体实现</h4><p>首先创建数据库表，其实是可以不用创建的，在SpringSecurity中源码有帮我们创建数据库的方法，但是我们这边为了演示的明显一点，所以我们手动创建数据库</p>
<p><code>JdbcTokenRepositoryImpl</code>该类中提供了操作表的语句</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094821.png" alt="image-20201205125557913"></p>
<p>这里我们手动创建表，其实就是复制上图中的CREATE_TABLE_SQL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> persistent_logins (</span><br><span class="line">	username <span class="type">VARCHAR</span> ( <span class="number">64</span> ) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	series <span class="type">VARCHAR</span> ( <span class="number">64</span> ) <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>,</span><br><span class="line">token <span class="type">VARCHAR</span> ( <span class="number">64</span> ) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">last_used <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094822.png" alt="image-20201205125747914"></p>
<p>创建JdbcTokenRepositoryConfig配置类 我们这里需要注入一个<code>JdbcTokenRepositoryImpl</code>到Spring容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.springsecurity.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-05 13:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 创建JdbcTokenRepositoryImpl对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTokenRepositoryConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建JdbcTokenRepositoryImpl对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource 数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JdbcTokenRepositoryImpl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTokenRepositoryImpl <span class="title">getJdbcTokenRepositoryImpl</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        JdbcTokenRepositoryImpl jdbcTokenRepository = <span class="keyword">new</span> JdbcTokenRepositoryImpl();</span><br><span class="line">        <span class="comment">//设置数据源</span></span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">//设置启动时创建表，因为我们手动创建了就不用写这条语句了</span></span><br><span class="line"><span class="comment">//        jdbcTokenRepository.setCreateTableOnStartup(true);</span></span><br><span class="line">        <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改SecurityConfig配置类</p>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094823.png" alt="image-20201205131330189"></p>
</blockquote>
<p>修改登录页面 添加记住我复选框</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remember-me&quot;</span>&gt;</span>记住我<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>login<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试</p>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094824.png" alt="image-20201205131124181"></p>
<p>登录成功后按F12打开开发者工具可以看到Cookie中存入了一个rememer-me的键值对</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094825.png" alt="image-20201205131207429"></p>
<p>数据库中也成功的存储了信息</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094826.png" alt="image-20201205131705201"></p>
<p>此时我们关闭浏览器后，再次访问需要登录认证的路径时发现可以直接访问</p>
<p>在点击退出时，会删除cookie和数据库中的数据</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094827.png" alt="image-20201205135626972"></p>
</blockquote>
<h3 id="4-9-CSRF"><a href="#4-9-CSRF" class="headerlink" title="4.9 CSRF"></a>4.9 CSRF</h3><h4 id="4-9-1-CSRF理解"><a href="#4-9-1-CSRF理解" class="headerlink" title="4.9.1 CSRF理解"></a>4.9.1 CSRF理解</h4><p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已 登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个 自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买 商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。 这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的 浏览器，却不能保证请求本身是用户自愿发出的。 从 Spring Security 4.0 开始，默认情况下会启用 CSRF 保护，以防止 CSRF 攻击应用 程序，Spring Security CSRF 会针对 PATCH，POST，PUT 和 DELETE 方法进行防护。</p>
<h4 id="4-9-2-案例"><a href="#4-9-2-案例" class="headerlink" title="4.9.2 案例"></a>4.9.2 案例</h4><p>在登录页面添加一个隐藏域：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span><span class="attr">th:if</span>=<span class="string">&quot;$&#123;_csrf&#125;!=null&quot;</span><span class="attr">th:value</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span><span class="attr">name</span>=<span class="string">&quot;_csrf&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>关闭安全配置的类中的 csrf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http.csrf().disable();</span></span><br></pre></td></tr></table></figure>
<h4 id="4-9-3-Spring-Security-实现-CSRF-的原理"><a href="#4-9-3-Spring-Security-实现-CSRF-的原理" class="headerlink" title="4.9.3 Spring Security 实现 CSRF 的原理"></a>4.9.3 Spring Security 实现 CSRF 的原理</h4><ol>
<li>生成 csrfToken 保存到 HttpSession 或者 Cookie 中</li>
</ol>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094828.png" alt="image-20201205141219922"></p>
<p>SaveOnAccessCsrfToken 类有个接口 CsrfTokenRepository</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094829.png" alt="image-20201205141234148"></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094830.png" alt="image-20201205141355532"></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094831.png" alt="image-20201205141409767"></p>
<ol start="2">
<li>请求到来时，从请求中提取 csrfToken，和保存的 csrfToken 做比较，进而判断当 前请求是否合法。主要通过 CsrfFilter 过滤器来完成。</li>
</ol>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094832.png" alt="image-20201205141524397"></p>
<h2 id="5-SpringSecurity-微服务权限方案"><a href="#5-SpringSecurity-微服务权限方案" class="headerlink" title="5. SpringSecurity 微服务权限方案"></a>5. SpringSecurity 微服务权限方案</h2><h3 id="5-1-微服务认证与授权实现思路"><a href="#5-1-微服务认证与授权实现思路" class="headerlink" title="5.1 微服务认证与授权实现思路"></a>5.1 微服务认证与授权实现思路</h3><ol>
<li>认证授权过程分析 （1）如果是基于 Session，那么 Spring-security 会对 cookie 里的 sessionid 进行解析，找 到服务器存储的 session 信息，然后判断当前用户是否符合请求的要求。 （2）如果是 token，则是解析出 token，然后将当前请求加入到 Spring-security 管理的权限 信息中去</li>
</ol>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094833.png" alt="image-20201205145809724"></p>
</blockquote>
<p>如果系统的模块众多，每个模块都需要进行授权与认证，所以我们选择基于 token 的形式 进行授权与认证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限 值，并以用户名为 key，权限列表为 value 的形式存入 redis 缓存中，根据用户名相关信息 生成 token 返回，浏览器将 token 记录到 cookie 中，每次调用 api 接口都默认将 token 携带 到 header 请求头中，Spring-security 解析 header 头获取 token 信息，解析 token 获取当前 用户名，根据用户名就可以从 redis 中获取权限列表，这样 Spring-security 就能够判断当前 请求是否有权限访问</p>
<ol start="2">
<li><p>权限管理数据模型</p>
<blockquote>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094834.png" alt="image-20201205145836211"></p>
</blockquote>
</li>
</ol>
<h3 id="5-2-jwt-介绍"><a href="#5-2-jwt-介绍" class="headerlink" title="5.2 jwt 介绍"></a>5.2 jwt 介绍</h3><h4 id="5-2-1-访问令牌的类型"><a href="#5-2-1-访问令牌的类型" class="headerlink" title="5.2.1 访问令牌的类型"></a>5.2.1 访问令牌的类型</h4><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094835.png" alt="image-20201205145949305"></p>
<h4 id="5-2-2-jwt的组成"><a href="#5-2-2-jwt的组成" class="headerlink" title="5.2.2 jwt的组成"></a>5.2.2 jwt的组成</h4><p>典型的，一个 JWT 看起来如下图：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107094836.png" alt="image-20201205150011360"></p>
<p>该对象为一个很长的字符串，字符之间通过”.”分隔符分为三个子串。 每一个子串表示了一个功能块，总共有以下三个部分：JWT 头、有效载荷和签名</p>
<h5 id="JWT-头"><a href="#JWT-头" class="headerlink" title="JWT 头"></a>JWT 头</h5><p> JWT 头部分是一个描述 JWT 元数据的 JSON 对象，通常如下所示。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，alg 属性表示签名使用的算法，默认为 HMAC SHA256（写为 HS256）； typ 属性表示令牌的类型，JWT 令牌统一写为 JWT。最后，使用 Base64 URL 算法将上述 JSON 对象转换为字符串保存。</p>
<h5 id="有效载荷"><a href="#有效载荷" class="headerlink" title="有效载荷"></a>有效载荷</h5><p>有效载荷部分，是 JWT 的主体内容部分，也是一个 JSON 对象，包含需要传递的数据。 JWT 指定七个默认字段供选择。</p>
<ul>
<li><p>iss：发行人 </p>
</li>
<li><p>xp：到期时间 </p>
</li>
<li><p>sub：主题 </p>
</li>
<li><p>aud：用户 </p>
</li>
<li><p>nbf：在此之前不可用</p>
</li>
<li><p>iat：发布时间 </p>
</li>
<li><p>jti：JWT ID 用于标识该 JWT </p>
<p>除以上默认字段外，我们还可以自定义私有字段，如下例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Helen&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;admin&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>  请注意，默认情况下 JWT 是未加密的，任何人都可以解读其内容，因此不要构建隐私信息 字段，存放保密信息，以防止信息泄露。</p>
<p> JSON 对象也使用 Base64 URL 算法转换为字符串保存。</p>
<h5 id="签名哈希"><a href="#签名哈希" class="headerlink" title="签名哈希"></a>签名哈希</h5><p>   签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。</p>
<p>   首先，需要指定一个密码（secret）。该密码仅仅为保存在服务器中，并且不能向用户公 开。然后，使用标头中指定的签名算法（默认情况下为 HMAC SHA256）根据以下公式生成签名。 </p>
<p>  HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(claims), secret) 在计算出签名哈希后，JWT 头，有效载荷和签名哈希的三个部分组合成一个字符串，每个 部分用”.”分隔，就构成整个 JWT 对象。</p>
<h5 id="Base64URL-算法"><a href="#Base64URL-算法" class="headerlink" title="Base64URL 算法"></a>Base64URL 算法</h5><p>  如前所述，JWT 头和有效载荷序列化的算法都用到了 Base64URL。该算法和常见 Base64 算 法类似，稍有差别。</p>
<p>  作为令牌的 JWT 可以放在 URL 中（例如 api.example/?token=xxx）。 Base64 中用的三个 字符是”+”，”/“和”=”，由于在 URL 中有特殊含义，因此 Base64URL 中对他们做了替换： “=”去掉，”+”用”-“替换，”/“用”_”替换，这就是 Base64URL 算法。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>树结构实际应用</title>
    <url>/2021/01/25/%E6%A0%91%E7%BB%93%E6%9E%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-堆排序"><a href="#1-堆排序" class="headerlink" title="1.堆排序"></a>1.堆排序</h2><h3 id="1-1堆排序基本介绍"><a href="#1-1堆排序基本介绍" class="headerlink" title="1.1堆排序基本介绍"></a>1.1堆排序基本介绍</h3><ol>
<li><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复 杂度均为 O(nlogn)，它也是不稳定排序。</p>
</li>
<li><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有 要求结点的左孩子的值和右孩子的值的大小关系。</p>
</li>
<li><p>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</p>
</li>
<li><p>大顶堆举例说明<img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154133.png" alt="image-20210125153328527"></p>
</li>
<li><p>小顶堆举例说明<img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154134.png" alt="image-20210125153342184"></p>
</li>
<li><p>一般升序采用大顶堆，降序采用小顶堆</p>
</li>
</ol>
<h3 id="1-2堆排序基本思想"><a href="#1-2堆排序基本思想" class="headerlink" title="1.2堆排序基本思想"></a>1.2堆排序基本思想</h3><p>堆排序的基本思想是:</p>
<ol>
<li>将待排序序列构造成一个大顶堆</li>
<li>此时，整个序列的最大值就是堆顶的根节点。</li>
<li>将其与末尾元素进行交换，此时末尾就为最大值。</li>
<li>然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序 序列了。</li>
</ol>
<p>可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了</p>
<h3 id="1-3堆排序步骤图解说明"><a href="#1-3堆排序步骤图解说明" class="headerlink" title="1.3堆排序步骤图解说明"></a>1.3堆排序步骤图解说明</h3><p>要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。</p>
<blockquote>
<p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。 原始的数组 [4, 6, 8, 5, 9] 1) .假设给定无序序列结构如下</strong></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154135.png" alt="image-20210125153459770"></p>
<p>此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154136.png" alt="image-20210125153527868"></p>
<p>找到第二个非叶节点 4，由于[4,9,8]中 9 元素最大，4 和 9 交换。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154137.png" alt="image-20210125153541179"></p>
<p>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154138.png" alt="image-20210125153550700"></p>
<p>此时，我们就将一个无序序列构造成了一个大顶堆。</p>
<p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p>
<p>将堆顶元素 9 和末尾元素 4 进行交换</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154139.png" alt="image-20210125153629892"></p>
<p>重新调整结构，使其继续满足堆定义</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154140.png" alt="image-20210125153638314"></p>
<p>再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8.</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154141.png" alt="image-20210125153647101"></p>
<p>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154142.png" alt="image-20210125153655194"></p>
<p><strong>再简单总结下堆排序的基本思路：</strong></p>
<ol>
<li>.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</li>
<li>.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</li>
<li>.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤， 直到整个序列有序</li>
</ol>
</blockquote>
<h3 id="1-4堆排序代码实现"><a href="#1-4堆排序代码实现" class="headerlink" title="1.4堆排序代码实现"></a>1.4堆排序代码实现</h3><p>要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。</p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-25 14:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            swap(arr,<span class="number">0</span>,j);<span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt;temp)&#123;<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-赫夫曼树"><a href="#2-赫夫曼树" class="headerlink" title="2.赫夫曼树"></a>2.赫夫曼树</h2><h3 id="2-1基本介绍"><a href="#2-1基本介绍" class="headerlink" title="2.1基本介绍"></a>2.1基本介绍</h3><ol>
<li>给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，<strong>若该树的带权路径长度(wpl)达到最小，</strong>称这样的二叉树为 最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。</li>
<li>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近</li>
</ol>
<h3 id="2-2赫夫曼树几个重要概念和举例说明"><a href="#2-2赫夫曼树几个重要概念和举例说明" class="headerlink" title="2.2赫夫曼树几个重要概念和举例说明"></a>2.2赫夫曼树几个重要概念和举例说明</h3><ol>
<li><strong>路径和路径长度</strong>：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。<strong>通路中分支的数目称为路径长度。</strong>若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1</li>
<li><strong>结点的权及带权路径长度</strong>：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。<strong>结点的带权路径长度为</strong>：从根结点到该结点之间的路径长度与该结点的权的乘积</li>
<li>树的带权路径长度：树的带权路径长度规定为<strong>所有叶子结点的带权路径长度之和，</strong>记为 <strong>WPL(weighted path length)</strong> ,权值越大的结点离根结点越近的二叉树才是最优二叉树。</li>
<li>WPL 最小的就是赫夫曼树</li>
</ol>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154143.png" alt="image-20210125153956963"></p>
<h3 id="2-3赫夫曼树创建思路图解"><a href="#2-3赫夫曼树创建思路图解" class="headerlink" title="2.3赫夫曼树创建思路图解"></a>2.3赫夫曼树创建思路图解</h3><p>给你一个数列 {13, 7, 8, 3, 29, 6, 1}，要求转成一颗赫夫曼树. </p>
<ul>
<li><p>思路分析(示意图)：</p>
<p>{13, 7, 8, 3, 29, 6, 1}</p>
<p><strong>构成赫夫曼树的步骤：</strong></p>
</li>
</ul>
<ol>
<li>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</li>
<li>取出根节点权值最小的两颗二叉树</li>
<li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</li>
<li>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数 据都被处理，就得到一颗赫夫曼树</li>
<li>图解:</li>
</ol>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210125154144.png" alt="image-20210125154103500"></p>
<h3 id="2-4赫夫曼树的代码实现"><a href="#2-4赫夫曼树的代码实现" class="headerlink" title="2.4赫夫曼树的代码实现"></a>2.4赫夫曼树的代码实现</h3><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.huffman;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-25 15:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 哈夫曼树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">29</span>, <span class="number">6</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Node root = createHuffmanTree(arr);</span><br><span class="line">        preOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        root.preOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建哈夫曼树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> root节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先将数组中所有数值创建成节点并加入到list集合中</span></span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> Node(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环创建子树</span></span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//首先对集合中进行排序</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            <span class="comment">//取出最小的两个节点</span></span><br><span class="line">            Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line">            Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//创建新的根节点</span></span><br><span class="line">            Node parant = <span class="keyword">new</span> Node(leftNode.value + rightNode.value);</span><br><span class="line">            parant.left = leftNode;</span><br><span class="line">            parant.right = rightNode;</span><br><span class="line">            <span class="comment">//从集合中删除取出来的两个节点</span></span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            <span class="comment">//添加新创建的节点</span></span><br><span class="line">            nodes.add(parant);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node  节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node.value);</span><br><span class="line">        preOrder(node.left);</span><br><span class="line">        preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value - o.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-赫夫曼编码"><a href="#3-赫夫曼编码" class="headerlink" title="3.赫夫曼编码"></a>3.赫夫曼编码</h2><h3 id="3-1基本介绍"><a href="#3-1基本介绍" class="headerlink" title="3.1基本介绍"></a>3.1基本介绍</h3><ol>
<li>赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法</li>
<li>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</li>
<li>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在 20%～90%之间</li>
<li>赫夫曼码是可变字长编码(VLC)的一种。Huffman 于 1952 年提出一种编码方法，称之为最佳编码</li>
</ol>
<h3 id="3-2原理剖析"><a href="#3-2原理剖析" class="headerlink" title="3.2原理剖析"></a>3.2原理剖析</h3><ul>
<li><p>通信领域中信息的处理方式 1-定长编码<img src="https://gitee.com/Pink_oops/image/raw/master/20210130144533.png" alt="image-20210126162836670"></p>
</li>
<li><p>通信领域中信息的处理方式 2-变长编码<img src="https://gitee.com/Pink_oops/image/raw/master/20210130144534.png" alt="image-20210126162849216"></p>
</li>
<li><p>通信领域中信息的处理方式 3-赫夫曼编码</p>
<p>步骤如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130144535.png" alt="image-20210126163131417"></p>
</li>
</ul>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130144536.png" alt="image-20210126163141984"></p>
<p>长度为 ： 133 </p>
<p>说明: 原来长度是 359 , 压缩了 (359-133) / 359 = 62.9%  </p>
<p>此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性 赫夫曼编码是无损处理方案</p>
<p><strong>注意事项：</strong></p>
<p>注意, 这个赫夫曼树根据<strong>排序方法不同</strong>，也可能不太一样，这样对应的<strong>赫夫曼编码也不完全一样</strong>，但是 <strong>wpl 是 一样的</strong>，都是最小的, 最后生成的赫夫曼编码的长度是一样，比如: 如果我们让每次生成的新的二叉树总是排在权 值相同的二叉树的最后一个，则生成的二叉树为:</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130144537.png" alt="image-20210126163251087"></p>
<h3 id="3-3最佳实践-数据压缩"><a href="#3-3最佳实践-数据压缩" class="headerlink" title="3.3最佳实践-数据压缩"></a>3.3最佳实践-数据压缩</h3><p>将给出的一段文本，比如 “i like like like java do you like a java” ， 根据前面的讲的赫夫曼编码原理，对其进行数 据 压 缩 处 理 ， 形 式 如 “1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100 110111101111011100100001100001110 “</p>
<ol>
<li>根据赫夫曼编码压缩数据的原理，需要创建 “i like like like java do you like a java” 对应的赫夫曼树.</li>
<li>生成赫夫曼树对应的赫夫曼编码 , 如下表: =01 a=100 d=11000 u=11001 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000 o=0011</li>
<li>使用赫夫曼编码来生成赫夫曼编码数据 ,即按照上面的赫夫曼编码，将”i like like like java do you like a java  字符串生成对应的编码数据, 形式如下. 10101000101111111100100010111111110010001011111111001001010011011100011100000110111010001111001010 00101111111100110001001010011011100</li>
<li>使用赫夫曼编码来解码数据</li>
<li>来完成对文件的压缩</li>
<li>来完成对文件的解压</li>
</ol>
<h3 id="3-4赫夫曼编码压缩文件注意事项"><a href="#3-4赫夫曼编码压缩文件注意事项" class="headerlink" title="3.4赫夫曼编码压缩文件注意事项"></a>3.4赫夫曼编码压缩文件注意事项</h3><ol>
<li>如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件 [举例压一个 .ppt]</li>
<li>赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件) [举例压一个.xml 文件]</li>
<li>如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显.</li>
</ol>
<h2 id="4-二叉排序树"><a href="#4-二叉排序树" class="headerlink" title="4.二叉排序树"></a>4.二叉排序树</h2><h3 id="3-1先看一个需求"><a href="#3-1先看一个需求" class="headerlink" title="3.1先看一个需求"></a>3.1先看一个需求</h3><p>给你一个数列 (7, 3, 10, 12, 5, 1, 9)，要求能够高效的完成对数据的查询和添加 </p>
<h3 id="3-2解决方案分析"><a href="#3-2解决方案分析" class="headerlink" title="3.2解决方案分析"></a>3.2解决方案分析</h3><ul>
<li><p>使用数组</p>
<p>数组未排序， 优点：直接在数组尾添加，速度快。 缺点：查找速度慢. [示意图] </p>
<p>数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位 </p>
<p>置后，后面的数据需整体移动，速度慢。[示意图]</p>
</li>
<li><p>使用链式存储-链表 </p>
<p>不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动。</p>
</li>
<li><p>使用二叉排序树</p>
</li>
</ul>
<h3 id="4-3二叉排序树介绍"><a href="#4-3二叉排序树介绍" class="headerlink" title="4.3二叉排序树介绍"></a>4.3二叉排序树介绍</h3><p><strong>二叉排序树</strong>：BST: (Binary Sort(Search) Tree), 对于二叉排序树的<strong>任何一个非叶子节点</strong>，要求<strong>左子节点的值比当</strong> </p>
<p><strong>前节点的值小</strong>，<strong>右子节点的值比当前节点的值大</strong>。 </p>
<p><strong>特别说明</strong>：如果有相同的值，可以将该节点放在左子节点或右子节点 </p>
<p>比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130144538.png" alt="image-20210130140018262"></p>
<h3 id="4-4二叉排序树创建和遍历"><a href="#4-4二叉排序树创建和遍历" class="headerlink" title="4.4二叉排序树创建和遍历"></a>4.4二叉排序树创建和遍历</h3><p>一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如: 数组为 Array(7, 3, 10, 12, 5, 1, 9) ， 创 </p>
<p>建成对应的二叉排序树为 : </p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130144539.png" alt="image-20210130140047802"></p>
<h3 id="4-5二叉排序树的删除"><a href="#4-5二叉排序树的删除" class="headerlink" title="4.5二叉排序树的删除"></a>4.5二叉排序树的删除</h3><p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑 </p>
<ol>
<li><p><strong>删除叶子节点</strong> (比如：2, 5, 9, 12)</p>
</li>
<li><p>删除<strong>只有一颗子树的节点</strong> (比如：1)</p>
</li>
<li><p>删除<strong>有两颗子树的节点</strong>. (比如：7, 3，10 )</p>
</li>
<li><p>操作的思路分析</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130144540.png" alt="image-20210130140144676"></p>
</li>
</ol>
<p>//对删除结点的各种情况的思路分析: </p>
<p>第一种情况: </p>
<p>删除叶子节点 (比如：2, 5, 9, 12) </p>
<p>思路</p>
<p>(1) 需求先去找到要删除的结点 targetNode </p>
<p>(2) 找到 targetNode 的 父结点 parent </p>
<p>(3) 确定 targetNode 是 parent 的左子结点 还是右子结点 </p>
<p>(4) 根据前面的情况来对应删除 </p>
<p>左子结点 parent.left = null </p>
<p>右子结点 parent.right = null; </p>
<p>第二种情况: 删除只有一颗子树的节点 比如 1 </p>
<p>思路</p>
<p>(1) 需求先去找到要删除的结点 targetNode </p>
<p>(2) 找到 targetNode 的 父结点 parent </p>
<p>(3) 确定 targetNode 的子结点是左子结点还是右子结点 </p>
<p>(4) targetNode 是 parent 的左子结点还是右子结点 </p>
<p>(5) 如果 targetNode 有左子结点</p>
<p>5.1 如果 targetNode 是 parent 的左子结点</p>
<p>parent.left = targetNode.left; </p>
<p>5.2 如果 targetNode 是 parent 的右子结点 </p>
<p>parent.right = targetNode.left; </p>
<p>(6) 如果 targetNode 有右子结点 </p>
<p>6.1 如果 targetNode 是 parent 的左子结点 </p>
<p>parent.left = targetNode.right; </p>
<p>6.2 如果 targetNode 是 parent 的右子结点 </p>
<p>parent.right = targetNode.right </p>
<p>情况三 ： 删除有两颗子树的节点. (比如：7, 3，10 ) </p>
<p>思路</p>
<p>(1) 需求先去找到要删除的结点 targetNode </p>
<p>(2) 找到 targetNode 的 父结点 parent </p>
<p>(3) 从 targetNode 的右子树找到最小的结点 </p>
<p>(4) 用一个临时变量，将 最小结点的值保存 temp = 11 </p>
<p>(5) 删除该最小结点 </p>
<p>(6) targetNode.value = temp </p>
<h3 id="4-6二叉排序树删除节点的代码实现"><a href="#4-6二叉排序树删除节点的代码实现" class="headerlink" title="4.6二叉排序树删除节点的代码实现"></a>4.6二叉排序树删除节点的代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.binarysorttree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-26 16:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 二叉排序树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            binarySortTree.add(<span class="keyword">new</span> Node(i));</span><br><span class="line">        &#125;</span><br><span class="line">        binarySortTree.midOrder();</span><br><span class="line"><span class="comment">//        binarySortTree.delNode(2);</span></span><br><span class="line">        binarySortTree.delNode(<span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">        binarySortTree.midOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root.midOrder(<span class="keyword">this</span>.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除右子树中最小的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root  根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  被删除的节点的value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">delRightTreeMinNode</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Node temp = root;</span><br><span class="line">        <span class="comment">//因为是二叉排序树所以左子树的值一定比根节点和右子树小 所以一直往左找 找到最左的节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除该节点</span></span><br><span class="line">        delNode(temp.value);</span><br><span class="line">        <span class="keyword">return</span> temp.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先获得要删除的节点</span></span><br><span class="line">        Node node = <span class="keyword">this</span>.root.search(value);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断root节点是需要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root.left == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.root.right == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.root.value == value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得父节点</span></span><br><span class="line">        Node parent = <span class="keyword">this</span>.root.searchParent(value);</span><br><span class="line">        <span class="comment">//判断需要删除的节点是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是父节点的左子节点还是右子节点</span></span><br><span class="line">            <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == node.value) &#123;</span><br><span class="line">                <span class="comment">//左子节点</span></span><br><span class="line">                parent.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == node.value) &#123;</span><br><span class="line">                <span class="comment">//右子节点</span></span><br><span class="line">                parent.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//左右两边都不为空的情况下</span></span><br><span class="line">            <span class="keyword">int</span> min = delRightTreeMinNode(node.right);</span><br><span class="line">            node.value = min;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//左右两边有一个不为空的情况下</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//在左子节点不为空的情况下</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == node.value) &#123;</span><br><span class="line">                    <span class="comment">//该节点是父节点的左子节点的情况下</span></span><br><span class="line">                    parent.left = node.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == node.value) &#123;</span><br><span class="line">                    <span class="comment">//该节点是父节点的右节点的情况下</span></span><br><span class="line">                    parent.right = node.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;出错了！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//在右子节点不为空的情况下</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == node.value) &#123;</span><br><span class="line">                    <span class="comment">//该节点是父节点的左子节点的情况下</span></span><br><span class="line">                    parent.left = node.right;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == node.value) &#123;</span><br><span class="line">                    <span class="comment">//该节点是父节点的右节点的情况下</span></span><br><span class="line">                    parent.right = node.right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;出错了！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 需要删除节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 需要删除的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值比当前节点的值要小的话就递归查询左子树</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值比当前节点的值要大的话就递归查询右子树</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点的父节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 需要删除的节点的父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value) || (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果需要查询的值小于当前节点则往左子树递归遍历</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果需要查询的值大于当前节点则往右子树递归遍历</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.midOrder(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.midOrder(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉排序树添加方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小于当前节点所有向左</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//大于等于当前节点向右</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-平衡二叉树-AVL-树"><a href="#5-平衡二叉树-AVL-树" class="headerlink" title="5.平衡二叉树(AVL 树)"></a>5.平衡二叉树(AVL 树)</h2><h3 id="5-1看一个案例-说明二叉排序树可能的问题"><a href="#5-1看一个案例-说明二叉排序树可能的问题" class="headerlink" title="5.1看一个案例(说明二叉排序树可能的问题)"></a>5.1看一个案例(说明二叉排序树可能的问题)</h3><p>给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在. </p>
<p>左边 BST 存在的问题分析: </p>
<ol>
<li><p>左子树全部为空，从形式上看，更像一个单链表.</p>
</li>
<li><p>插入速度没有影响</p>
</li>
<li><p>查询速度明显降低(因为需要依次比较), 不能发挥 BST的优势，因为每次还需要比较左子树，其查询速度比 </p>
<p>单链表还慢</p>
</li>
<li><p>解决方案-平衡二叉树(AVL)</p>
</li>
</ol>
<h3 id="5-2基本介绍"><a href="#5-2基本介绍" class="headerlink" title="5.2基本介绍"></a>5.2基本介绍</h3><ol>
<li><p>平衡二叉树也叫平衡<strong>二叉搜索树</strong>（Self-balancing binary search tree）又被称为 AVL 树， 可以保证查询效率较高。</p>
</li>
<li><p>具有以下特点：它是<strong>一 棵空树</strong>或<strong>它的左右两个子树的高度差的绝对值不超过</strong> <strong>1</strong>，并且<strong>左右两个子树都是一棵</strong> <strong>平衡二叉树</strong>。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等</p>
</li>
<li><p>举例说明, 看看下面哪些 AVL 树, 为什么?<img src="https://gitee.com/Pink_oops/image/raw/master/20210130165515.png" alt="image-20210130165514884"></p>
</li>
</ol>
<h3 id="5-3应用案例-单旋转-左旋转"><a href="#5-3应用案例-单旋转-左旋转" class="headerlink" title="5.3应用案例-单旋转(左旋转)"></a>5.3应用案例-单旋转(左旋转)</h3><ol>
<li>要求: 给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8} </li>
<li>思路分析(示意图)<img src="https://gitee.com/Pink_oops/image/raw/master/20210130165614.png" alt="image-20210130165614396"></li>
<li>代码实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 左旋转</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建新的结点，以当前根结点的值</span></span><br><span class="line">  Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">  <span class="comment">//把新的结点的左子树设置成当前结点的左子树</span></span><br><span class="line">  newNode.left = <span class="keyword">this</span>.left;</span><br><span class="line">  <span class="comment">//把新的结点的右子树设置成当前结点的右子树的左子树</span></span><br><span class="line">  newNode.right =  <span class="keyword">this</span>.right.left;</span><br><span class="line">  <span class="comment">//把当前结点的值替换成右子结点的值</span></span><br><span class="line">  <span class="keyword">this</span>.value = right.value;</span><br><span class="line">  <span class="comment">//把当前结点的右子树设置成当前结点右子树的右子树</span></span><br><span class="line">  <span class="keyword">this</span>.right = <span class="keyword">this</span>.right.right;</span><br><span class="line">  <span class="comment">//把当前结点的左子树(左子结点)设置成新的结点</span></span><br><span class="line">  <span class="keyword">this</span>.left = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4应用案例-单旋转-右旋转"><a href="#5-4应用案例-单旋转-右旋转" class="headerlink" title="5.4应用案例-单旋转(右旋转)"></a>5.4应用案例-单旋转(右旋转)</h3><ol>
<li>要求: 给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6}</li>
<li>思路分析（示意图）<img src="https://gitee.com/Pink_oops/image/raw/master/20210130165753.png" alt="image-20210130165753518"></li>
<li>代码实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 右旋转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">  newNode.right = <span class="keyword">this</span>.right;</span><br><span class="line">  newNode.left = <span class="keyword">this</span>.left.right;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">this</span>.left.value;</span><br><span class="line">  <span class="keyword">this</span>.left = <span class="keyword">this</span>.left.left;</span><br><span class="line">  <span class="keyword">this</span>.right = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-5应用案例-双旋转"><a href="#5-5应用案例-双旋转" class="headerlink" title="5.5应用案例-双旋转"></a>5.5应用案例-双旋转</h3><p>前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转 </p>
<p>不能完成平衡二叉树的转换。比如数列 </p>
<p>int[] arr = { 10, 11, 7, 6, 8, 9 }; 运行原来的代码可以看到，并没有转成 AVL 树. </p>
<p>int[] arr = {2,1,6,5,7,3}; // 运行原来的代码可以看到，并没有转成 AVL 树</p>
<p>问题分析<img src="https://gitee.com/Pink_oops/image/raw/master/20210130165903.png" alt="image-20210130165903250"></p>
<p>总体代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.avl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/30 3:05 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> AVL数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;4,3,6,5,7,8&#125;;</span></span><br><span class="line"><span class="comment">//        int[] arr = &#123; 10, 12, 8, 9, 7, 6 &#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="comment">//创建一个 AVLTree对象</span></span><br><span class="line">        AVLTree avlTree = <span class="keyword">new</span> AVLTree();</span><br><span class="line">        <span class="comment">//添加结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            avlTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        avlTree.midOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;在平衡处理~~&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;树的高度=&quot;</span> + avlTree.getRoot().height()); <span class="comment">//3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;树的左子树高度=&quot;</span> + avlTree.getRoot().leftTreeHeight()); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;树的右子树高度=&quot;</span> + avlTree.getRoot().rightTreeHeight()); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root.midOrder(<span class="keyword">this</span>.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除右子树中最小的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被删除的节点的value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">delRightTreeMinNode</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Node temp = root;</span><br><span class="line">        <span class="comment">//因为是二叉排序树所以左子树的值一定比根节点和右子树小 所以一直往左找 找到最左的节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除该节点</span></span><br><span class="line">        delNode(temp.value);</span><br><span class="line">        <span class="keyword">return</span> temp.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先获得要删除的节点</span></span><br><span class="line">        Node node = <span class="keyword">this</span>.root.search(value);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断root节点是需要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root.left == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.root.right == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.root.value == value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得父节点</span></span><br><span class="line">        Node parent = <span class="keyword">this</span>.root.searchParent(value);</span><br><span class="line">        <span class="comment">//判断需要删除的节点是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是父节点的左子节点还是右子节点</span></span><br><span class="line">            <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == node.value) &#123;</span><br><span class="line">                <span class="comment">//左子节点</span></span><br><span class="line">                parent.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == node.value) &#123;</span><br><span class="line">                <span class="comment">//右子节点</span></span><br><span class="line">                parent.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//左右两边都不为空的情况下</span></span><br><span class="line">            <span class="keyword">int</span> min = delRightTreeMinNode(node.right);</span><br><span class="line">            node.value = min;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//左右两边有一个不为空的情况下</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//在左子节点不为空的情况下</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == node.value) &#123;</span><br><span class="line">                    <span class="comment">//该节点是父节点的左子节点的情况下</span></span><br><span class="line">                    parent.left = node.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == node.value) &#123;</span><br><span class="line">                    <span class="comment">//该节点是父节点的右节点的情况下</span></span><br><span class="line">                    parent.right = node.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    root = node.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//在右子节点不为空的情况下</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == node.value) &#123;</span><br><span class="line">                    <span class="comment">//该节点是父节点的左子节点的情况下</span></span><br><span class="line">                    parent.left = node.right;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == node.value) &#123;</span><br><span class="line">                    <span class="comment">//该节点是父节点的右节点的情况下</span></span><br><span class="line">                    parent.right = node.right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    root = node.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightTreeHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.right.height();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左子树的高度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 左子树的高度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftTreeHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.left.height();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求出树的高度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(<span class="keyword">this</span>.left == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="keyword">this</span>.left.height(), <span class="keyword">this</span>.right == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="keyword">this</span>.right.height()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左旋转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建新的结点，以当前根结点的值</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">        <span class="comment">//把新的结点的左子树设置成当前结点的左子树</span></span><br><span class="line">        newNode.left = <span class="keyword">this</span>.left;</span><br><span class="line">        <span class="comment">//把新的结点的右子树设置成当前结点的右子树的左子树</span></span><br><span class="line">        newNode.right =  <span class="keyword">this</span>.right.left;</span><br><span class="line">        <span class="comment">//把当前结点的值替换成右子结点的值</span></span><br><span class="line">        <span class="keyword">this</span>.value = right.value;</span><br><span class="line">        <span class="comment">//把当前结点的右子树设置成当前结点右子树的右子树</span></span><br><span class="line">        <span class="keyword">this</span>.right = <span class="keyword">this</span>.right.right;</span><br><span class="line">        <span class="comment">//把当前结点的左子树(左子结点)设置成新的结点</span></span><br><span class="line">        <span class="keyword">this</span>.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右旋转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">        newNode.right = <span class="keyword">this</span>.right;</span><br><span class="line">        newNode.left = <span class="keyword">this</span>.left.right;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.left.value;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">this</span>.left.left;</span><br><span class="line">        <span class="keyword">this</span>.right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 需要删除节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 需要删除的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值比当前节点的值要小的话就递归查询左子树</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果需要查找的值比当前节点的值要大的话就递归查询右子树</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点的父节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 需要删除的节点的父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value) || (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果需要查询的值小于当前节点则往左子树递归遍历</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果需要查询的值大于当前节点则往右子树递归遍历</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.midOrder(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.midOrder(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉排序树添加方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小于当前节点所有向左</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//大于等于当前节点向右</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加完之后判断是否需要旋转</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.rightTreeHeight() - <span class="keyword">this</span>.leftTreeHeight() &gt;<span class="number">1</span> ) &#123;</span><br><span class="line">            <span class="comment">//如果当前节点的右子树的左子树高度大于右子树的右子树的高度的话就需要先将当前节点的右子树先进行一次右旋转</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.left.height() &gt; <span class="keyword">this</span>.right.right.height()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.right.rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            leftRotate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.leftTreeHeight() - <span class="keyword">this</span>.rightTreeHeight() &gt;<span class="number">1</span> ) &#123;</span><br><span class="line">            <span class="comment">//如果当前节点的左子树的左子树高度小于左子树的右子树的话就需要先将当前节点的左子树先进行一次左旋转</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.left.height() &lt; <span class="keyword">this</span>.left.right.height()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.left.leftRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            rightRotate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-多路查找树"><a href="#6-多路查找树" class="headerlink" title="6.多路查找树"></a>6.多路查找树</h2><h3 id="6-1-二叉树与B树"><a href="#6-1-二叉树与B树" class="headerlink" title="6.1 二叉树与B树"></a>6.1 二叉树与B树</h3><h4 id="6-1-1二叉树的问题分析"><a href="#6-1-1二叉树的问题分析" class="headerlink" title="6.1.1二叉树的问题分析"></a>6.1.1二叉树的问题分析</h4><p>二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130182005.png" alt="image-20210130180457810"></p>
<p>二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如 1 亿)， 就 </p>
<p>存在如下问题:</p>
<p>问题 1：在构建二叉树时，需要多次进行 i/o 操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时， 速度有影响</p>
<p>问题 2：节点海量，也会造成二叉树的高度很大，会降低操作速度.</p>
<h4 id="6-1-2多叉树"><a href="#6-1-2多叉树" class="headerlink" title="6.1.2多叉树"></a>6.1.2多叉树</h4><ol>
<li>在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点， 就是多叉树（multiway tree）</li>
<li>后面我们讲解的 2-3 树，2-3-4 树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。</li>
<li>举例说明(下面 2-3 树就是一颗多叉树)<img src="https://gitee.com/Pink_oops/image/raw/master/20210130180746.png" alt="image-20210130180746024"></li>
</ol>
<h3 id="6-2-2-3-树"><a href="#6-2-2-3-树" class="headerlink" title="6.2 2-3 树"></a>6.2 2-3 树</h3><p>2-3 树是最简单的 B 树结构, 具有如下特点:</p>
<ol>
<li>2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件) </li>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</li>
<li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.</li>
<li>2-3 树是由二节点和三节点构成的树。 </li>
</ol>
<p>将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成 2-3 树，并保证数据插入的大小顺序。(演示一下构建 2-3 树的过程.) </p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130181027.png" alt="image-20210130181027566"></p>
<p>插入规则: </p>
<ol>
<li><p>2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件)</p>
</li>
<li><p>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</p>
</li>
<li><p>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</p>
</li>
<li><p>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层， 拆后仍然需要满足上面 3 个条件。 </p>
</li>
<li><p>对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则</p>
</li>
</ol>
<p>除了 23 树，还有 234 树等，概念和 23 树类似，也是一种 B 树。 如图:<img src="https://gitee.com/Pink_oops/image/raw/master/20210130181223.png" alt="image-20210130181223147"></p>
<h3 id="6-3-B-树、B-树和-B-树"><a href="#6-3-B-树、B-树和-B-树" class="headerlink" title="6.3 B 树、B+树和 B*树"></a>6.3 B 树、B+树和 B*树</h3><h4 id="6-3-1-B-树的介绍"><a href="#6-3-1-B-树的介绍" class="headerlink" title="6.3.1 B 树的介绍"></a>6.3.1 B 树的介绍</h4><p>B-tree 树即 B 树，B 即 Balanced，平衡的意思。有人把 B-tree 翻译成 B-树，容易让人产生误解。会以为 B-树 是一种树，而 B 树又是另一种树。实际上，B-tree 就是指的 B 树。</p>
<h3 id="6-3-2-B-树的介绍"><a href="#6-3-2-B-树的介绍" class="headerlink" title="6.3.2 B 树的介绍"></a>6.3.2 B 树的介绍</h3><p>前面已经介绍了 2-3 树和 2-3-4 树，他们就是 B 树(英语：B-tree 也写成 B-树)，这里我们再做一个说明，我们在学 习 Mysql 时，经常听到说某种类型的索引是基于 B 树或者 B+树的，如图: <img src="https://gitee.com/Pink_oops/image/raw/master/20210130181425.png" alt="image-20210130181425020"></p>
<p>对上图的说明:</p>
<ol>
<li>B 树的阶：节点的最多子节点个数。比如 2-3 树的阶是 3，2-3-4 树的阶是 4</li>
<li>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询 关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li>
<li>关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据. </li>
<li>搜索有可能在非叶子结点结束</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找</li>
</ol>
<h3 id="6-3-3-B-树的介绍"><a href="#6-3-3-B-树的介绍" class="headerlink" title="6.3.3 B+树的介绍"></a>6.3.3 B+树的介绍</h3><p>B+树是 B 树的变体，也是一种多路搜索树。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130181535.png" alt="image-20210130181535392"></p>
<p>对上图的说明:</p>
<ol>
<li>B+树的搜索与 B 树也基本相同，区别是 B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性 能也等价于在关键字全集做一次二分查找</li>
<li>所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据) 恰好是有序的。 </li>
<li>不可能在非叶子结点命中</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数b据层</li>
<li>更适合文件索引系统</li>
<li>B 树和 B+树各有自己的应用场景，不能说 B+树完全比 B 树好，反之亦然</li>
</ol>
<h3 id="6-3-4-B-树的介绍"><a href="#6-3-4-B-树的介绍" class="headerlink" title="6.3.4 B*树的介绍"></a>6.3.4 B*树的介绍</h3><p>B*树是 B+树的变体，在 B+树的<strong>非根和非叶子结点</strong>再增<strong>加指向兄弟的指针</strong>。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210130181716.png" alt="image-20210130181716612"></p>
<p>B*树的说明: </p>
<ol>
<li><p>B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为 2/3，而 B+树的块的最低使用率为的 1/2。</p>
</li>
<li><p>从第 1 个特点我们可以看出，B*树分配新结点的概率比 B+树要低，空间使用率更高</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>树学习笔记</title>
    <url>/2021/01/21/%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1.二叉树"></a>1.二叉树</h2><h3 id="1-1为什么需要树这种数据结构"><a href="#1-1为什么需要树这种数据结构" class="headerlink" title="1.1为什么需要树这种数据结构"></a>1.1为什么需要树这种数据结构</h3><ul>
<li><p><strong>数组</strong>存储方式的分析</p>
<p><strong>优点</strong>：通过<strong>下标方式访问元素</strong>，速度快。对于有序数组，还可使用<strong>二分查找</strong>提高检索速度。 缺点：如果要检索具体某个值，或者<strong>插入值(按一定顺序)会整体移动</strong>，效率较低 [示意图] 画出<strong>操作示意图</strong>：</p>
</li>
</ul>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210121155706.png" alt="image-20210121140600253"></p>
<ul>
<li><p><strong>链式</strong>存储方式的分析</p>
<p><strong>优点</strong>：在一定程度上对数组存储方式有优化(比如：<strong>插入</strong>一个数值节点，只需要将插入节点，链接到链表中即可， <strong>删除</strong>效率也很好)。 <strong>缺点</strong>：在进行<strong>检索</strong>时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 【示意图】 </p>
</li>
</ul>
<p><strong>操作示意图</strong>：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210121155707.png" alt="image-20210121140646387"></p>
<ul>
<li><p><strong>树存储</strong>方式的分析</p>
<p>能提高数据<strong>存储，读取</strong>的效率, 比如利用 <strong>二叉排序树</strong>(Binary Sort Tree)，既可以保证数据的检索速度，同时也 可以保证数据的<strong>插入，删除，修改</strong>的速度。【示意图,后面详讲】</p>
</li>
</ul>
<p><strong>案例</strong>: [7, 3, 10, 1, 5, 9, 12]</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210121155708.png" alt="image-20210121140739579"></p>
<h3 id="1-2树示意图"><a href="#1-2树示意图" class="headerlink" title="1.2树示意图"></a>1.2树示意图</h3><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210121155709.png" alt="image-20210121140806316"></p>
<table>
<thead>
<tr>
<th>树的常用术语(结合示意图理解):</th>
</tr>
</thead>
<tbody><tr>
<td>节点</td>
</tr>
<tr>
<td>根节点</td>
</tr>
<tr>
<td>父节点</td>
</tr>
<tr>
<td>子节点</td>
</tr>
<tr>
<td>叶子节点 (没有子节点的节点)</td>
</tr>
<tr>
<td>节点的权(节点值)</td>
</tr>
<tr>
<td>路径(从 root 节点找到该节点的路线)</td>
</tr>
<tr>
<td>层</td>
</tr>
<tr>
<td>子树</td>
</tr>
<tr>
<td>树的高度(最大层数)</td>
</tr>
<tr>
<td>森林 :多颗子树构成森林</td>
</tr>
</tbody></table>
<h3 id="1-3二叉树的概念"><a href="#1-3二叉树的概念" class="headerlink" title="1.3二叉树的概念"></a>1.3二叉树的概念</h3><ul>
<li><p>树有很多种，每个节点<strong>最多只能有两个子节点</strong>的一种形式称为二叉树。</p>
</li>
<li><p>二叉树的子节点分为左节点和右节点</p>
</li>
<li><p>示意图</p>
</li>
</ul>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210121155710.png" alt="image-20210121141000184"></p>
<ul>
<li>如果该二叉树的<strong>所有叶子节点</strong>都在<strong>最后一层</strong>，并且结点总数= <strong>2^n -1</strong> , n 为层数，则我们称为<strong>满二叉树</strong></li>
</ul>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210121155711.png" alt="image-20210121141036942"></p>
<ul>
<li>如果该二叉树的<strong>所有叶子节点</strong>都在<strong>最后一层或者倒数第二层</strong>，而且最后一层的叶子节点在<strong>左边连续</strong>，倒数第二 层的叶子节点在<strong>右边连续</strong>，我们称为<strong>完全二叉树</strong></li>
</ul>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210121155712.png" alt="image-20210121141106988"></p>
<h3 id="1-4二叉树遍历的说明"><a href="#1-4二叉树遍历的说明" class="headerlink" title="1.4二叉树遍历的说明"></a>1.4二叉树遍历的说明</h3><p>使用<strong>前序，中序和后序</strong>对下面的二叉树进行遍历</p>
<ol>
<li>前序遍历: 先输出父节点，再遍历左子树和右子树</li>
<li>中序遍历: 先遍历左子树，再输出父节点，再遍历右子树</li>
<li>后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点</li>
<li><strong>小结</strong>: 看输出父节点的顺序，就确定是前序，中序还是后序</li>
</ol>
<h3 id="1-5二叉树遍历应用实例-前序-中序-后序"><a href="#1-5二叉树遍历应用实例-前序-中序-后序" class="headerlink" title="1.5二叉树遍历应用实例(前序,中序,后序)"></a>1.5二叉树遍历应用实例(前序,中序,后序)</h3><p>应用实例的说明和思路</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210121155713.png" alt="image-20210121141303602"></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-21 13:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先需要创建一颗二叉树</span></span><br><span class="line">        BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">        <span class="comment">//创建需要的结点</span></span><br><span class="line">        HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">        HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;吴用&quot;</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">        HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>);</span><br><span class="line">        HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">5</span>, <span class="string">&quot;关胜&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        node3.setLeft(node5);</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前序遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历&quot;</span>);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        binaryTree.midOrder();</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历&quot;</span>);</span><br><span class="line">        binaryTree.rearOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前根节点为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.midOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前根节点为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rearOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.rearOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前根节点为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;</span><br><span class="line">    <span class="keyword">private</span> HeroNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历首先输出当前节点 再判断左节点、 右节点是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历首先判断左节点是否为空，再输出当前节点，再判断右节点是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.midOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.midOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序遍历首先判断左节点是否为空，再判断右节点是否为空，再输出当前节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rearOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.rearOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.rearOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6二叉树-查找指定节点"><a href="#1-6二叉树-查找指定节点" class="headerlink" title="1.6二叉树-查找指定节点"></a>1.6二叉树-查找指定节点</h3><p>要求</p>
<ol>
<li><p>请编写前序查找，中序查找和后序查找的方法。</p>
</li>
<li><p>并分别使用三种查找方式，查找 heroNO = 5 的节点</p>
</li>
<li><p>并分析各种查找方式，分别比较了多少次</p>
</li>
<li><p>思路分析图解</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210121155714.png" alt="image-20210121144238133"></p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-21 13:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先需要创建一颗二叉树</span></span><br><span class="line">        BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">        <span class="comment">//创建需要的结点</span></span><br><span class="line">        HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">        HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;吴用&quot;</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">        HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>);</span><br><span class="line">        HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">5</span>, <span class="string">&quot;关胜&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        node3.setLeft(node5);</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //前序遍历</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;前序遍历&quot;);</span></span><br><span class="line"><span class="comment">//        binaryTree.preOrder();</span></span><br><span class="line"><span class="comment">//        //中序遍历</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;中序遍历&quot;);</span></span><br><span class="line"><span class="comment">//        binaryTree.midOrder();</span></span><br><span class="line"><span class="comment">//        //后序遍历</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;后序遍历&quot;);</span></span><br><span class="line"><span class="comment">//        binaryTree.rearOrder();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//前序遍历</span></span><br><span class="line">        <span class="comment">//前序遍历的次数 ：4</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;前序遍历方式~~~&quot;);</span></span><br><span class="line"><span class="comment">//        HeroNode resNode = binaryTree.preOrderSearch(7);</span></span><br><span class="line"><span class="comment">//        if (resNode != null) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.printf(&quot;找到了，信息为 no=%d name=%s&quot;, resNode.getNo(), resNode.getName());</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            System.out.printf(&quot;没有找到 no = %d 的英雄&quot;, 5);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历查找</span></span><br><span class="line">        <span class="comment">//中序遍历3次</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;中序遍历方式~~~&quot;);</span></span><br><span class="line"><span class="comment">//		HeroNode resNode = binaryTree.midOrderSearch(5);</span></span><br><span class="line"><span class="comment">//		if (resNode != null) &#123;</span></span><br><span class="line"><span class="comment">//			System.out.printf(&quot;找到了，信息为 no=%d name=%s&quot;, resNode.getNo(), resNode.getName());</span></span><br><span class="line"><span class="comment">//		&#125; else &#123;</span></span><br><span class="line"><span class="comment">//			System.out.printf(&quot;没有找到 no = %d 的英雄&quot;, 5);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//后序遍历查找</span></span><br><span class="line">        <span class="comment">//后序遍历查找的次数  2次</span></span><br><span class="line">		System.out.println(<span class="string">&quot;后序遍历方式~~~&quot;</span>);</span><br><span class="line">		HeroNode resNode = binaryTree.rearOrderSearch(<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.printf(<span class="string">&quot;找到了，信息为 no=%d name=%s&quot;</span>, resNode.getNo(), resNode.getName());</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.printf(<span class="string">&quot;没有找到 no = %d 的英雄&quot;</span>, <span class="number">5</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前根节点为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.midOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前根节点为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rearOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.rearOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前根节点为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.root.preOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">midOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.root.midOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">rearOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.root.rearOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;</span><br><span class="line">    <span class="keyword">private</span> HeroNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历首先输出当前节点 再判断左节点、 右节点是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历首先判断左节点是否为空，再输出当前节点，再判断右节点是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.midOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.midOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序遍历首先判断左节点是否为空，再判断右节点是否为空，再输出当前节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rearOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.rearOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.rearOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找的编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 编号对应的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;查找！&quot;</span>);</span><br><span class="line">        <span class="comment">//首先先判断是否是当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断左子节点是否为空 如果不为空则左递归前序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果resNode不等于空了的话代表从左子节点递归中获得到了节点 就代表找到了no节点</span></span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断右子节点是否为空 如果不为空则右递归前序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时返回resNode 不管resNode是不是为空 因为所有节点已经遍历结束 如果最后返回为null代表没有找到该节点</span></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找的编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 编号对应的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">midOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断左子节点是否为空 如果不为空则左递归中序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.midOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果resNode不等于空了的话代表从左子节点递归中获得到了节点 就代表找到了no节点</span></span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;查找！&quot;</span>);</span><br><span class="line">        <span class="comment">//判断是否是当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断右子节点是否为空 如果不为空则右递归中序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.midOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时返回resNode 不管resNode是不是为空 因为所有节点已经遍历结束 如果最后返回为null代表没有找到该节点</span></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找的编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 编号对应的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">rearOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断左子节点是否为空 如果不为空则左递归后序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.midOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果resNode不等于空了的话代表从左子节点递归中获得到了节点 就代表找到了no节点</span></span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断右子节点是否为空 如果不为空则右递归后序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.midOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果resNode不等于空了的话代表从左子节点递归中获得到了节点 就代表找到了no节点</span></span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;查找！&quot;</span>);</span><br><span class="line">        <span class="comment">//判断是否是当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时返回resNode 不管resNode是不是为空 因为所有节点已经遍历结束 如果最后返回为null代表没有找到该节点</span></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-7二叉树-删除节点"><a href="#1-7二叉树-删除节点" class="headerlink" title="1.7二叉树-删除节点"></a>1.7二叉树-删除节点</h3></li>
</ol>
<p>要求</p>
<ol>
<li><p>如果删除的节点是叶子节点，则删除该节点</p>
</li>
<li><p>如果删除的节点是非叶子节点，则删除该子树.</p>
</li>
<li><p>测试，删除掉 5 号叶子节点 和 3 号子树.</p>
</li>
<li><p>完成删除思路分析</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210121155715.png" alt="image-20210121152314470"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	BinaryTree类的delNode方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root.getNo() == no) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前根节点为空，无法删除&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除节点	HeroNode类的delNode方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> no 节点编号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断</span></span><br><span class="line"><span class="comment">    当前这个结点是不是需要删除结点.</span></span><br><span class="line"><span class="comment">    2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将 this.left = null; 并且就返回</span></span><br><span class="line"><span class="comment">    (结束递归删除)</span></span><br><span class="line"><span class="comment">    3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将 this.right= null ;并且就返回</span></span><br><span class="line"><span class="comment">    (结束递归删除)</span></span><br><span class="line"><span class="comment">    4. 如果第 2 和第 3 步没有删除结点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">    5. 如果第 4 步也没有删除结点，则应当向右子树进行递归删除.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="2-顺序存储二叉树"><a href="#2-顺序存储二叉树" class="headerlink" title="2.顺序存储二叉树"></a>2.顺序存储二叉树</h2><h3 id="2-1顺序存储二叉树的概念"><a href="#2-1顺序存储二叉树的概念" class="headerlink" title="2.1顺序存储二叉树的概念"></a>2.1顺序存储二叉树的概念</h3><ul>
<li><p>基本说明</p>
<p>从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组， 看右面的示意图。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210121155716.png" alt="image-20210121154900126"></p>
<ul>
<li>要求:<ol>
<li>右图的二叉树的结点，要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6]</li>
<li>要求在遍历数组 arr 时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历</li>
</ol>
</li>
<li>顺序存储二叉树的特点:<ol>
<li>顺序二叉树通常只考虑完全二叉树</li>
<li>第 n 个元素的左子节点为 2 * n + 1</li>
<li>第 n 个元素的右子节点为 2 * n + 2</li>
<li>第 n 个元素的父节点为 (n-1) / 2</li>
<li>n : 表示二叉树中的第几个元素(按 0 开始编号如图所示)</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="2-2顺序存储二叉树遍历"><a href="#2-2顺序存储二叉树遍历" class="headerlink" title="2.2顺序存储二叉树遍历"></a>2.2顺序存储二叉树遍历</h3><p>需求: 给你一个数组 {1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。 前序遍历的结果应当为 1,2,4,5,3,6,7</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-21 15:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 顺序存储二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="comment">//前序输出 [1,2,4,5,3,6,7]</span></span><br><span class="line">        <span class="comment">//中序输出 [4,2,5,1,6,3,7]</span></span><br><span class="line">        <span class="comment">//后序输出 [4,5,2,6,7,3,1]</span></span><br><span class="line">        ArrBinaryTree arrBinaryTree = <span class="keyword">new</span> ArrBinaryTree(arr);</span><br><span class="line">        System.out.print(<span class="string">&quot;前序输出: &quot;</span>);</span><br><span class="line">        arrBinaryTree.preOrder();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.print(<span class="string">&quot;中序输出: &quot;</span>);</span><br><span class="line">        arrBinaryTree.midOrder();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.print(<span class="string">&quot;后序输出: &quot;</span>);</span><br><span class="line">        arrBinaryTree.rearOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrBinaryTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重载前序遍历默认为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重载中序遍历默认为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.midOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重载后序遍历默认为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rearOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rearOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//左节点是index*2+1 右节点是index*2+2</span></span><br><span class="line">        System.out.print(arr[index] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        <span class="comment">//左递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            preOrder(index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            preOrder(index * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//左节点是index*2+1 右节点是index*2+2</span></span><br><span class="line">        <span class="comment">//左递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            midOrder(index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(arr[index] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        <span class="comment">//右递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            midOrder(index * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rearOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//左节点是index*2+1 右节点是index*2+2</span></span><br><span class="line">        <span class="comment">//左递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            rearOrder(index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            rearOrder(index * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(arr[index] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-3顺序存储二叉树应用实例"><a href="#2-3顺序存储二叉树应用实例" class="headerlink" title="2.3顺序存储二叉树应用实例"></a>2.3顺序存储二叉树应用实例</h3><p>八大排序算法中的堆排序，就会使用到顺序存储二叉树， 关于堆排序，我们放在**&lt;&lt;树结构实际应用&gt;&gt;** 章节讲解。</p>
<h2 id="3-线索化二叉树"><a href="#3-线索化二叉树" class="headerlink" title="3.线索化二叉树"></a>3.线索化二叉树</h2><h3 id="3-1先看一个问题"><a href="#3-1先看一个问题" class="headerlink" title="3.1先看一个问题"></a>3.1先看一个问题</h3><p>将数列 {1, 3, 6, 8, 10, 14 } 构建成一颗二叉树. n+1=7</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210123170024.png" alt="image-20210123151734744"></p>
<p>问题分析:</p>
<ol>
<li>当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 6, 14 }</li>
<li>但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上.</li>
<li>) 如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办?</li>
<li>解决方案-<strong>线索二叉树</strong></li>
</ol>
<h3 id="3-2线索二叉树基本介绍"><a href="#3-2线索二叉树基本介绍" class="headerlink" title="3.2线索二叉树基本介绍"></a>3.2线索二叉树基本介绍</h3><ol>
<li>n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向 该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”）</li>
<li>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质 的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种</li>
<li>一个结点的前一个结点，称为<strong>前驱</strong>结点</li>
<li>一个结点的后一个结点，称为<strong>后继</strong>结点</li>
</ol>
<h3 id="3-3线索二叉树应用案例"><a href="#3-3线索二叉树应用案例" class="headerlink" title="3.3线索二叉树应用案例"></a>3.3线索二叉树应用案例</h3><p>应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为 {8, 3, 10, 1, 14, 6}</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210123170025.png" alt="image-20210123151848919"></p>
<p><strong>思路分析</strong>: 中序遍历的结果：{8, 3, 10, 1, 14, 6}<img src="https://gitee.com/Pink_oops/image/raw/master/img/20210123170026.png" alt="image-20210123151900977"></p>
<blockquote>
<p>说明: 当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况:</p>
<ol>
<li>left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的 就是前驱节点.</li>
<li>right 指向的是右子树，也可能是指向后继节点，比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向 的是后继节点.</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.tree.threadedbinarytree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-23 14:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 线索化二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试一把中序线索二叉树的功能</span></span><br><span class="line">        HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">6</span>, <span class="string">&quot;smith&quot;</span>);</span><br><span class="line">        HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">8</span>, <span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">10</span>, <span class="string">&quot;king&quot;</span>);</span><br><span class="line">        HeroNode node6 = <span class="keyword">new</span> HeroNode(<span class="number">14</span>, <span class="string">&quot;dim&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二叉树，后面我们要递归创建, 现在简单处理使用手动创建</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试中序线索化</span></span><br><span class="line">        ThreadedBinaryTree threadedBinaryTree = <span class="keyword">new</span> ThreadedBinaryTree();</span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNodes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试: 以10号节点测试</span></span><br><span class="line">        HeroNode leftNode = node5.getLeft();</span><br><span class="line">        HeroNode rightNode = node5.getRight();</span><br><span class="line">        System.out.println(<span class="string">&quot;10号结点的前驱结点是 =&quot;</span> + leftNode); <span class="comment">//3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;10号结点的后继结点是=&quot;</span> + rightNode); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        threadedBinaryTree.threadedList();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线索二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标识前一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode pre;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadedNodes(<span class="keyword">this</span>.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线索化遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HeroNode node = <span class="keyword">this</span>.root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//找到第一个节点</span></span><br><span class="line">            <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出当前节点</span></span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//替换node</span></span><br><span class="line">            node = node.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序线索化二叉树方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为是中序线索二叉树所以我们先进行左子树线索化</span></span><br><span class="line">        threadedNodes(node.getLeft());</span><br><span class="line">        <span class="comment">//线索化当前节点   设置前驱是在当前节点操作 设置后继是在pre操作</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//设置前驱为pre</span></span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            <span class="comment">//设置左节点的类型为前驱</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将node的值赋值给pre</span></span><br><span class="line">        pre = node;</span><br><span class="line">        <span class="comment">//线索化右子树</span></span><br><span class="line">        threadedNodes(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前根节点为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.midOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前根节点为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rearOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.rearOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前根节点为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.root.preOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">midOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.root.midOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">rearOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.root.rearOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.root.getNo() == no) &#123;</span><br><span class="line">                <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.root.delNode(no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前根节点为空，无法删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;</span><br><span class="line">    <span class="keyword">private</span> HeroNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标识左节点的类型是什么 0：左子树  1：前驱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标识右节点的类型是什么 0：右子树  1：后继</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历首先输出当前节点 再判断左节点、 右节点是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历首先判断左节点是否为空，再输出当前节点，再判断右节点是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.midOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.midOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序遍历首先判断左节点是否为空，再判断右节点是否为空，再输出当前节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rearOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.rearOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.rearOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找的编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 编号对应的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;查找！&quot;</span>);</span><br><span class="line">        <span class="comment">//首先先判断是否是当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断左子节点是否为空 如果不为空则左递归前序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果resNode不等于空了的话代表从左子节点递归中获得到了节点 就代表找到了no节点</span></span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断右子节点是否为空 如果不为空则右递归前序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时返回resNode 不管resNode是不是为空 因为所有节点已经遍历结束 如果最后返回为null代表没有找到该节点</span></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找的编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 编号对应的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">midOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断左子节点是否为空 如果不为空则左递归中序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.midOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果resNode不等于空了的话代表从左子节点递归中获得到了节点 就代表找到了no节点</span></span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;查找！&quot;</span>);</span><br><span class="line">        <span class="comment">//判断是否是当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断右子节点是否为空 如果不为空则右递归中序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.midOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时返回resNode 不管resNode是不是为空 因为所有节点已经遍历结束 如果最后返回为null代表没有找到该节点</span></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找的编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 编号对应的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">rearOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断左子节点是否为空 如果不为空则左递归后序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.midOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果resNode不等于空了的话代表从左子节点递归中获得到了节点 就代表找到了no节点</span></span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断右子节点是否为空 如果不为空则右递归后序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.midOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果resNode不等于空了的话代表从左子节点递归中获得到了节点 就代表找到了no节点</span></span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;查找！&quot;</span>);</span><br><span class="line">        <span class="comment">//判断是否是当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时返回resNode 不管resNode是不是为空 因为所有节点已经遍历结束 如果最后返回为null代表没有找到该节点</span></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 节点编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断</span></span><br><span class="line"><span class="comment">          当前这个结点是不是需要删除结点.</span></span><br><span class="line"><span class="comment">          2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将 this.left = null; 并且就返回</span></span><br><span class="line"><span class="comment">          (结束递归删除)</span></span><br><span class="line"><span class="comment">          3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将 this.right= null ;并且就返回</span></span><br><span class="line"><span class="comment">          (结束递归删除)</span></span><br><span class="line"><span class="comment">          4. 如果第 2 和第 3 步没有删除结点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">          5. 如果第 4 步也没有删除结点，则应当向右子树进行递归删除.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4遍历线索化二叉树"><a href="#3-4遍历线索化二叉树" class="headerlink" title="3.4遍历线索化二叉树"></a>3.4遍历线索化二叉树</h3><ol>
<li>说明：对前面的中序线索化的二叉树， 进行遍历</li>
<li>分析：因为线索化后，<strong>各个结点指向有变化，因此原来的遍历方式不能使用，</strong>这时需要使用新的方式遍历 线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。 遍历的次 序应当和中序遍历保持一致。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线索化遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HeroNode node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//找到第一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.getLeft();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出当前节点</span></span><br><span class="line">        System.out.println(node);</span><br><span class="line">        <span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">            node = node.getRight();</span><br><span class="line">            System.out.println(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//替换node</span></span><br><span class="line">        node = node.getRight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch学习笔记</title>
    <url>/2021/01/07/ElasticSearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ElasticSearch安装与介绍"><a href="#ElasticSearch安装与介绍" class="headerlink" title="ElasticSearch安装与介绍"></a>ElasticSearch安装与介绍</h1><h2 id="Elastic-Stack简介"><a href="#Elastic-Stack简介" class="headerlink" title="Elastic Stack简介"></a>Elastic Stack简介</h2><p>如果你没有听说过Elastic Stack，那你一定听说过ELK，实际上ELK是三款软件的简称，分别是Elasticsearch、<br>Logstash、Kibana组成，在发展的过程中，又有新成员Beats的加入，所以就形成了Elastic Stack。所以说，ELK是旧的称呼，Elastic Stack是新的名字。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095121.png" alt="image-20200922092403279"></p>
<p>全系的Elastic Stack技术栈包括：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095122.png" alt="image-20200922092505011"></p>
<h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><p>Elasticsearch 基于java，是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。</p>
<h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><p>Logstash 基于java，是一个开源的用于收集,分析和存储日志的工具。</p>
<h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><p>Kibana 基于nodejs，也是一个开源和免费的工具，Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的Web 界面，可以汇总、分析和搜索重要数据日志。</p>
<h3 id="Beats"><a href="#Beats" class="headerlink" title="Beats"></a>Beats</h3><p>Beats是elastic公司开源的一款采集系统监控数据的代理agent，是在被监控服务器上以客户端形式运行的数据收集器的统称，可以直接把数据发送给Elasticsearch或者通过Logstash发送给Elasticsearch，然后进行后续的数据分析活动。Beats由如下组成:</p>
<ul>
<li>Packetbeat：是一个网络数据包分析器，用于监控、收集网络流量信息，Packetbeat嗅探服务器之间的流量，解析应用层协议，并关联到消息的处理，其支 持ICMP (v4 and v6)、DNS、HTTP、Mysql、PostgreSQL、Redis、MongoDB、Memcache等协议；</li>
<li>Filebeat：用于监控、收集服务器日志文件，其已取代 logstash forwarder；</li>
<li>Metricbeat：可定期获取外部系统的监控指标信息，其可以监控、收集 Apache、HAProxy、MongoDB<br>MySQL、Nginx、PostgreSQL、Redis、System、Zookeeper等服务；</li>
</ul>
<blockquote>
<p>Beats和Logstash其实都可以进行数据的采集，但是目前主流的是使用Beats进行数据采集，然后使用 Logstash进行数据的分割处理等，早期没有Beats的时候，使用的就是Logstash进行数据的采集。</p>
</blockquote>
<h2 id="ElasticSearch快速入门"><a href="#ElasticSearch快速入门" class="headerlink" title="ElasticSearch快速入门"></a>ElasticSearch快速入门</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>官网：<a href="https://www.elastic.co/">https://www.elastic.co/</a></p>
<p>ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p>
<p>我们建立一个网站或应用程序，并要添加搜索功能，但是想要完成搜索工作的创建是非常困难的。我们希望搜索解决方案要运行速度快，我们希望能有一个零配置和一个完全免费的搜索模式，我们希望能够简单地使用JSON通过HTTP来索引数据，我们希望我们的搜索服务器始终可用，我们希望能够从一台开始并扩展到数百台，我们要实时搜索，我们要简单的多租户，我们希望建立一个云的解决方案。因此我们利用Elasticsearch来解决所有这些问题及可能出现的更多其它问题。</p>
<p>ElasticSearch是Elastic Stack的核心，同时Elasticsearch 是一个分布式、RESTful风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。作为Elastic Stack的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Elasticsearch的发展是非常快速的，所以在ES5.0之前，ELK的各个版本都不统一，出现了版本号混乱的状态，所以从5.0开始，所有Elastic Stack中的项目全部统一版本号。目前最新版本是6.5.4，我们将基于这一版本进行学习。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095123.png" alt="image-20200922093432839"></p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>到官网下载：<a href="https://www.elastic.co/cn/downloads/">https://www.elastic.co/cn/downloads/</a></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095124.png" alt="image-20200922094003384"></p>
<p>选择对应版本的数据，这里我使用的是Linux来进行安装，所以就先下载好ElasticSearch的Linux安装包</p>
<h3 id="拉取Docker容器"><a href="#拉取Docker容器" class="headerlink" title="拉取Docker容器"></a>拉取Docker容器</h3><p>因为我们需要部署在Linux下，为了以后迁移ElasticStack环境方便，我们就使用Docker来进行部署，首先我们拉取一个带有ssh的centos docker镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">docker pull moxi/centos_ssh</span><br><span class="line"><span class="comment"># 制作容器</span></span><br><span class="line">docker run --privileged -d -it -h ElasticStack --name ElasticStack -p 11122:22 -p 9200:9200 -p 5601:5601 -p 9300:9300 -v /etc/localtime:/etc/localtime:ro  moxi/centos_ssh /usr/sbin/init</span><br></pre></td></tr></table></figure>
<p>然后直接远程连接11122端口即可</p>
<h3 id="单机版安装"><a href="#单机版安装" class="headerlink" title="单机版安装"></a>单机版安装</h3><p>因为ElasticSearch不支持Root用户直接操作，因此我们需要创建一个elsearch用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加新用户</span></span><br><span class="line">useradd elsearch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个soft目录，存放下载的软件</span></span><br><span class="line">mkdir /soft</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入，然后通过xftp工具，将刚刚下载的文件拖动到该目录下</span></span><br><span class="line"><span class="built_in">cd</span> /soft</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩</span></span><br><span class="line">tar -zxvf elasticsearch-7.9.1-linux-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#重命名</span></span><br><span class="line">mv elasticsearch-7.9.1/ elsearch</span><br></pre></td></tr></table></figure>
<p>因为刚刚我们是使用root用户操作的，所以我们还需要更改一下/soft文件夹的所属，改为elsearch用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown elsearch:elsearch /soft/ -R</span><br></pre></td></tr></table></figure>
<p>然后在切换成elsearch用户进行操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line">su - elsearch</span><br></pre></td></tr></table></figure>
<p>然后我们就可以对我们的配置文件进行修改了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入到 elsearch下的config目录</span></span><br><span class="line"><span class="built_in">cd</span> /soft/elsearch/config</span><br></pre></td></tr></table></figure>
<p>然后找到下面的配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开配置文件</span></span><br><span class="line"><span class="string">vim</span> <span class="string">elasticsearch.yml</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#设置ip地址，任意网络均可访问</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> </span><br></pre></td></tr></table></figure>
<p>在Elasticsearch中如果，network.host不是localhost或者127.0.0.1的话，就会认为是生产环境，会对环境的要求比较高，我们的测试环境不一定能够满足，一般情况下需要修改2处配置，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改jvm启动参数</span></span><br><span class="line">vim conf/jvm.options</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据自己机器情况修改</span></span><br><span class="line">-Xms128m </span><br><span class="line">-Xmx128m</span><br></pre></td></tr></table></figure>
<p>然后在修改第二处的配置，这个配置要求我们到宿主机器上来进行配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 到宿主机上打开文件</span></span><br><span class="line">vim /etc/sysctl.conf</span><br><span class="line"><span class="comment"># 增加这样一条配置，一个进程在VMAs(虚拟内存区域)创建内存映射最大数量</span></span><br><span class="line">vm.max_map_count=655360</span><br><span class="line"><span class="comment"># 让配置生效</span></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<h3 id="启动ElasticSearch"><a href="#启动ElasticSearch" class="headerlink" title="启动ElasticSearch"></a>启动ElasticSearch</h3><p>首先我们需要切换到 elsearch用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - elsearch</span><br></pre></td></tr></table></figure>
<p>然后在到bin目录下，执行下面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入bin目录</span></span><br><span class="line"><span class="built_in">cd</span> /soft/elsearch/bin</span><br><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">./elasticsearch -d</span><br></pre></td></tr></table></figure>
<p>启动成功后，访问下面的URL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://202.193.56.222:9200/</span><br></pre></td></tr></table></figure>
<p>如果出现了下面的信息，就表示已经成功启动了</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095125.png" alt="image-20200922150758205"></p>
<p>如果你在启动的时候，遇到过问题，那么请参考下面的错误分析~</p>
<h2 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h2><h3 id="错误情况1"><a href="#错误情况1" class="headerlink" title="错误情况1"></a>错误情况1</h3><p>如果出现下面的错误信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.RuntimeException: can not run elasticsearch as root</span><br><span class="line">	at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:111)</span><br><span class="line">	at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:178)</span><br><span class="line">	at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:393)</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:170)</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:161)</span><br><span class="line">	at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:86)</span><br><span class="line">	at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:127)</span><br><span class="line">	at org.elasticsearch.cli.Command.main(Command.java:90)</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:126)</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:92)</span><br><span class="line">For complete error details, refer to the log at &#x2F;soft&#x2F;elsearch&#x2F;logs&#x2F;elasticsearch.log</span><br><span class="line">[root@e588039bc613 bin]# 2020-09-22 02:59:39,537121 UTC [536] ERROR CLogger.cc@310 Cannot log to named pipe &#x2F;tmp&#x2F;elasticsearch-5834501324803693929&#x2F;controller_log_381 as it could not be opened for writing</span><br><span class="line">2020-09-22 02:59:39,537263 UTC [536] INFO  Main.cc@103 Parent process died - ML controller exiting</span><br></pre></td></tr></table></figure>
<p>就说明你没有切换成 elsearch用户，因为不能使用root操作es</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - elsearch</span><br></pre></td></tr></table></figure>
<h3 id="错误情况2"><a href="#错误情况2" class="headerlink" title="错误情况2"></a>错误情况2</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[1]:max file descriptors [4096] <span class="keyword">for</span> elasticsearch process is too low, increase to at least[65536]</span><br></pre></td></tr></table></figure>
<p>解决方法：切换到root用户，编辑limits.conf添加如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/security/limits.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># ElasticSearch添加如下内容:</span></span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 131072</span><br><span class="line">* soft nproc 2048</span><br><span class="line">* hard nproc 4096</span><br></pre></td></tr></table></figure>
<h3 id="错误情况3"><a href="#错误情况3" class="headerlink" title="错误情况3"></a>错误情况3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2]: max number of threads [1024] <span class="keyword">for</span> user [elsearch] is too low, increase to at least</span><br><span class="line">[4096]</span><br></pre></td></tr></table></figure>
<p>也就是最大线程数设置的太低了，需要改成4096</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解决：切换到root用户，进入limits.d目录下修改配置文件。</span></span><br><span class="line">vi /etc/security/limits.d/90-nproc.conf</span><br><span class="line"><span class="comment">#修改如下内容：</span></span><br><span class="line">* soft nproc 1024</span><br><span class="line"><span class="comment">#修改为</span></span><br><span class="line">* soft nproc 4096</span><br></pre></td></tr></table></figure>
<h3 id="错误情况4"><a href="#错误情况4" class="headerlink" title="错误情况4"></a>错误情况4</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[3]: system call filters failed to install; check the logs and fix your configuration</span><br><span class="line">or <span class="built_in">disable</span> system call filters at your own risk</span><br></pre></td></tr></table></figure>
<p>解决：Centos6不支持SecComp，而ES5.2.0默认bootstrap.system_call_filter为true</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim config/elasticsearch.yml</span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line">bootstrap.system_call_filter: <span class="literal">false</span></span><br><span class="line">bootstrap.memory_lock: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="错误情况5"><a href="#错误情况5" class="headerlink" title="错误情况5"></a>错误情况5</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[elsearch@e588039bc613 bin]$ Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> org.elasticsearch.bootstrap.BootstrapException: java.nio.file.AccessDeniedException: /soft/elsearch/config/elasticsearch.keystore</span><br><span class="line">Likely root cause: java.nio.file.AccessDeniedException: /soft/elsearch/config/elasticsearch.keystore</span><br><span class="line">	at java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:90)</span><br><span class="line">	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)</span><br><span class="line">	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116)</span><br><span class="line">	at java.base/sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:219)</span><br><span class="line">	at java.base/java.nio.file.Files.newByteChannel(Files.java:375)</span><br><span class="line">	at java.base/java.nio.file.Files.newByteChannel(Files.java:426)</span><br><span class="line">	at org.apache.lucene.store.SimpleFSDirectory.openInput(SimpleFSDirectory.java:79)</span><br><span class="line">	at org.elasticsearch.common.settings.KeyStoreWrapper.load(KeyStoreWrapper.java:220)</span><br><span class="line">	at org.elasticsearch.bootstrap.Bootstrap.loadSecureSettings(Bootstrap.java:240)</span><br><span class="line">	at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:349)</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:170)</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:161)</span><br><span class="line">	at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:86)</span><br><span class="line">	at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:127)</span><br><span class="line">	at org.elasticsearch.cli.Command.main(Command.java:90)</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:126)</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:92)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们通过排查，发现是因为 /soft/elsearch/config/elasticsearch.keystore 存在问题</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095126.png" alt="image-20200922111823740"></p>
<p>也就是说该文件还是所属于root用户，而我们使用elsearch用户无法操作，所以需要把它变成elsearch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown elsearch:elsearch elasticsearch.keystore</span><br></pre></td></tr></table></figure>
<h3 id="错误情况6"><a href="#错误情况6" class="headerlink" title="错误情况6"></a>错误情况6</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[1]: the default discovery settings are unsuitable <span class="keyword">for</span> production use; at least one of [discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes] must be configured</span><br><span class="line">ERROR: Elasticsearch did not <span class="built_in">exit</span> normally - check the logs at /soft/elsearch/logs/elasticsearch.log</span><br></pre></td></tr></table></figure>
<p>继续修改配置 elasticsearch.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取消注释，并保留一个节点</span></span><br><span class="line">node.name: node-1</span><br><span class="line">cluster.initial_master_nodes: [<span class="string">&quot;node-1&quot;</span>]</span><br></pre></td></tr></table></figure>


<h2 id="ElasticSearchHead可视化工具"><a href="#ElasticSearchHead可视化工具" class="headerlink" title="ElasticSearchHead可视化工具"></a>ElasticSearchHead可视化工具</h2><p>由于ES官方没有给ES提供可视化管理工具，仅仅是提供了后台的服务，elasticsearch-head是一个为ES开发的一个页面客户端工具，其源码托管于Github，地址为 <a href="https://github.com/mobz/elasticsearch-head">传送门</a></p>
<p>head提供了以下安装方式</p>
<ul>
<li>源码安装，通过npm run start启动（不推荐）</li>
<li>通过docker安装（推荐）</li>
<li>通过chrome插件安装（推荐）</li>
<li>通过ES的plugin方式安装（不推荐）</li>
</ul>
<h3 id="通过Docker方式安装"><a href="#通过Docker方式安装" class="headerlink" title="通过Docker方式安装"></a>通过Docker方式安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#拉取镜像</span></span><br><span class="line">docker pull mobz/elasticsearch-head:5</span><br><span class="line"><span class="comment">#创建容器</span></span><br><span class="line">docker create --name elasticsearch-head -p 9100:9100 mobz/elasticsearch-head:5</span><br><span class="line"><span class="comment">#启动容器</span></span><br><span class="line">docker start elasticsearch-head</span><br></pre></td></tr></table></figure>
<p>通过浏览器进行访问：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095127.png" alt="image-20200922151529269"></p>
<p>注意：<br>由于前后端分离开发，所以会存在跨域问题，需要在服务端做CORS的配置，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim elasticsearch.yml</span><br><span class="line"></span><br><span class="line">http.cors.enabled: <span class="literal">true</span> http.cors.allow-origin: <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过chrome插件的方式安装不存在该问题</p>
<h3 id="通过Chrome插件安装"><a href="#通过Chrome插件安装" class="headerlink" title="通过Chrome插件安装"></a>通过Chrome插件安装</h3><p>打开chrome的应用商店，即可安装 <a href="https://chrome.google.com/webstore/detail/elasticsearch-head/ffmkiejjmecolpfloofpjologoblkegm">https://chrome.google.com/webstore/detail/elasticsearch-head/ffmkiejjmecolpfloofpjologoblkegm</a></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095128.png" alt="image-20200922152428838"></p>
<p>我们也可以新建索引</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095129.png" alt="image-20200922152534471"></p>
<p>建议：推荐使用chrome插件的方式安装，如果网络环境不允许，就采用其它方式安装。</p>
<h2 id="ElasticSearch中的基本概念"><a href="#ElasticSearch中的基本概念" class="headerlink" title="ElasticSearch中的基本概念"></a>ElasticSearch中的基本概念</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul>
<li>索引（index）是Elasticsearch对逻辑数据的逻辑存储，所以它可以分为更小的部分。</li>
<li>可以把索引看成关系型数据库的表，索引的结构是为快速有效的全文索引准备的，特别是它不存储原始值。</li>
<li>Elasticsearch可以把索引存放在一台机器或者分散在多台服务器上，每个索引有一或多个分片（shard），每个分片可以有多个副本（replica）。</li>
</ul>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul>
<li>存储在Elasticsearch中的主要实体叫文档（document）。用关系型数据库来类比的话，一个文档相当于数据库表中的一行记录。</li>
<li>Elasticsearch和MongoDB中的文档类似，都可以有不同的结构，但Elasticsearch的文档中，相同字段必须有相同类型。</li>
<li>文档由多个字段组成，每个字段可能多次出现在一个文档里，这样的字段叫多值字段（multivalued）。<br>每个字段的类型，可以是文本、数值、日期等。字段类型也可以是复杂类型，一个字段包含其他子文档或者数<br>组。</li>
</ul>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>所有文档写进索引之前都会先进行分析，如何将输入的文本分割为词条、哪些词条又会被过滤，这种行为叫做<br>映射（mapping）。一般由用户自己定义规则。</p>
<h3 id="文档类型"><a href="#文档类型" class="headerlink" title="文档类型"></a>文档类型</h3><ul>
<li>在Elasticsearch中，一个索引对象可以存储很多不同用途的对象。例如，一个博客应用程序可以保存文章和评<br>论。</li>
<li>每个文档可以有不同的结构。</li>
<li>不同的文档类型不能为相同的属性设置不同的类型。例如，在同一索引中的所有文档类型中，一个叫title的字段必须具有相同的类型。</li>
</ul>
<h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><p>在Elasticsearch中，提供了功能丰富的RESTful API的操作，包括基本的CRUD、创建索引、删除索引等操作。</p>
<h3 id="创建非结构化索引"><a href="#创建非结构化索引" class="headerlink" title="创建非结构化索引"></a>创建非结构化索引</h3><p>在Lucene中，创建索引是需要定义字段名称以及字段的类型的，在Elasticsearch中提供了非结构化的索引，就是不需要创建索引结构，即可写入数据到索引中，实际上在Elasticsearch底层会进行结构化操作，此操作对用户是透明的。</p>
<h3 id="创建空索引"><a href="#创建空索引" class="headerlink" title="创建空索引"></a>创建空索引</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT /haoke</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;index&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;number_of_shards&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="comment">#分片数</span></span><br><span class="line">        <span class="string">&quot;number_of_replicas&quot;</span>: <span class="string">&quot;0&quot;</span> <span class="comment">#副本数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除索引</span></span><br><span class="line">DELETE /haoke</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;acknowledged&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><blockquote>
<p>URL规则：<br>POST /{索引}/{类型}/{id}</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /haoke/user/1001</span><br><span class="line"><span class="comment">#数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;id&quot;</span>:1001,</span><br><span class="line"><span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>:20,</span><br><span class="line"><span class="string">&quot;sex&quot;</span>:<span class="string">&quot;男&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用postman操作成功后</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095130.png" alt="image-20200922155642306"></p>
<p>我们通过ElasticSearchHead进行数据预览就能够看到我们刚刚插入的数据了</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095131.png" alt="image-20200922155843314"></p>
<p>说明：非结构化的索引，不需要事先创建，直接插入数据默认创建索引。不指定id插入数据：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095132.png" alt="image-20200922155935366"></p>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>在Elasticsearch中，文档数据是不为修改的，但是可以通过覆盖的方式进行更新。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT /haoke/user/1001</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;id&quot;</span>:1001,</span><br><span class="line"><span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>:21,</span><br><span class="line"><span class="string">&quot;sex&quot;</span>:<span class="string">&quot;女&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新结果如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095133.png" alt="image-20200922160154599"></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095134.png" alt="image-20200922160201130"></p>
<p>可以看到数据已经被覆盖了。问题来了，可以局部更新吗？ – 可以的。前面不是说，文档数据不能更新吗？ 其实是这样的：在内部，依然会查询到这个文档数据，然后进行覆盖操作，步骤如下：</p>
<ol>
<li>从旧文档中检索JSON</li>
<li>修改它</li>
<li>删除旧文档</li>
<li>索引新文档</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意：这里多了_update标识</span></span><br><span class="line">POST /haoke/user/1001/_update</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;age&quot;</span>:23</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095135.png" alt="image-20200922160709463"></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095136.png" alt="image-20200922160717001"></p>
<p>可以看到，数据已经是局部更新了</p>
<h3 id="删除索引-1"><a href="#删除索引-1" class="headerlink" title="删除索引"></a>删除索引</h3><p>在Elasticsearch中，删除文档数据，只需要发起DELETE请求即可，不用额外的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DELETE 1 /haoke/user/1001</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095137.png" alt="image-20200922160752862"></p>
<p>需要注意的是，result表示已经删除，version也增加了。</p>
<p>如果删除一条不存在的数据，会响应404</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095138.png" alt="image-20200922161627716"></p>
<blockquote>
<p>删除一个文档也不会立即从磁盘上移除，它只是被标记成已删除。Elasticsearch将会在你之后添加更多索引的时候才会在后台进行删除内容的清理。【相当于批量操作】</p>
</blockquote>
<h3 id="搜索数据"><a href="#搜索数据" class="headerlink" title="搜索数据"></a>搜索数据</h3><h4 id="根据id搜索数据"><a href="#根据id搜索数据" class="headerlink" title="根据id搜索数据"></a>根据id搜索数据</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /haoke/user/BbPe_WcB9cFOnF3uebvr</span><br><span class="line"><span class="comment">#返回的数据如下</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;haoke&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_type&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;BbPe_WcB9cFOnF3uebvr&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_version&quot;</span>: 8,</span><br><span class="line">    <span class="string">&quot;found&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;_source&quot;</span>: &#123; <span class="comment">#原始数据在这里</span></span><br><span class="line">        <span class="string">&quot;id&quot;</span>: 1002,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: 40,</span><br><span class="line">        <span class="string">&quot;sex&quot;</span>: <span class="string">&quot;男&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="搜索全部数据"><a href="#搜索全部数据" class="headerlink" title="搜索全部数据"></a>搜索全部数据</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET 1 /haoke/user/_search</span><br></pre></td></tr></table></figure>
<p>注意，使用查询全部数据的时候，默认只会返回10条</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095139.png" alt="image-20200922162228822"></p>
<h4 id="关键字搜索数据"><a href="#关键字搜索数据" class="headerlink" title="关键字搜索数据"></a>关键字搜索数据</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询年龄等于20的用户</span></span><br><span class="line">GET /haoke/user/_search?q=age:20</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095140.png" alt="image-20200922162309797"></p>
<h3 id="DSL搜索"><a href="#DSL搜索" class="headerlink" title="DSL搜索"></a>DSL搜索</h3><p>Elasticsearch提供丰富且灵活的查询语言叫做DSL查询(Query DSL),它允许你构建更加复杂、强大的查询。<br>DSL(Domain Specific Language特定领域语言)以JSON请求体的形式出现。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /haoke/user/_search</span><br><span class="line"><span class="comment">#请求体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span> : &#123;</span><br><span class="line">        <span class="string">&quot;match&quot;</span> : &#123; <span class="comment">#match只是查询的一种</span></span><br><span class="line">        	<span class="string">&quot;age&quot;</span> : 20</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现：查询年龄大于30岁的男性用户。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095141.png" alt="image-20200922162943539"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /haoke/user/_search</span><br><span class="line"><span class="comment">#请求数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;filter&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;range&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;age&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;gt&quot;</span>: 30</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;must&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">                	<span class="string">&quot;sex&quot;</span>: <span class="string">&quot;男&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询出来的结果</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095142.png" alt="image-20200922163109515"></p>
<h4 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /haoke/user/_search</span><br><span class="line"><span class="comment">#请求数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">        	<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三 李四&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095143.png" alt="image-20200922163315285"></p>
<p>高亮显示，只需要在添加一个 highlight即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /haoke/user/_search</span><br><span class="line"><span class="comment">#请求数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">        	<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三 李四&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">        	<span class="string">&quot;name&quot;</span>: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095144.png" alt="image-20200922163432853"></p>
<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>在Elasticsearch中，支持聚合操作，类似SQL中的group by操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /haoke/user/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;all_interests&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;field&quot;</span>: <span class="string">&quot;age&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下，我们通过年龄进行聚合</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095145.png" alt="image-20200922163614708"></p>
<p>从结果可以看出，年龄30的有2条数据，20的有一条，40的一条。</p>
<h2 id="ElasticSearch核心详解"><a href="#ElasticSearch核心详解" class="headerlink" title="ElasticSearch核心详解"></a>ElasticSearch核心详解</h2><h3 id="文档-1"><a href="#文档-1" class="headerlink" title="文档"></a>文档</h3><p>在Elasticsearch中，文档以JSON格式进行存储，可以是复杂的结构，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;haoke&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_type&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;1005&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_version&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;_score&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: 1005,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;孙七&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: 37,</span><br><span class="line">        <span class="string">&quot;sex&quot;</span>: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">        <span class="string">&quot;card&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;card_number&quot;</span>: <span class="string">&quot;123456789&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，card是一个复杂对象，嵌套的Card对象</p>
<h4 id="元数据（metadata）"><a href="#元数据（metadata）" class="headerlink" title="元数据（metadata）"></a>元数据（metadata）</h4><p>一个文档不只有数据。它还包含了元数据(metadata)——关于文档的信息。三个必须的元数据节点是：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095146.png" alt="image-20200922165956176"></p>
<h4 id="index"><a href="#index" class="headerlink" title="index"></a>index</h4><p>索引(index)类似于关系型数据库里的“数据库”——它是我们存储和索引关联数据的地方。</p>
<blockquote>
<p>提示：事实上，我们的数据被存储和索引在分片(shards)中，索引只是一个把一个或多个分片分组在一起的逻辑空间。然而，这只是一些内部细节——我们的程序完全不用关心分片。对于我们的程序而言，文档存储在索引(index)中。剩下的细节由Elasticsearch关心既可。</p>
</blockquote>
<h4 id="type"><a href="#type" class="headerlink" title="_type"></a>_type</h4><p>在应用中，我们使用对象表示一些“事物”，例如一个用户、一篇博客、一个评论，或者一封邮件。每个对象都属于一个类(class)，这个类定义了属性或与对象关联的数据。user 类的对象可能包含姓名、性别、年龄和Email地址。<br>在关系型数据库中，我们经常将相同类的对象存储在一个表里，因为它们有着相同的结构。同理，在Elasticsearch<br>中，我们使用相同类型(type)的文档表示相同的“事物”，因为他们的数据结构也是相同的。</p>
<p>每个类型(type)都有自己的映射(mapping)或者结构定义，就像传统数据库表中的列一样。所有类型下的文档被存储在同一个索引下，但是类型的映射(mapping)会告诉Elasticsearch不同的文档如何被索引。</p>
<p>_type 的名字可以是大写或小写，不能包含下划线或逗号。我们将使用blog 做为类型名。</p>
<h4 id="id"><a href="#id" class="headerlink" title="_id"></a>_id</h4><p>id仅仅是一个字符串，它与_index 和_type 组合时，就可以在Elasticsearch中唯一标识一个文档。当创建一个文<br>档，你可以自定义_id ，也可以让Elasticsearch帮你自动生成（32位长度）</p>
<h3 id="查询响应"><a href="#查询响应" class="headerlink" title="查询响应"></a>查询响应</h3><h4 id="pretty"><a href="#pretty" class="headerlink" title="pretty"></a>pretty</h4><p>可以在查询url后面添加pretty参数，使得返回的json更易查看。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095147.png" alt="image-20200923101056932"></p>
<h4 id="指定响应字段"><a href="#指定响应字段" class="headerlink" title="指定响应字段"></a>指定响应字段</h4><p>在响应的数据中，如果我们不需要全部的字段，可以指定某些需要的字段进行返回。通过添加 _source</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /haoke/user/1005?_source=id,name</span><br><span class="line"><span class="comment">#响应</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;haoke&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_type&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;1005&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_version&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;found&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;孙七&quot;</span>,</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: 1005</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如不需要返回元数据，仅仅返回原始数据，可以这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /haoke/1 user/1005/_source</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095148.png" alt="image-20200923101239226"></p>
<p>还可以这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /haoke/user/1005/_source?_1 <span class="built_in">source</span>=id,name</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095149.png" alt="image-20200923101319728"></p>
<h4 id="判断文档是否存在"><a href="#判断文档是否存在" class="headerlink" title="判断文档是否存在"></a>判断文档是否存在</h4><p>如果我们只需要判断文档是否存在，而不是查询文档内容，那么可以这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HEAD /haoke/user/1005</span><br></pre></td></tr></table></figure>
<p>通过发送一个head请求，来判断数据是否存在</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095150.png" alt="image-20200923101354992"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HEAD 1 /haoke/user/1006</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095151.png" alt="image-20200923101433608"></p>
<blockquote>
<p>当然，这只表示你在查询的那一刻文档不存在，但并不表示几毫秒后依旧不存在。另一个进程在这期间可能创建新文档。</p>
</blockquote>
<h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><p>有些情况下可以通过批量操作以减少网络请求。如：批量查询、批量插入数据。</p>
<h4 id="批量查询"><a href="#批量查询" class="headerlink" title="批量查询"></a>批量查询</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /haoke/user/_mget</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;ids&quot;</span> : [ <span class="string">&quot;1001&quot;</span>, <span class="string">&quot;1003&quot;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095152.png" alt="image-20200923101540616"></p>
<p>如果，某一条数据不存在，不影响整体响应，需要通过found的值进行判断是否查询到数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /haoke/user/_mget</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;ids&quot;</span> : [ <span class="string">&quot;1001&quot;</span>, <span class="string">&quot;1006&quot;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095153.png" alt="image-20200923101721344"></p>
<blockquote>
<p>也就是说，一个数据的存在不会影响其它数据的返回</p>
</blockquote>
<h4 id="bulk操作"><a href="#bulk操作" class="headerlink" title="_bulk操作"></a>_bulk操作</h4><p>在Elasticsearch中，支持批量的插入、修改、删除操作，都是通过_bulk的api完成的。</p>
<p>请求格式如下：（请求格式不同寻常）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; action: &#123; metadata &#125;&#125;</span><br><span class="line">&#123; request body &#125;</span><br><span class="line">&#123; action: &#123; metadata &#125;&#125;</span><br><span class="line">&#123; request body &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>批量插入数据： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;create&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;haoke&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;user&quot;</span>,<span class="string">&quot;_id&quot;</span>:2001&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:2001,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;name1&quot;</span>,<span class="string">&quot;age&quot;</span>: 20,<span class="string">&quot;sex&quot;</span>: <span class="string">&quot;男&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;create&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;haoke&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;user&quot;</span>,<span class="string">&quot;_id&quot;</span>:2002&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:2002,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;name2&quot;</span>,<span class="string">&quot;age&quot;</span>: 20,<span class="string">&quot;sex&quot;</span>: <span class="string">&quot;男&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;create&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;haoke&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;user&quot;</span>,<span class="string">&quot;_id&quot;</span>:2003&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:2003,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;name3&quot;</span>,<span class="string">&quot;age&quot;</span>: 20,<span class="string">&quot;sex&quot;</span>: <span class="string">&quot;男&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>注意最后一行的回车。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095154.png" alt="image-20200923101946147"></p>
<p>批量删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;delete&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;haoke&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;user&quot;</span>,<span class="string">&quot;_id&quot;</span>:2001&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;delete&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;haoke&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;user&quot;</span>,<span class="string">&quot;_id&quot;</span>:2002&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;delete&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;haoke&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;user&quot;</span>,<span class="string">&quot;_id&quot;</span>:2003&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>由于delete没有请求体，所以，action的下一行直接就是下一个action。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095155.png" alt="image-20200923102044231"></p>
<p>其他操作就类似了。一次请求多少性能最高？</p>
<ul>
<li>整个批量请求需要被加载到接受我们请求节点的内存里，所以请求越大，给其它请求可用的内存就越小。有一<br>个最佳的bulk请求大小。超过这个大小，性能不再提升而且可能降低。</li>
<li>最佳大小，当然并不是一个固定的数字。它完全取决于你的硬件、你文档的大小和复杂度以及索引和搜索的负<br>载。</li>
<li>幸运的是，这个最佳点(sweetspot)还是容易找到的：试着批量索引标准的文档，随着大小的增长，当性能开始<br>降低，说明你每个批次的大小太大了。开始的数量可以在1000~5000个文档之间，如果你的文档非常大，可以使用较小的批次。</li>
<li>通常着眼于你请求批次的物理大小是非常有用的。一千个1kB的文档和一千个1MB的文档大不相同。一个好的<br>批次最好保持在5-15MB大小间。</li>
</ul>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>和SQL使用LIMIT 关键字返回只有一页的结果一样，Elasticsearch接受from 和size 参数：</p>
<ul>
<li>size: 结果数，默认10</li>
<li>from: 跳过开始的结果数，默认0</li>
</ul>
<p>如果你想每页显示5个结果，页码从1到3，那请求如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /_search?size=5</span><br><span class="line">GET /_search?size=5&amp;from=5</span><br><span class="line">GET /_search?size=5&amp;from=10</span><br></pre></td></tr></table></figure>
<p>应该当心分页太深或者一次请求太多的结果。结果在返回前会被排序。但是记住一个搜索请求常常涉及多个分<br>片。每个分片生成自己排好序的结果，它们接着需要集中起来排序以确保整体排序正确。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /haoke/user/_1 search?size=1&amp;from=2</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095156.png" alt="image-20200923102611567"></p>
<h4 id="在集群系统中深度分页"><a href="#在集群系统中深度分页" class="headerlink" title="在集群系统中深度分页"></a>在集群系统中深度分页</h4><p>为了理解为什么深度分页是有问题的，让我们假设在一个有5个主分片的索引中搜索。当我们请求结果的第一<br>页（结果1到10）时，每个分片产生自己最顶端10个结果然后返回它们给请求节点(requesting node)，它再<br>排序这所有的50个结果以选出顶端的10个结果。</p>
<p>现在假设我们请求第1000页——结果10001到10010。工作方式都相同，不同的是每个分片都必须产生顶端的<br>10010个结果。然后请求节点排序这50050个结果并丢弃50040个！</p>
<p>你可以看到在分布式系统中，排序结果的花费随着分页的深入而成倍增长。这也是为什么网络搜索引擎中任何<br>语句不能返回多于1000个结果的原因。</p>
<h3 id="映射-1"><a href="#映射-1" class="headerlink" title="映射"></a>映射</h3><p>前面我们创建的索引以及插入数据，都是由Elasticsearch进行自动判断类型，有些时候我们是需要进行明确字段类型的，否则，自动判断的类型和实际需求是不相符的。</p>
<p>自动判断的规则如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095157.png" alt="image-20200923103848097"></p>
<p>Elasticsearch中支持的类型如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095158.png" alt="image-20200923103917807"></p>
<ul>
<li>string类型在ElasticSearch 旧版本中使用较多，从ElasticSearch 5.x开始不再支持string，由text和<br>keyword类型替代。</li>
<li>text 类型，当一个字段是要被全文搜索的，比如Email内容、产品描述，应该使用text类型。设置text类型<br>以后，字段内容会被分析，在生成倒排索引以前，字符串会被分析器分成一个一个词项。text类型的字段<br>不用于排序，很少用于聚合。</li>
<li>keyword类型适用于索引结构化的字段，比如email地址、主机名、状态码和标签。如果字段需要进行过<br>滤(比如查找已发布博客中status属性为published的文章)、排序、聚合。keyword类型的字段只能通过精<br>确值搜索到。</li>
</ul>
<h4 id="创建明确类型的索引："><a href="#创建明确类型的索引：" class="headerlink" title="创建明确类型的索引："></a>创建明确类型的索引：</h4><blockquote>
<p> 如果你要像之前旧版版本一样兼容自定义 type ,需要将 *<em>i*</em>nclude_type_name=true 携带</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">put http://202.193.56.222:9200/itcast?include_type_name=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;settings&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;index&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;number_of_shards&quot;</span>:<span class="string">&quot;2&quot;</span>,</span><br><span class="line">            <span class="string">&quot;number_of_replicas&quot;</span>:<span class="string">&quot;0&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;person&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>:&#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;age&quot;</span>:&#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;integer&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;mail&quot;</span>:&#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;hobby&quot;</span>:&#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看映射</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /itcast/_mapping</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095159.png" alt="image-20200923104201613"></p>
<p>插入数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /itcast/_bulk</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;itcast&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>: 20,<span class="string">&quot;mail&quot;</span>: <span class="string">&quot;111@qq.com&quot;</span>,<span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;羽毛球、乒乓球、足球&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;itcast&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;age&quot;</span>: 21,<span class="string">&quot;mail&quot;</span>: <span class="string">&quot;222@qq.com&quot;</span>,<span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;羽毛球、乒乓球、足球、篮球&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;itcast&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;age&quot;</span>: 22,<span class="string">&quot;mail&quot;</span>: <span class="string">&quot;333@qq.com&quot;</span>,<span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;羽毛球、篮球、游泳、听音乐&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;itcast&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;赵六&quot;</span>,<span class="string">&quot;age&quot;</span>: 23,<span class="string">&quot;mail&quot;</span>: <span class="string">&quot;444@qq.com&quot;</span>,<span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;跑步、游泳&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;itcast&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;孙七&quot;</span>,<span class="string">&quot;age&quot;</span>: 24,<span class="string">&quot;mail&quot;</span>: <span class="string">&quot;555@qq.com&quot;</span>,<span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;听音乐、看电影&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095200.png" alt="image-20200923104551405"></p>
<h4 id="测试搜索"><a href="#测试搜索" class="headerlink" title="测试搜索"></a>测试搜索</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /itcast/person/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;音乐&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095201.png" alt="image-20200923104653427"></p>
<h3 id="结构化查询"><a href="#结构化查询" class="headerlink" title="结构化查询"></a>结构化查询</h3><h4 id="term查询"><a href="#term查询" class="headerlink" title="term查询"></a>term查询</h4><p>term 主要用于精确匹配哪些值，比如数字，日期，布尔值或 not_analyzed 的字符串(未经分析的文本数据类型)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123; <span class="string">&quot;term&quot;</span>: &#123; <span class="string">&quot;age&quot;</span>: 26 &#125;&#125;</span><br><span class="line">&#123; <span class="string">&quot;term&quot;</span>: &#123; <span class="string">&quot;date&quot;</span>: <span class="string">&quot;2014-09-01&quot;</span> &#125;&#125;</span><br><span class="line">&#123; <span class="string">&quot;term&quot;</span>: &#123; <span class="string">&quot;public&quot;</span>: <span class="literal">true</span> &#125;&#125;</span><br><span class="line">&#123; <span class="string">&quot;term&quot;</span>: &#123; <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;full_text&quot;</span> &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /itcast/person/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;term&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;age&quot;</span>:20</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095202.png" alt="image-20200923104851159"></p>
<h4 id="terms查询"><a href="#terms查询" class="headerlink" title="terms查询"></a>terms查询</h4><p>terms 跟 term 有点类似，但 terms 允许指定多个匹配条件。 如果某个字段指定了多个值，那么文档需要一起去<br>做匹配：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;terms&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;tag&quot;</span>:[</span><br><span class="line">            <span class="string">&quot;search&quot;</span>,</span><br><span class="line">            <span class="string">&quot;full_text&quot;</span>,</span><br><span class="line">            <span class="string">&quot;nosql&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /itcast/person/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;terms&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;age&quot;</span>:[</span><br><span class="line">                20,</span><br><span class="line">                21</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095203.png" alt="image-20200923105030182"></p>
<h4 id="range查询"><a href="#range查询" class="headerlink" title="range查询"></a>range查询</h4><p>range 过滤允许我们按照指定范围查找一批数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;range&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;age&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;gte&quot;</span>:20,</span><br><span class="line">            <span class="string">&quot;lt&quot;</span>:30</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>范围操作符包含：</p>
<ul>
<li>gt : 大于</li>
<li>gte:: 大于等于</li>
<li>lt : 小于</li>
<li>lte: 小于等于</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /itcast/person/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;range&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;age&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;gte&quot;</span>:20,</span><br><span class="line">                <span class="string">&quot;lte&quot;</span>:22</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exists-查询"><a href="#exists-查询" class="headerlink" title="exists 查询"></a>exists 查询</h4><p>exists 查询可以用于查找文档中是否包含指定字段或没有某个字段，类似于SQL语句中的IS_NULL 条件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;exists&quot;</span>: &#123;</span><br><span class="line">    	<span class="string">&quot;field&quot;</span>: <span class="string">&quot;title&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个查询只是针对已经查出一批数据来，但是想区分出某个字段是否存在的时候使用。示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /haoke/user/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;exists&quot;</span>: &#123; <span class="comment">#必须包含</span></span><br><span class="line">        	<span class="string">&quot;field&quot;</span>: <span class="string">&quot;card&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095204.png" alt="image-20200923105416339"></p>
<h4 id="match查询"><a href="#match查询" class="headerlink" title="match查询"></a>match查询</h4><p>match 查询是一个标准查询，不管你需要全文本查询还是精确查询基本上都要用到它。</p>
<p>如果你使用 match 查询一个全文本字段，它会在真正查询之前用分析器先分析match 一下查询字符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">    	<span class="string">&quot;tweet&quot;</span>: <span class="string">&quot;About Search&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用match 下指定了一个确切值，在遇到数字，日期，布尔值或者not_analyzed 的字符串时，它将为你搜索你<br>给定的值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123; <span class="string">&quot;match&quot;</span>: &#123; <span class="string">&quot;age&quot;</span>: 26 &#125;&#125;</span><br><span class="line">&#123; <span class="string">&quot;match&quot;</span>: &#123; <span class="string">&quot;date&quot;</span>: <span class="string">&quot;2014-09-01&quot;</span> &#125;&#125;</span><br><span class="line">&#123; <span class="string">&quot;match&quot;</span>: &#123; <span class="string">&quot;public&quot;</span>: <span class="literal">true</span> &#125;&#125;</span><br><span class="line">&#123; <span class="string">&quot;match&quot;</span>: &#123; <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;full_text&quot;</span> &#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bool查询"><a href="#bool查询" class="headerlink" title="bool查询"></a>bool查询</h4><ul>
<li>bool 查询可以用来合并多个条件查询结果的布尔逻辑，它包含一下操作符：</li>
<li>must :: 多个查询条件的完全匹配,相当于 and 。</li>
<li>must_not :: 多个查询条件的相反匹配，相当于 not 。</li>
<li>should :: 至少有一个查询条件匹配, 相当于 or 。</li>
</ul>
<p>这些参数可以分别继承一个查询条件或者一个查询条件的数组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;bool&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;must&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;term&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;folder&quot;</span>:<span class="string">&quot;inbox&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;must_not&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;term&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;tag&quot;</span>:<span class="string">&quot;spam&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;should&quot;</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;term&quot;</span>:&#123;</span><br><span class="line">                    <span class="string">&quot;starred&quot;</span>:<span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;term&quot;</span>:&#123;</span><br><span class="line">                    <span class="string">&quot;unread&quot;</span>:<span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="过滤查询"><a href="#过滤查询" class="headerlink" title="过滤查询"></a>过滤查询</h3><p>前面讲过结构化查询，Elasticsearch也支持过滤查询，如term、range、match等。</p>
<p>示例：查询年龄为20岁的用户。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /itcast/person/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;bool&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;filter&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;term&quot;</span>:&#123;</span><br><span class="line">                    <span class="string">&quot;age&quot;</span>:20</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查询和过滤的对比"><a href="#查询和过滤的对比" class="headerlink" title="查询和过滤的对比"></a>查询和过滤的对比</h4><ul>
<li>一条过滤语句会询问每个文档的字段值是否包含着特定值。</li>
<li>查询语句会询问每个文档的字段值与特定值的匹配程度如何。</li>
<li>一条查询语句会计算每个文档与查询语句的相关性，会给出一个相关性评分 _score，并且 按照相关性对匹<br>配到的文档进行排序。 这种评分方式非常适用于一个没有完全配置结果的全文本搜索。</li>
<li>一个简单的文档列表，快速匹配运算并存入内存是十分方便的， 每个文档仅需要1个字节。这些缓存的过滤结果集与后续请求的结合使用是非常高效的。</li>
<li>查询语句不仅要查找相匹配的文档，还需要计算每个文档的相关性，所以一般来说查询语句要比 过滤语句更耗时，并且查询结果也不可缓存。</li>
</ul>
<h4 id="建议："><a href="#建议：" class="headerlink" title="建议："></a>建议：</h4><p>做精确匹配搜索时，最好用过滤语句，因为过滤语句可以缓存数据。</p>
<h2 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h2><h3 id="什么是分词"><a href="#什么是分词" class="headerlink" title="什么是分词"></a>什么是分词</h3><p>分词就是指将一个文本转化成一系列单词的过程，也叫文本分析，在Elasticsearch中称之为Analysis。</p>
<p>举例：我是中国人 –&gt; 我/是/中国人</p>
<h3 id="分词api"><a href="#分词api" class="headerlink" title="分词api"></a>分词api</h3><p>指定分词器进行分词</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;analyzer&quot;</span>:<span class="string">&quot;standard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;text&quot;</span>:<span class="string">&quot;hello world&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095205.png" alt="image-20200923110814505"></p>
<p>在结果中不仅可以看出分词的结果，还返回了该词在文本中的位置。</p>
<blockquote>
<p>指定索引分词</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /itcast/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;field&quot;</span>: <span class="string">&quot;hobby&quot;</span>,</span><br><span class="line">    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;听音乐&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095206.png" alt="image-20200923110905001"></p>
<h3 id="中文分词难点"><a href="#中文分词难点" class="headerlink" title="中文分词难点"></a>中文分词难点</h3><p>中文分词的难点在于，在汉语中没有明显的词汇分界点，如在英语中，空格可以作为分隔符，如果分隔不正确就会造成歧义。如：</p>
<ul>
<li>我/爱/炒肉丝</li>
<li>我/爱/炒/肉丝</li>
</ul>
<p>常用中文分词器，IK、jieba、THULAC等，推荐使用IK分词器。</p>
<p>IK Analyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。从2006年12月推出1.0版开始，IKAnalyzer已经推出了3个大版本。最初，它是以开源项目Luence为应用主体的，结合词典分词和文法分析算法的中文分词组件。新版本的IK Analyzer 3.0则发展为面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。</p>
<p>采用了特有的“正向迭代最细粒度切分算法“，具有80万字/秒的高速处理能力 采用了多子处理器分析模式，支持：英文字母（IP地址、Email、URL）、数字（日期，常用中文数量词，罗马数字，科学计数法），中文词汇（姓名、地名处理）等分词处理。 优化的词典存储，更小的内存占用。</p>
<p>IK分词器 Elasticsearch插件地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></p>
<h3 id="安装分词器"><a href="#安装分词器" class="headerlink" title="安装分词器"></a>安装分词器</h3><p>首先下载到最新的ik分词器：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v7.9.1">下载地址</a></p>
<p>下载完成后，使用xftp工具，拷贝到服务器上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装方法：将下载到的 es/plugins/ik 目录下</span></span><br><span class="line">mkdir es/plugins/ik</span><br><span class="line"></span><br><span class="line"><span class="comment">#解压</span></span><br><span class="line">unzip elasticsearch-analysis-ik-7.9.1.zip</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure>
<p>我们通过日志，发现它已经成功加载了ik分词器插件</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095207.png" alt="image-20200923113200826"></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line">    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;我是中国人&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现ik分词器已经成功分词完成</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095208.png" alt="image-20200923113222937"></p>
<h2 id="全文搜索-1"><a href="#全文搜索-1" class="headerlink" title="全文搜索"></a>全文搜索</h2><p>全文搜索两个最重要的方面是：</p>
<ul>
<li>相关性（Relevance） 它是评价查询与其结果间的相关程度，并根据这种相关程度对结果排名的一种能力，这<br>种计算方式可以是 TF/IDF 方法、地理位置邻近、模糊相似，或其他的某些算法。</li>
<li>分词（Analysis） 它是将文本块转换为有区别的、规范化的 token 的一个过程，目的是为了创建倒排索引以及查询倒排索引。</li>
</ul>
<h3 id="构造数据"><a href="#构造数据" class="headerlink" title="构造数据"></a>构造数据</h3><blockquote>
<p>ES 7.4 默认不在支持指定索引类型，默认索引类型是_doc</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://202.193.56.222:9200/itcast?include_type_name=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;settings&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;index&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;number_of_shards&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;number_of_replicas&quot;</span>:<span class="string">&quot;0&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;person&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>:&#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;age&quot;</span>:&#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;integer&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;mail&quot;</span>:&#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;hobby&quot;</span>:&#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;analyzer&quot;</span>:<span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后插入数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST http://202.193.56.222:9200/itcast/_bulk</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;itcast&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>: 20,<span class="string">&quot;mail&quot;</span>: <span class="string">&quot;111@qq.com&quot;</span>,<span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;羽毛球、乒乓球、足球&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;itcast&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;age&quot;</span>: 21,<span class="string">&quot;mail&quot;</span>: <span class="string">&quot;222@qq.com&quot;</span>,<span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;羽毛球、乒乓球、足球、篮球&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;itcast&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;age&quot;</span>: 22,<span class="string">&quot;mail&quot;</span>: <span class="string">&quot;333@qq.com&quot;</span>,<span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;羽毛球、篮球、游泳、听音乐&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;itcast&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;赵六&quot;</span>,<span class="string">&quot;age&quot;</span>: 23,<span class="string">&quot;mail&quot;</span>: <span class="string">&quot;444@qq.com&quot;</span>,<span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;跑步、游泳、篮球&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;itcast&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;孙七&quot;</span>,<span class="string">&quot;age&quot;</span>: 24,<span class="string">&quot;mail&quot;</span>: <span class="string">&quot;555@qq.com&quot;</span>,<span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;听音乐、看电影、羽毛球&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095209.png" alt="image-20200923141912153"></p>
<h3 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /itcast/person/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;音乐&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;highlight&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;fields&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;hobby&quot;</span>:&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询出来的结果如下，并且还带有高亮</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095210.png" alt="image-20200923142131426"></p>
<p>过程说明：</p>
<ul>
<li>检查字段类型<ul>
<li>爱好 hobby 字段是一个 text 类型（ 指定了IK分词器），这意味着查询字符串本身也应该被分词。</li>
</ul>
</li>
<li>分析查询字符串 。<ul>
<li>将查询的字符串 “音乐” 传入IK分词器中，输出的结果是单个项 音乐。因为只有一个单词项，所以 match 查询执行的是单个底层 term 查询。</li>
</ul>
</li>
<li>查找匹配文档 。<ul>
<li>用 term 查询在倒排索引中查找 “音乐” 然后获取一组包含该项的文档，本例的结果是文档：3 、5 。</li>
</ul>
</li>
<li>为每个文档评分 。<ul>
<li>用 term 查询计算每个文档相关度评分 _score ，这是种将 词频（term frequency，即词 “音乐” 在相关文档的hobby 字段中出现的频率）和 反向文档频率（inverse document frequency，即词 “音乐” 在所有文档的hobby 字段中出现的频率），以及字段的长度（即字段越短相关度越高）相结合的计算方式。</li>
</ul>
</li>
</ul>
<h3 id="多词搜索"><a href="#多词搜索" class="headerlink" title="多词搜索"></a>多词搜索</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /itcast/person/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;音乐 篮球&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;highlight&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;fields&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;hobby&quot;</span>:&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，包含了“音乐”、“篮球”的数据都已经被搜索到了。可是，搜索的结果并不符合我们的预期，因为我们想搜索的是既包含“音乐”又包含“篮球”的用户，显然结果返回的“或”的关系。在Elasticsearch中，可以指定词之间的逻辑关系，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;hobby&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;query&quot;</span>: <span class="string">&quot;音乐 羽毛球&quot;</span>,</span><br><span class="line">                <span class="string">&quot;operator&quot;</span>: <span class="string">&quot;and&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;hobby&quot;</span>: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这样的话，就会让两个关键字之间存在and关系了</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095211.png" alt="image-20200923142538105"></p>
<p>可以看到结果符合预期。</p>
<p>前面我们测试了“OR” 和 “AND”搜索，这是两个极端，其实在实际场景中，并不会选取这2个极端，更有可能是选取这种，或者说，只需要符合一定的相似度就可以查询到数据，在Elasticsearch中也支持这样的查询，通过<br>minimum_should_match来指定匹配度，如：70%；</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;hobby&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;query&quot;</span>:<span class="string">&quot;游泳 羽毛球&quot;</span>,</span><br><span class="line">            <span class="string">&quot;minimum_should_match&quot;</span>:<span class="string">&quot;80%&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        <span class="string">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;hobby&quot;</span>: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#结果：省略显示</span></span><br><span class="line"><span class="string">&quot;hits&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;total&quot;</span>: 4, <span class="comment">#相似度为80%的情况下，查询到4条数据</span></span><br><span class="line"><span class="string">&quot;max_score&quot;</span>: 1.621458,</span><br><span class="line"><span class="string">&quot;hits&quot;</span>: [</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#设置40%进行测试：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;hobby&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;query&quot;</span>:<span class="string">&quot;游泳 羽毛球&quot;</span>,</span><br><span class="line">            <span class="string">&quot;minimum_should_match&quot;</span>:<span class="string">&quot;40%&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;hobby&quot;</span>: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果：</span></span><br><span class="line"><span class="string">&quot;hits&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;total&quot;</span>: 5, <span class="comment">#相似度为40%的情况下，查询到5条数据</span></span><br><span class="line"><span class="string">&quot;max_score&quot;</span>: 1.621458,</span><br><span class="line"><span class="string">&quot;hits&quot;</span>: [</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相似度应该多少合适，需要在实际的需求中进行反复测试，才可得到合理的值。</p>
<h3 id="组合搜索"><a href="#组合搜索" class="headerlink" title="组合搜索"></a>组合搜索</h3><p>在搜索时，也可以使用过滤器中讲过的bool组合查询，示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /itcast/person/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;bool&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;must&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">                    <span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;篮球&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;must_not&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">                    <span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;音乐&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;should&quot;</span>:[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">                        <span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;游泳&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;highlight&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;fields&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;hobby&quot;</span>:&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面搜索的意思是：<br>搜索结果中必须包含篮球，不能包含音乐，如果包含了游泳，那么它的相似度更高。</p>
</blockquote>
<p>结果：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095212.png" alt="image-20200923145310698"></p>
<blockquote>
<p>评分的计算规则</p>
<p>bool 查询会为每个文档计算相关度评分 _score ， 再将所有匹配的 must 和 should 语句的分数 _score 求和，最后除以 must 和 should 语句的总数。</p>
<p>must_not 语句不会影响评分； 它的作用只是将不相关的文档排除。</p>
</blockquote>
<p>默认情况下，should中的内容不是必须匹配的，如果查询语句中没有must，那么就会至少匹配其中一个。当然了，也可以通过minimum_should_match参数进行控制，该值可以是数字也可以的百分比。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /itcast/person/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;bool&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;should&quot;</span>:[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">                        <span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;游泳&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">                        <span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;篮球&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">                        <span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;音乐&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;minimum_should_match&quot;</span>:2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;highlight&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;fields&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;hobby&quot;</span>:&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>minimum_should_match为2，意思是should中的三个词，至少要满足2个。</p>
<h3 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h3><p>有些时候，我们可能需要对某些词增加权重来影响该条数据的得分。如下：</p>
<p>搜索关键字为“游泳篮球”，如果结果中包含了“音乐”权重为10，包含了“跑步”权重为2。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /itcast/person/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;bool&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;must&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">                    <span class="string">&quot;hobby&quot;</span>:&#123;</span><br><span class="line">                        <span class="string">&quot;query&quot;</span>:<span class="string">&quot;游泳篮球&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;operator&quot;</span>:<span class="string">&quot;and&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;should&quot;</span>:[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">                        <span class="string">&quot;hobby&quot;</span>:&#123;</span><br><span class="line">                            <span class="string">&quot;query&quot;</span>:<span class="string">&quot;音乐&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;boost&quot;</span>:10</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">                        <span class="string">&quot;hobby&quot;</span>:&#123;</span><br><span class="line">                            <span class="string">&quot;query&quot;</span>:<span class="string">&quot;跑步&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;boost&quot;</span>:2</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;highlight&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;fields&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;hobby&quot;</span>:&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="ElasticSearch集群"><a href="#ElasticSearch集群" class="headerlink" title="ElasticSearch集群"></a>ElasticSearch集群</h2><h3 id="集群节点"><a href="#集群节点" class="headerlink" title="集群节点"></a>集群节点</h3><p>ELasticsearch的集群是由多个节点组成的，通过cluster.name设置集群名称，并且用于区分其它的集群，每个节点通过node.name指定节点的名称。</p>
<p>在Elasticsearch中，节点的类型主要有4种：</p>
<ul>
<li>master节点<ul>
<li>配置文件中node.master属性为true(默认为true)，就有资格被选为master节点。master节点用于控制整个集群的操作。比如创建或删除索引，管理其它非master节点等。</li>
</ul>
</li>
<li>data节点<ul>
<li>配置文件中node.data属性为true(默认为true)，就有资格被设置成data节点。data节点主要用于执行数据相关的操作。比如文档的CRUD。</li>
</ul>
</li>
<li>客户端节点<ul>
<li>配置文件中node.master属性和node.data属性均为false。</li>
<li>该节点不能作为master节点，也不能作为data节点。</li>
<li>可以作为客户端节点，用于响应用户的请求，把请求转发到其他节点</li>
</ul>
</li>
<li>部落节点<ul>
<li>当一个节点配置tribe.*的时候，它是一个特殊的客户端，它可以连接多个集群，在所有连接的集群上执行<br>搜索和其他操作。</li>
</ul>
</li>
</ul>
<h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动3个虚拟机，分别在3台虚拟机上部署安装Elasticsearch</span></span><br><span class="line">mkdir /itcast/es-cluster</span><br><span class="line"></span><br><span class="line"><span class="comment">#分发到其它机器</span></span><br><span class="line">scp -r es-cluster elsearch@192.168.40.134:/itcast</span><br><span class="line"></span><br><span class="line"><span class="comment">#node01的配置：</span></span><br><span class="line">cluster.name: es-itcast-cluster</span><br><span class="line">node.name: node01</span><br><span class="line">node.master: <span class="literal">true</span></span><br><span class="line">node.data: <span class="literal">true</span></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">http.port: 9200</span><br><span class="line">discovery.zen.ping.unicast.hosts: [<span class="string">&quot;192.168.40.133&quot;</span>,<span class="string">&quot;192.168.40.134&quot;</span>,<span class="string">&quot;192.168.40.135&quot;</span>]</span><br><span class="line"><span class="comment"># 最小节点数</span></span><br><span class="line">discovery.zen.minimum_master_nodes: 2</span><br><span class="line"><span class="comment"># 跨域专用</span></span><br><span class="line">http.cors.enabled: <span class="literal">true</span></span><br><span class="line">http.cors.allow-origin: <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#node02的配置：</span></span><br><span class="line">cluster.name: es-itcast-cluster</span><br><span class="line">node.name: node02</span><br><span class="line">node.master: <span class="literal">true</span></span><br><span class="line">node.data: <span class="literal">true</span></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">http.port: 9200</span><br><span class="line">discovery.zen.ping.unicast.hosts: [<span class="string">&quot;192.168.40.133&quot;</span>,<span class="string">&quot;192.168.40.134&quot;</span>,<span class="string">&quot;192.168.40.135&quot;</span>]</span><br><span class="line">discovery.zen.minimum_master_nodes: 2</span><br><span class="line">http.cors.enabled: <span class="literal">true</span></span><br><span class="line">http.cors.allow-origin: <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#node03的配置：</span></span><br><span class="line">cluster.name: es-itcast-cluster</span><br><span class="line">node.name: node02</span><br><span class="line">node.master: <span class="literal">true</span></span><br><span class="line">node.data: <span class="literal">true</span></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">http.port: 9200</span><br><span class="line">discovery.zen.ping.unicast.hosts: [<span class="string">&quot;192.168.40.133&quot;</span>,<span class="string">&quot;192.168.40.134&quot;</span>,<span class="string">&quot;192.168.40.135&quot;</span>]</span><br><span class="line">discovery.zen.minimum_master_nodes: 2</span><br><span class="line">http.cors.enabled: <span class="literal">true</span></span><br><span class="line">http.cors.allow-origin: <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#分别启动3个节点</span></span><br><span class="line">./elasticsearch</span><br></pre></td></tr></table></figure>
<p>查看集群</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095213.png" alt="image-20200923151823672"></p>
<p>创建索引：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095214.png" alt="image-20200923151851785"></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095215.png" alt="image-20200923151935283"></p>
<p>查询集群状态：/_cluster/health<br>响应：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095216.png" alt="image-20200923151953227"></p>
<p>集群中有三种颜色</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095217.png" alt="image-20200923152005930"></p>
<h3 id="分片和副本"><a href="#分片和副本" class="headerlink" title="分片和副本"></a>分片和副本</h3><p>为了将数据添加到Elasticsearch，我们需要索引(index)——一个存储关联数据的地方。实际上，索引只是一个用来指向一个或多个分片(shards)的“逻辑命名空间(logical namespace)”.</p>
<ul>
<li>一个分片(shard)是一个最小级别“工作单元(worker unit)”,它只是保存了索引中所有数据的一部分。</li>
<li>我们需要知道是分片就是一个Lucene实例，并且它本身就是一个完整的搜索引擎。应用程序不会和它直接通<br>信。</li>
<li>分片可以是主分片(primary shard)或者是复制分片(replica shard)。</li>
<li>索引中的每个文档属于一个单独的主分片，所以主分片的数量决定了索引最多能存储多少数据。</li>
<li>复制分片只是主分片的一个副本，它可以防止硬件故障导致的数据丢失，同时可以提供读请求，比如搜索或者从别的shard取回文档。</li>
<li>当索引创建完成的时候，主分片的数量就固定了，但是复制分片的数量可以随时调整。</li>
</ul>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><h4 id="将data节点停止"><a href="#将data节点停止" class="headerlink" title="将data节点停止"></a>将data节点停止</h4><p>这里选择将node02停止：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095218.png" alt="image-20200923152229908"></p>
<p>当前集群状态为黄色，表示主节点可用，副本节点不完全可用，过一段时间观察，发现节点列表中看不到node02，副本节点分配到了node01和node03，集群状态恢复到绿色。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095219.png" alt="image-20200923152248547"></p>
<p>将node02恢复： ./node02/1 bin/elasticsearch</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095220.png" alt="image-20200923152328458"></p>
<p>可以看到，node02恢复后，重新加入了集群，并且重新分配了节点信息。</p>
<h4 id="将master节点停止"><a href="#将master节点停止" class="headerlink" title="将master节点停止"></a>将master节点停止</h4><p>接下来，测试将node01停止，也就是将主节点停止。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095221.png" alt="image-20200923152415890"></p>
<p>从结果中可以看出，集群对master进行了重新选举，选择node03为master。并且集群状态变成黄色。<br>等待一段时间后，集群状态从黄色变为了绿色：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095222.png" alt="image-20200923153343555"></p>
<p>恢复node01节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./node01/1 bin/elasticsearch</span><br></pre></td></tr></table></figure>
<p>重启之后，发现node01可以正常加入到集群中，集群状态依然为绿色：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095223.png" alt="image-20200923153415117"></p>
<p>特别说明：</p>
<p>如果在配置文件中discovery.zen.minimum_master_nodes设置的不是N/2+1时，会出现脑裂问题，之前宕机<br>的主节点恢复后不会加入到集群。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095224.png" alt="image-20200923153441693"></p>
<h3 id="分布式文档"><a href="#分布式文档" class="headerlink" title="分布式文档"></a>分布式文档</h3><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p>首先，来看个问题：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095225.png" alt="image-20200923153556720"></p>
<p>如图所示：当我们想一个集群保存文档时，文档该存储到哪个节点呢？ 是随机吗？ 是轮询吗？实际上，在ELasticsearch中，会采用计算的方式来确定存储到哪个节点，计算公式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shard = <span class="built_in">hash</span>(routing) % number_1 of_primary_shards</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>routing值是一个任意字符串，它默认是_id但也可以自定义。</li>
<li>这个routing字符串通过哈希函数生成一个数字，然后除以主切片的数量得到一个余数(remainder)，余数<br>的范围永远是0到number_of_primary_shards - 1，这个数字就是特定文档所在的分片</li>
</ul>
<p>这就是为什么创建了主分片后，不能修改的原因。</p>
<h4 id="文档的写操作"><a href="#文档的写操作" class="headerlink" title="文档的写操作"></a>文档的写操作</h4><p>新建、索引和删除请求都是写（write）操作，它们必须在主分片上成功完成才能复制分片上</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095226.png" alt="image-20200923155314424"></p>
<p>下面我们罗列在主分片和复制分片上成功新建、索引或删除一个文档必要的顺序步骤：</p>
<ol>
<li>客户端给Node 1 发送新建、索引或删除请求。</li>
<li>节点使用文档的_id 确定文档属于分片0 。它转发请求到Node 3 ，分片0 位于这个节点上。</li>
<li>Node 3 在主分片上执行请求，如果成功，它转发请求到相应的位于Node 1 和Node 2 的复制节点上。当所有<br>的复制节点报告成功， Node 3 报告成功到请求的节点，请求的节点再报告给客户端。</li>
</ol>
<p>客户端接收到成功响应的时候，文档的修改已经被应用于主分片和所有的复制分片。你的修改生效了。</p>
<h3 id="搜索文档"><a href="#搜索文档" class="headerlink" title="搜索文档"></a>搜索文档</h3><p>文档能够从主分片或任意一个复制分片被检索。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095227.png" alt="image-20200923160046962"></p>
<p>下面我们罗列在主分片或复制分片上检索一个文档必要的顺序步骤：</p>
<ol>
<li>客户端给Node 1 发送get请求。</li>
<li>节点使用文档的_id 确定文档属于分片0 。分片0 对应的复制分片在三个节点上都有。此时，它转发请求到<br>Node 2 。</li>
<li>Node 2 返回文档(document)给Node 1 然后返回给客户端。对于读请求，为了平衡负载，请求节点会为每个请求选择不同的分片——它会循环所有分片副本。可能的情况是，一个被索引的文档已经存在于主分片上却还没来得及同步到复制分片上。这时复制分片会报告文档未找到，主分片会成功返回文档。一旦索引请求成功返回给用户，文档则在主分片和复制分片都是可用的。</li>
</ol>
<h3 id="全文搜索-2"><a href="#全文搜索-2" class="headerlink" title="全文搜索"></a>全文搜索</h3><p>对于全文搜索而言，文档可能分散在各个节点上，那么在分布式的情况下，如何搜索文档呢？</p>
<p>搜索，分为2个阶段，</p>
<ul>
<li>搜索（query）</li>
<li>取回（fetch）</li>
</ul>
<h4 id="搜索（query）"><a href="#搜索（query）" class="headerlink" title="搜索（query）"></a>搜索（query）</h4><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095228.png" alt="image-20200923161323235"></p>
<p>查询阶段包含以下三步：</p>
<ol>
<li>客户端发送一个search（搜索） 请求给Node 3 , Node 3 创建了一个长度为from+size 的空优先级队</li>
<li>Node 3 转发这个搜索请求到索引中每个分片的原本或副本。每个分片在本地执行这个查询并且结果将结果到<br>一个大小为from+size 的有序本地优先队列里去。</li>
<li>每个分片返回document的ID和它优先队列里的所有document的排序值给协调节点Node 3 。Node 3 把这些<br>值合并到自己的优先队列里产生全局排序结果。</li>
</ol>
<h4 id="取回-fetch"><a href="#取回-fetch" class="headerlink" title="取回 fetch"></a>取回 fetch</h4><p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095229.png" alt="image-20200923161447618"></p>
<p>分发阶段由以下步骤构成：</p>
<ol>
<li>协调节点辨别出哪个document需要取回，并且向相关分片发出GET 请求。</li>
<li>每个分片加载document并且根据需要丰富（enrich）它们，然后再将document返回协调节点。</li>
<li>一旦所有的document都被取回，协调节点会将结果返回给客户端。</li>
</ol>
<h2 id="Java客户端"><a href="#Java客户端" class="headerlink" title="Java客户端"></a>Java客户端</h2><p>在Elasticsearch中，为java提供了2种客户端，一种是REST风格的客户端，另一种是Java API的客户端</p>
<h3 id="REST客户端"><a href="#REST客户端" class="headerlink" title="REST客户端"></a>REST客户端</h3><p>Elasticsearch提供了2种REST客户端，一种是低级客户端，一种是高级客户端。</p>
<ul>
<li>Java Low Level REST Client：官方提供的低级客户端。该客户端通过http来连接Elasticsearch集群。用户在使<br>用该客户端时需要将请求数据手动拼接成Elasticsearch所需JSON格式进行发送，收到响应时同样也需要将返回的JSON数据手动封装成对象。虽然麻烦，不过该客户端兼容所有的Elasticsearch版本。</li>
<li>Java High Level REST Client：官方提供的高级客户端。该客户端基于低级客户端实现，它提供了很多便捷的<br>API来解决低级客户端需要手动转换数据格式的问题。</li>
</ul>
<h3 id="构造数据-1"><a href="#构造数据-1" class="headerlink" title="构造数据"></a>构造数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /haoke/house/_bulk</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;haoke&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;house&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;1001&quot;</span>,<span class="string">&quot;title&quot;</span>:<span class="string">&quot;整租 · 南丹大楼 1居室 7500&quot;</span>,<span class="string">&quot;price&quot;</span>:<span class="string">&quot;7500&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;haoke&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;house&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;1002&quot;</span>,<span class="string">&quot;title&quot;</span>:<span class="string">&quot;陆家嘴板块，精装设计一室一厅，可拎包入住诚意租。&quot;</span>,<span class="string">&quot;price&quot;</span>:<span class="string">&quot;8500&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;haoke&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;house&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;1003&quot;</span>,<span class="string">&quot;title&quot;</span>:<span class="string">&quot;整租 · 健安坊 1居室 4050&quot;</span>,<span class="string">&quot;price&quot;</span>:<span class="string">&quot;7500&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;haoke&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;house&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;1004&quot;</span>,<span class="string">&quot;title&quot;</span>:<span class="string">&quot;整租 · 中凯城市之光+视野开阔+景色秀丽+拎包入住&quot;</span>,<span class="string">&quot;price&quot;</span>:<span class="string">&quot;6500&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;haoke&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;house&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;1005&quot;</span>,<span class="string">&quot;title&quot;</span>:<span class="string">&quot;整租 · 南京西路品质小区 21213三轨交汇 配套齐* 拎包入住&quot;</span>,<span class="string">&quot;price&quot;</span>:<span class="string">&quot;6000&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;haoke&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;house&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;1006&quot;</span>,<span class="string">&quot;title&quot;</span>:<span class="string">&quot;祥康里 简约风格 *南户型 拎包入住 看房随时&quot;</span>,<span class="string">&quot;price&quot;</span>:<span class="string">&quot;7000&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/img/20210107095230.png" alt="image-20200923162419395"></p>
<h3 id="REST低级客户端"><a href="#REST低级客户端" class="headerlink" title="REST低级客户端"></a>REST低级客户端</h3><p>创建项目，加入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Study_ElasticSearch_Code<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>7<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>7<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.Request;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.Response;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClientBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用低级客户端 访问</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 陌溪</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-09-23-16:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ESApi</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RestClient restClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper MAPPER = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestClientBuilder restClientBuilder = RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">&quot;202.193.56.222&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.restClient = restClientBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询集群状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetInfo</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = <span class="keyword">new</span> Request(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/_cluster/state&quot;</span>);</span><br><span class="line">        request.addParameter(<span class="string">&quot;pretty&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        Response response = <span class="keyword">this</span>.restClient.performRequest(request);</span><br><span class="line">        System.out.println(response.getStatusLine());</span><br><span class="line">        System.out.println(EntityUtils.toString(response.getEntity()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID查询数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetHouseInfo</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = <span class="keyword">new</span> Request(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/haoke/house/Z3CduXQBYpWein3CRFug&quot;</span>);</span><br><span class="line">        request.addParameter(<span class="string">&quot;pretty&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        Response response = <span class="keyword">this</span>.restClient.performRequest(request);</span><br><span class="line">        System.out.println(response.getStatusLine());</span><br><span class="line">        System.out.println(EntityUtils.toString(response.getEntity()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = <span class="keyword">new</span> Request(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/haoke/house&quot;</span>);</span><br><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        data.put(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;2001&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;张江高科&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;price&quot;</span>, <span class="string">&quot;3500&quot;</span>);</span><br><span class="line">        <span class="comment">// 写成JSON</span></span><br><span class="line">        request.setJsonEntity(MAPPER.writeValueAsString(data));</span><br><span class="line">        Response response = <span class="keyword">this</span>.restClient.performRequest(request);</span><br><span class="line">        System.out.println(response.getStatusLine());</span><br><span class="line">        System.out.println(EntityUtils.toString(response.getEntity()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSearchData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = <span class="keyword">new</span> Request(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/haoke/house/_search&quot;</span>);</span><br><span class="line">        String searchJson = <span class="string">&quot;&#123;\&quot;query\&quot;: &#123;\&quot;match\&quot;: &#123;\&quot;title\&quot;: \&quot;拎包入住\&quot;&#125;&#125;&#125;&quot;</span>;</span><br><span class="line">        request.setJsonEntity(searchJson);</span><br><span class="line">        request.addParameter(<span class="string">&quot;pretty&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        Response response = <span class="keyword">this</span>.restClient.performRequest(request);</span><br><span class="line">        System.out.println(response.getStatusLine());</span><br><span class="line">        System.out.println(EntityUtils.toString(response.getEntity()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ESApi esApi = <span class="keyword">new</span> ESApi();</span><br><span class="line">        esApi.init();</span><br><span class="line"><span class="comment">//        esApi.testGetInfo();</span></span><br><span class="line"><span class="comment">//        esApi.testGetHouseInfo();</span></span><br><span class="line">        esApi.testCreateData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="REST高级客户端"><a href="#REST高级客户端" class="headerlink" title="REST高级客户端"></a>REST高级客户端</h3><p>创建项目，引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写测试用例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.ActionListener;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.delete.DeleteRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.delete.DeleteResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.get.GetRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.get.GetResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.index.IndexRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.index.IndexResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.search.SearchRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.search.SearchResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.update.UpdateRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.update.UpdateResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.*;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.Strings;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.unit.TimeValue;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.QueryBuilders;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.search.SearchHit;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.search.SearchHits;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.search.builder.SearchSourceBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.search.fetch.subphase.FetchSourceContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ES高级客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 陌溪</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-09-23-16:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ESHightApi</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestClientBuilder restClientBuilder = RestClient.builder(</span><br><span class="line">                <span class="keyword">new</span> HttpHost(<span class="string">&quot;202.193.56.222&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.client = <span class="keyword">new</span> RestHighLevelClient(restClientBuilder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增文档，同步操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        data.put(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;2002&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;南京西路 拎包入住 一室一厅&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;price&quot;</span>, <span class="string">&quot;4500&quot;</span>);</span><br><span class="line">        IndexRequest indexRequest = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;haoke&quot;</span>, <span class="string">&quot;house&quot;</span>)</span><br><span class="line">                .source(data);</span><br><span class="line">        IndexResponse indexResponse = <span class="keyword">this</span>.client.index(indexRequest,</span><br><span class="line">                RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(<span class="string">&quot;id-&gt;&quot;</span> + indexResponse.getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;index-&gt;&quot;</span> + indexResponse.getIndex());</span><br><span class="line">        System.out.println(<span class="string">&quot;type-&gt;&quot;</span> + indexResponse.getType());</span><br><span class="line">        System.out.println(<span class="string">&quot;version-&gt;&quot;</span> + indexResponse.getVersion());</span><br><span class="line">        System.out.println(<span class="string">&quot;result-&gt;&quot;</span> + indexResponse.getResult());</span><br><span class="line">        System.out.println(<span class="string">&quot;shardInfo-&gt;&quot;</span> + indexResponse.getShardInfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步创建文档</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        data.put(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;2003&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;南京东路 最新房源 二室一厅&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;price&quot;</span>, <span class="string">&quot;5500&quot;</span>);</span><br><span class="line">        IndexRequest indexRequest = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;haoke&quot;</span>, <span class="string">&quot;house&quot;</span>)</span><br><span class="line">                .source(data);</span><br><span class="line">        <span class="keyword">this</span>.client.indexAsync(indexRequest, RequestOptions.DEFAULT, <span class="keyword">new</span></span><br><span class="line">                ActionListener&lt;IndexResponse&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(IndexResponse indexResponse)</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;id-&gt;&quot;</span> + indexResponse.getId());</span><br><span class="line">                        System.out.println(<span class="string">&quot;index-&gt;&quot;</span> + indexResponse.getIndex());</span><br><span class="line">                        System.out.println(<span class="string">&quot;type-&gt;&quot;</span> + indexResponse.getType());</span><br><span class="line">                        System.out.println(<span class="string">&quot;version-&gt;&quot;</span> + indexResponse.getVersion());</span><br><span class="line">                        System.out.println(<span class="string">&quot;result-&gt;&quot;</span> + indexResponse.getResult());</span><br><span class="line">                        System.out.println(<span class="string">&quot;shardInfo-&gt;&quot;</span> + indexResponse.getShardInfo());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">                        System.out.println(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        GetRequest getRequest = <span class="keyword">new</span> GetRequest(<span class="string">&quot;haoke&quot;</span>, <span class="string">&quot;house&quot;</span>,</span><br><span class="line">                <span class="string">&quot;GkpdE2gBCKv8opxuOj12&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定返回的字段</span></span><br><span class="line">        String[] includes = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;title&quot;</span>, <span class="string">&quot;id&quot;</span>&#125;;</span><br><span class="line">        String[] excludes = Strings.EMPTY_ARRAY;</span><br><span class="line">        FetchSourceContext fetchSourceContext =</span><br><span class="line">                <span class="keyword">new</span> FetchSourceContext(<span class="keyword">true</span>, includes, excludes);</span><br><span class="line">        getRequest.fetchSourceContext(fetchSourceContext);</span><br><span class="line">        GetResponse response = <span class="keyword">this</span>.client.get(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(<span class="string">&quot;数据 -&gt; &quot;</span> + response.getSource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExists</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        GetRequest getRequest = <span class="keyword">new</span> GetRequest(<span class="string">&quot;haoke&quot;</span>, <span class="string">&quot;house&quot;</span>,</span><br><span class="line">                <span class="string">&quot;GkpdE2gBCKv8opxuOj12&quot;</span>);</span><br><span class="line"><span class="comment">// 不返回的字段</span></span><br><span class="line">        getRequest.fetchSourceContext(<span class="keyword">new</span> FetchSourceContext(<span class="keyword">false</span>));</span><br><span class="line">        <span class="keyword">boolean</span> exists = <span class="keyword">this</span>.client.exists(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(<span class="string">&quot;exists -&gt; &quot;</span> + exists);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest(<span class="string">&quot;haoke&quot;</span>, <span class="string">&quot;house&quot;</span>,</span><br><span class="line">                <span class="string">&quot;GkpdE2gBCKv8opxuOj12&quot;</span>);</span><br><span class="line">        DeleteResponse response = <span class="keyword">this</span>.client.delete(deleteRequest,</span><br><span class="line">                RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(response.status());<span class="comment">// OK or NOT_FOUND</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        UpdateRequest updateRequest = <span class="keyword">new</span> UpdateRequest(<span class="string">&quot;haoke&quot;</span>, <span class="string">&quot;house&quot;</span>,</span><br><span class="line">                <span class="string">&quot;G0pfE2gBCKv8opxuRz1y&quot;</span>);</span><br><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        data.put(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;张江高科2&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;price&quot;</span>, <span class="string">&quot;5000&quot;</span>);</span><br><span class="line">        updateRequest.doc(data);</span><br><span class="line">        UpdateResponse response = <span class="keyword">this</span>.client.update(updateRequest,</span><br><span class="line">                RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(<span class="string">&quot;version -&gt; &quot;</span> + response.getVersion());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试搜索</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSearch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;haoke&quot;</span>);</span><br><span class="line">        searchRequest.types(<span class="string">&quot;house&quot;</span>);</span><br><span class="line">        SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        sourceBuilder.query(QueryBuilders.matchQuery(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;拎包入住&quot;</span>));</span><br><span class="line">        sourceBuilder.from(<span class="number">0</span>);</span><br><span class="line">        sourceBuilder.size(<span class="number">5</span>);</span><br><span class="line">        sourceBuilder.timeout(<span class="keyword">new</span> TimeValue(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line">        searchRequest.source(sourceBuilder);</span><br><span class="line">        SearchResponse search = <span class="keyword">this</span>.client.search(searchRequest,</span><br><span class="line">                RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(<span class="string">&quot;搜索到 &quot;</span> + search.getHits().totalHits + <span class="string">&quot; 条数据.&quot;</span>);</span><br><span class="line">        SearchHits hits = search.getHits();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">            System.out.println(hit.getSourceAsString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ESHightApi esHightApi = <span class="keyword">new</span> ESHightApi();</span><br><span class="line">        esHightApi.init();</span><br><span class="line">        esHightApi.testCreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>ELK</category>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习笔记</title>
    <url>/2021/03/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>该笔记资料取自于bilibili视频:<a href="https://www.bilibili.com/video/BV1Np4y1z7BU?p=70">https://www.bilibili.com/video/BV1Np4y1z7BU?p=70</a></p>
<h1 id="1，设计模式概述"><a href="#1，设计模式概述" class="headerlink" title="1，设计模式概述"></a>1，设计模式概述</h1><h2 id="1-1-软件设计模式的产生背景"><a href="#1-1-软件设计模式的产生背景" class="headerlink" title="1.1 软件设计模式的产生背景"></a>1.1 软件设计模式的产生背景</h2><p>“设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。</p>
<p>1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任<code>克里斯托夫·亚历山大（Christopher Alexander）</code>在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。</p>
<p>1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。  </p>
<h2 id="1-2-软件设计模式的概念"><a href="#1-2-软件设计模式的概念" class="headerlink" title="1.2 软件设计模式的概念"></a>1.2 软件设计模式的概念</h2><p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。</p>
<h2 id="1-3-学习设计模式的必要性"><a href="#1-3-学习设计模式的必要性" class="headerlink" title="1.3 学习设计模式的必要性"></a>1.3 学习设计模式的必要性</h2><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p>
<p>正确使用设计模式具有以下优点。</p>
<ul>
<li>可以提高程序员的思维能力、编程能力和设计能力。</li>
<li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li>
<li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li>
</ul>
<h2 id="1-4-设计模式分类"><a href="#1-4-设计模式分类" class="headerlink" title="1.4 设计模式分类"></a>1.4 设计模式分类</h2><ul>
<li><p><strong>创建型模式</strong></p>
<p>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</p>
</li>
<li><p><strong>结构型模式</strong></p>
<p>用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</p>
</li>
<li><p><strong>行为型模式</strong></p>
<p>用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</p>
</li>
</ul>
<h1 id="2，UML图"><a href="#2，UML图" class="headerlink" title="2，UML图"></a>2，UML图</h1><p>统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p>
<p>UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。</p>
<h2 id="2-1-类图概述"><a href="#2-1-类图概述" class="headerlink" title="2.1 类图概述"></a>2.1 类图概述</h2><p>类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。</p>
<h2 id="2-2-类图的作用"><a href="#2-2-类图的作用" class="headerlink" title="2.2 类图的作用"></a>2.2 类图的作用</h2><ul>
<li>在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；</li>
<li>类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。</li>
</ul>
<h2 id="2-3-类图表示法"><a href="#2-3-类图表示法" class="headerlink" title="2.3 类图表示法"></a>2.3 类图表示法</h2><h3 id="2-3-1-类的表示方式"><a href="#2-3-1-类的表示方式" class="headerlink" title="2.3.1 类的表示方式"></a>2.3.1 类的表示方式</h3><p>在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。 </p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104101.png" alt="image-20210326104100889"></p>
<p>属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：</p>
<ul>
<li><p>+：表示public</p>
</li>
<li><p>-：表示private</p>
</li>
<li><p>#：表示protected</p>
</li>
</ul>
<p>属性的完整表示方式是： <strong>可见性  名称 ：类型 [ = 缺省值]</strong>  </p>
<p>方法的完整表示方式是： <strong>可见性  名称(参数列表) [ ： 返回类型]</strong></p>
<blockquote>
<p>注意：</p>
<p>​    1，中括号中的内容表示是可选的</p>
<p>​    2，也有将类型放在变量名前面，返回值类型放在方法名前面</p>
</blockquote>
<p><strong>举个栗子：</strong></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104120.png" alt="image-20210326104120130"></p>
<p>上图Demo类定义了三个方法：</p>
<ul>
<li>method()方法：修饰符为public，没有参数，没有返回值。</li>
<li>method1()方法：修饰符为private，没有参数，返回值类型为String。</li>
<li>method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。</li>
</ul>
<h3 id="2-3-2-类与类之间关系的表示方式"><a href="#2-3-2-类与类之间关系的表示方式" class="headerlink" title="2.3.2 类与类之间关系的表示方式"></a>2.3.2 类与类之间关系的表示方式</h3><h4 id="2-3-2-1-关联关系"><a href="#2-3-2-1-关联关系" class="headerlink" title="2.3.2.1 关联关系"></a>2.3.2.1 关联关系</h4><p>关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p>
<p>关联又可以分为单向关联，双向关联，自关联。</p>
<p><strong>1，单向关联</strong></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326103848.png"></p>
<p>在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p>
<p><strong>2，双向关联</strong></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326103848.png"></p>
<p>从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。</p>
<p>在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List/<Product>，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</p>
<p><strong>3，自关联</strong></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326103848.png"></p>
<p>自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。</p>
<h4 id="2-3-2-2-聚合关系"><a href="#2-3-2-2-聚合关系" class="headerlink" title="2.3.2.2 聚合关系"></a>2.3.2.2 聚合关系</h4><p>聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。</p>
<p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p>
<p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210318194619.png"></p>
<h4 id="2-3-2-3-组合关系"><a href="#2-3-2-3-组合关系" class="headerlink" title="2.3.2.3 组合关系"></a>2.3.2.3 组合关系</h4><p>组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。</p>
<p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p>
<p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326103849.png"></p>
<h4 id="2-3-2-4-依赖关系"><a href="#2-3-2-4-依赖关系" class="headerlink" title="2.3.2.4 依赖关系"></a>2.3.2.4 依赖关系</h4><p>依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p>
<p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326103849.png"></p>
<h4 id="2-3-2-5-继承关系"><a href="#2-3-2-5-继承关系" class="headerlink" title="2.3.2.5 继承关系"></a>2.3.2.5 继承关系</h4><p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。</p>
<p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210318194800.png"></p>
<h4 id="2-3-2-6-实现关系"><a href="#2-3-2-6-实现关系" class="headerlink" title="2.3.2.6 实现关系"></a>2.3.2.6 实现关系</h4><p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p>
<p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210318194801.png"></p>
<h1 id="3，软件设计原则"><a href="#3，软件设计原则" class="headerlink" title="3，软件设计原则"></a>3，软件设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p>
<h2 id="3-1-开闭原则"><a href="#3-1-开闭原则" class="headerlink" title="3.1 开闭原则"></a>3.1 开闭原则</h2><p><strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p>
<p>想要达到这样的效果，我们需要使用接口和抽象类。</p>
<p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p>
<p>下面以 <code>搜狗输入法</code> 的皮肤为例介绍开闭原则的应用。</p>
<p>【例】<code>搜狗输入法</code> 的皮肤设计。</p>
<p>分析：<code>搜狗输入法</code> 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104212.png" alt="image-20210326104148399"></p>
<p><strong>搜狗输入法类(SougouInput)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.principle.openclose;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/2/25 10:55 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 搜狗输入法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SougouInput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractSkin skin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SougouInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SougouInput</span><span class="params">(AbstractSkin skin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.skin = skin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractSkin <span class="title">getSkin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> skin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSkin</span><span class="params">(AbstractSkin skin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.skin = skin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.skin.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>抽象皮肤类(AbstractSkin)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.principle.openclose;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/2/25 10:53 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 抽象皮肤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSkin</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示皮肤</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认皮肤类(DefaultSkin)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.principle.openclose;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/2/25 10:54 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 默认皮肤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSkin</span> <span class="keyword">extends</span> <span class="title">AbstractSkin</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;默认皮肤&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>绿色皮肤类(GreenSkin)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.principle.openclose;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/2/25 10:54 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenSkin</span> <span class="keyword">extends</span> <span class="title">AbstractSkin</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绿色皮肤&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Demo类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsy.principle.openclose;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/2/25 10:56 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SougouInput input = <span class="keyword">new</span> SougouInput();</span><br><span class="line"><span class="comment">//        AbstractSkin skin = new DefaultSkin();</span></span><br><span class="line">        AbstractSkin skin = <span class="keyword">new</span> GreenSkin();</span><br><span class="line">        input.setSkin(skin);</span><br><span class="line">        input.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-2-里氏代换原则"><a href="#3-2-里氏代换原则" class="headerlink" title="3.2 里氏代换原则"></a>3.2 里氏代换原则</h2><p>里氏代换原则是面向对象设计的基本原则之一。</p>
<p>里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法</strong>。</p>
<p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p>
<p>下面看一个里氏替换原则中经典的一个例子</p>
<p>【例】正方形不是长方形。</p>
<p>在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210318194718.png"></p>
<p>代码如下：</p>
<p><strong>长方形类（Rectangle）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">double</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正方形（Square）：</strong></p>
<p>由于正方形的长和宽相同，所以在方法setLength和setWidth中，对长度和宽度都需要赋相同值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setLength(width);</span><br><span class="line">        <span class="keyword">super</span>.setWidth(width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">double</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setLength(length);</span><br><span class="line">        <span class="keyword">super</span>.setWidth(length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类RectangleDemo是我们的软件系统中的一个组件，它有一个resize方法依赖基类Rectangle，resize方法是RectandleDemo类中的一个方法，用来实现宽度逐渐增长的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RectangleDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(Rectangle rectangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (rectangle.getWidth() &lt;= rectangle.getLength()) &#123;</span><br><span class="line">            rectangle.setWidth(rectangle.getWidth() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印长方形的长和宽</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLengthAndWidth</span><span class="params">(Rectangle rectangle)</span> </span>&#123;</span><br><span class="line">        System.out.println(rectangle.getLength());</span><br><span class="line">        System.out.println(rectangle.getWidth());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Rectangle rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">        rectangle.setLength(<span class="number">20</span>);</span><br><span class="line">        rectangle.setWidth(<span class="number">10</span>);</span><br><span class="line">        resize(rectangle);</span><br><span class="line">        printLengthAndWidth(rectangle);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Rectangle rectangle1 = <span class="keyword">new</span> Square();</span><br><span class="line">        rectangle1.setLength(<span class="number">10</span>);</span><br><span class="line">        resize(rectangle1);</span><br><span class="line">        printLengthAndWidth(rectangle1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们运行一下这段代码就会发现，假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。<br>我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。</p>
<p>如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口</p>
<p>这时候我们都重写接口中的getLength()和getWidth()方法，这时候我们在设计RectangleDemo的方法形式参数时，我们可以选择将Square和Rectangle的接口Quadrilateral作为形式参数，这时候我们无论是放入Square还是Rectangle类都没有问题，也不会出现改写父类方法的情况</p>
<img src="https://gitee.com/Pink_oops/image/raw/master/20210318194726.png" style="zoom:80%;" />



<h2 id="3-3-依赖倒转原则"><a href="#3-3-依赖倒转原则" class="headerlink" title="3.3 依赖倒转原则"></a>3.3 依赖倒转原则</h2><p><strong>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</strong></p>
<p>下面看一个例子来理解依赖倒转原则</p>
<p>【例】组装电脑</p>
<p>现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。</p>
<p><strong>类图如下：</strong></p>
<img src="https://gitee.com/Pink_oops/image/raw/master/20210318194802.png" style="zoom:80%;" />

<p>代码如下：</p>
<p><strong>希捷硬盘类（XiJieHardDisk）:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiJieHardDisk</span> <span class="keyword">implements</span> <span class="title">HardDisk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用希捷硬盘存储数据&quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用希捷希捷硬盘取数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;数据&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Intel处理器（IntelCpu）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntelCpu</span> <span class="keyword">implements</span> <span class="title">Cpu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用Intel处理器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>金士顿内存条（KingstonMemory）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KingstonMemory</span> <span class="keyword">implements</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用金士顿作为内存条&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>电脑（Computer）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> XiJieHardDisk hardDisk;</span><br><span class="line">    <span class="keyword">private</span> IntelCpu cpu;</span><br><span class="line">    <span class="keyword">private</span> KingstonMemory memory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IntelCpu <span class="title">getCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCpu</span><span class="params">(IntelCpu cpu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KingstonMemory <span class="title">getMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(KingstonMemory memory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XiJieHardDisk <span class="title">getHardDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHardDisk</span><span class="params">(XiJieHardDisk hardDisk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hardDisk = hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算机工作&quot;</span>);</span><br><span class="line">        cpu.run();</span><br><span class="line">        memory.save();</span><br><span class="line">        String data = hardDisk.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;从硬盘中获取的数据为：&quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试类（TestComputer）：</strong></p>
<p>测试类用来组装电脑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestComputer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        computer.setHardDisk(<span class="keyword">new</span> XiJieHardDisk());</span><br><span class="line">        computer.setCpu(<span class="keyword">new</span> IntelCpu());</span><br><span class="line">        computer.setMemory(<span class="keyword">new</span> KingstonMemory());</span><br><span class="line"></span><br><span class="line">        computer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。</p>
<p>根据依赖倒转原则进行改进：</p>
<p>代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。</p>
<p><strong>类图如下：</strong></p>
<img src="https://gitee.com/Pink_oops/image/raw/master/20210318194252.png" alt="image-20191229173554296" style="zoom:70%;" />

<p><strong>电脑（Computer）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HardDisk hardDisk;</span><br><span class="line">    <span class="keyword">private</span> Cpu cpu;</span><br><span class="line">    <span class="keyword">private</span> Memory memory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HardDisk <span class="title">getHardDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHardDisk</span><span class="params">(HardDisk hardDisk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hardDisk = hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cpu <span class="title">getCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCpu</span><span class="params">(Cpu cpu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memory <span class="title">getMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(Memory memory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算机工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。</p>
<h2 id="3-4-接口隔离原则"><a href="#3-4-接口隔离原则" class="headerlink" title="3.4 接口隔离原则"></a>3.4 接口隔离原则</h2><p><strong>客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。</strong></p>
<p>下面看一个例子来理解接口隔离原则</p>
<p>【例】安全门案例</p>
<p>我们需要创建一个<code>黑马</code>品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210318194241.png"></p>
<p>上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326103850.png"></p>
<p>代码如下：</p>
<p><strong>AntiTheft（接口）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AntiTheft</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">antiTheft</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Fireproof（接口）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fireproof</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fireproof</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Waterproof（接口）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Waterproof</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">waterproof</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>HeiMaSafetyDoor（类）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeiMaSafetyDoor</span> <span class="keyword">implements</span> <span class="title">AntiTheft</span>,<span class="title">Fireproof</span>,<span class="title">Waterproof</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">antiTheft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防盗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fireproof</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waterproof</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防水&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ItcastSafetyDoor（类）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastSafetyDoor</span> <span class="keyword">implements</span> <span class="title">AntiTheft</span>,<span class="title">Fireproof</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">antiTheft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防盗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fireproof</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-5-迪米特法则"><a href="#3-5-迪米特法则" class="headerlink" title="3.5 迪米特法则"></a>3.5 迪米特法则</h2><p>迪米特法则又叫最少知识原则。</p>
<p>只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。</p>
<p>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
<p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p>
<p>下面看一个例子来理解迪米特法则</p>
<p>【例】明星与经纪人的关系实例</p>
<p>明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p>
<p>类图如下：</p>
<img src="https://gitee.com/Pink_oops/image/raw/master/20210318194803.png" alt="image-20191229173554296" style="zoom:80%;" />

<p>代码如下：</p>
<p><strong>明星类（Star）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Star</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>粉丝类（Fans）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fans</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fans</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>媒体公司类（Company）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Company</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>经纪人类（Agent）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Star star;</span><br><span class="line">    <span class="keyword">private</span> Fans fans;</span><br><span class="line">    <span class="keyword">private</span> Company company;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStar</span><span class="params">(Star star)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.star = star;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFans</span><span class="params">(Fans fans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fans = fans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompany</span><span class="params">(Company company)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.company = company;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meeting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(fans.getName() + <span class="string">&quot;与明星&quot;</span> + star.getName() + <span class="string">&quot;见面了。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(company.getName() + <span class="string">&quot;与明星&quot;</span> + star.getName() + <span class="string">&quot;洽淡业务。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-6-合成复用原则"><a href="#3-6-合成复用原则" class="headerlink" title="3.6 合成复用原则"></a>3.6 合成复用原则</h2><p>合成复用原则是指：<strong>尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</strong></p>
<p>通常类的复用分为继承复用和合成复用两种。</p>
<p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p>
<ol>
<li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li>
<li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li>
<li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li>
</ol>
<p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p>
<ol>
<li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li>
<li>对象间的耦合度低。可以在<strong>类的成员位置声明抽象。</strong></li>
<li>复用的灵活性高。这种复用可以在运行时动态进行，<strong>新对象可以动态地引用与成分对象类型相同的对象。</strong>就是说可以将该对象的成员变量对象重新引用到另一个对象上</li>
</ol>
<p>下面看一个例子来理解合成复用原则</p>
<p>【例】汽车分类管理程序</p>
<p>汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下： </p>
<img src="https://gitee.com/Pink_oops/image/raw/master/20210318194143.png" alt="image-20191229173554296" style="zoom:80%;" />

<p>从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。</p>
<img src="https://gitee.com/Pink_oops/image/raw/master/20210318194129.png" alt="image-20191229173554296" style="zoom:80%;" />



<h1 id="4，创建者模式"><a href="#4，创建者模式" class="headerlink" title="4，创建者模式"></a>4，创建者模式</h1><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。</p>
<p>这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p>
<p>创建型模式分为：</p>
<ul>
<li>单例模式</li>
<li>工厂方法模式</li>
<li>抽象工程模式</li>
<li>原型模式</li>
<li>建造者模式</li>
</ul>
<h2 id="4-1-单例设计模式"><a href="#4-1-单例设计模式" class="headerlink" title="4.1 单例设计模式"></a>4.1 单例设计模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<h3 id="4-1-1-单例模式的结构"><a href="#4-1-1-单例模式的结构" class="headerlink" title="4.1.1 单例模式的结构"></a>4.1.1 单例模式的结构</h3><p>单例模式的主要有以下角色：</p>
<ul>
<li>单例类。只能创建一个实例的类</li>
<li>访问类。使用单例类</li>
</ul>
<h3 id="4-1-2-单例模式的实现"><a href="#4-1-2-单例模式的实现" class="headerlink" title="4.1.2 单例模式的实现"></a>4.1.2 单例模式的实现</h3><blockquote>
<p>单例设计模式分类两种：</p>
<p>​    饿汉式：类加载就会导致该单实例对象被创建    </p>
<p>​    懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p>
</blockquote>
<ol>
<li><p>饿汉式-方式1（静态变量方式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> *      静态变量创建类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color='red'>说明：</font></p>
<p>​    该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。<strong>如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</strong></p>
</li>
</ol>
<ol start="2">
<li><p>饿汉式-方式2（静态代码块方式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恶汉式</span></span><br><span class="line"><span class="comment"> *      在静态代码块中创建该类对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color='red'>说明：</font></p>
<p>​    该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。<strong>所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。</strong></p>
</li>
</ol>
<ol start="3">
<li><p>懒汉式-方式1（线程不安全）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> *  线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color='red'>说明：</font></p>
<p>​    从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。</p>
</li>
</ol>
<ol start="4">
<li><p>懒汉式-方式2（线程安全）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> *  线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color='red'>说明：</font></p>
<p>​    该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。</p>
</li>
</ol>
<ol start="5">
<li><p>懒汉式-方式3（双重检查锁）</p>
<p>再来讨论一下懒汉模式中加锁的问题，对于 <code>getInstance()</code> 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为null</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</p>
<p>要解决双重检查锁模式带来空指针异常的问题，只需要使用 <code>volatile</code> 关键字, <code>volatile</code> 关键字可以保证可见性和有序性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="red">小结：</font></p>
<p>添加 <code>volatile</code> 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。</p>
</li>
</ol>
<ol start="6">
<li><p>懒汉式-方式4（静态内部类方式）</p>
<p>静态内部类单例模式中实例由内部类创建，<strong>由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的</strong>, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>final</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color='red'>说明：</font></p>
<p>​    第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder</p>
<p>并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p>
<p><font color="red">小结：</font></p>
<p>​    静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p>
</li>
</ol>
<ol start="7">
<li><p>枚举方式</p>
<p>枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color='red'>说明：</font></p>
<p>​    枚举方式属于恶汉式方式。</p>
</li>
</ol>
<h3 id="4-1-3-存在的问题"><a href="#4-1-3-存在的问题" class="headerlink" title="4.1.3 存在的问题"></a>4.1.3 存在的问题</h3><h4 id="4-1-3-1-问题演示"><a href="#4-1-3-1-问题演示" class="headerlink" title="4.1.3.1 问题演示"></a>4.1.3.1 问题演示</h4><p>破坏单例模式：</p>
<p>使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。</p>
<ul>
<li><p>序列化反序列化</p>
<p><strong>Singleton类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Test类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//往文件中写对象</span></span><br><span class="line">        <span class="comment">//writeObject2File();</span></span><br><span class="line">        <span class="comment">//从文件中读取对象</span></span><br><span class="line">        Singleton s1 = readObjectFromFile();</span><br><span class="line">        Singleton s2 = readObjectFromFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断两个反序列化后的对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title">readObjectFromFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象输入流对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//第一个读取Singleton对象</span></span><br><span class="line">        Singleton instance = (Singleton) ois.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObject2File</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的对象</span></span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        <span class="comment">//创建对象输出流</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//将instance对象写出到文件中</span></span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式。</p>
</blockquote>
</li>
<li><p>反射</p>
<p><strong>Singleton类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Test类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的字节码对象</span></span><br><span class="line">        Class clazz = Singleton.class;</span><br><span class="line">        <span class="comment">//获取Singleton类的私有无参构造方法对象</span></span><br><span class="line">        Constructor constructor = clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//取消访问检查</span></span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Singleton类的对象s1</span></span><br><span class="line">        Singleton s1 = (Singleton) constructor.newInstance();</span><br><span class="line">        <span class="comment">//创建Singleton类的对象s2</span></span><br><span class="line">        Singleton s2 = (Singleton) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断通过反射创建的两个Singleton对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><font color="red">注意：</font>枚举方式不会出现这两个问题。</p>
</blockquote>
<h4 id="4-1-3-2-问题的解决"><a href="#4-1-3-2-问题的解决" class="headerlink" title="4.1.3.2 问题的解决"></a>4.1.3.2 问题的解决</h4><ul>
<li><p>序列化、反序列方式破坏单例模式的解决方法</p>
<p>在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p>
<p><strong>Singleton类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面是为了解决序列化反序列化破解单例模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>源码解析：</strong></p>
<p>ObjectInputStream类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// if nested read, passHandle contains handle of enclosing object</span></span><br><span class="line">    <span class="keyword">int</span> outerHandle = passHandle;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object obj = readObject0(<span class="keyword">false</span>);<span class="comment">//重点查看readObject0方法</span></span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readObject0</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">case</span> TC_OBJECT:</span><br><span class="line">				<span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));<span class="comment">//重点查看readOrdinaryObject方法</span></span><br><span class="line">			...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        depth--;</span><br><span class="line">        bin.setBlockDataMode(oldMode);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readOrdinaryObject</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类，</span></span><br><span class="line">    obj = desc.isInstantiable() ? desc.newInstance() : <span class="keyword">null</span>; </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true</span></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="keyword">null</span> &amp;&amp; desc.hasReadResolveMethod()) &#123;</span><br><span class="line">    	<span class="comment">// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量</span></span><br><span class="line">    	<span class="comment">// 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。</span></span><br><span class="line">    	Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">     	...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>反射方式破解单例的解决方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           反射破解单例模式需要添加的代码</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="red">说明:</font></p>
<p>​    这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。</p>
</li>
</ul>
<h3 id="4-1-4-JDK源码解析-Runtime类"><a href="#4-1-4-JDK源码解析-Runtime类" class="headerlink" title="4.1.4 JDK源码解析-Runtime类"></a>4.1.4 JDK源码解析-Runtime类</h3><p>Runtime类就是使用的单例设计模式。</p>
<ol>
<li><p>通过源代码查看使用的是哪儿种单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the runtime object associated with the current Java application.</span></span><br><span class="line"><span class="comment">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span></span><br><span class="line"><span class="comment">     * methods and must be invoked with respect to the current runtime object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span></span><br><span class="line"><span class="comment">     *          Java application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Don&#x27;t let anyone else instantiate this class */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面源代码中可以看出Runtime类使用的是饿汉式（静态属性）方式来实现单例模式的。</p>
</li>
</ol>
<ol start="2">
<li><p>使用Runtime类中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取Runtime类对象</span></span><br><span class="line">        Runtime runtime = Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回 Java 虚拟机中的内存总量。</span></span><br><span class="line">        System.out.println(runtime.totalMemory());</span><br><span class="line">        <span class="comment">//返回 Java 虚拟机试图使用的最大内存量。</span></span><br><span class="line">        System.out.println(runtime.maxMemory());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个新的进程执行指定的字符串命令，返回进程对象</span></span><br><span class="line">        Process process = runtime.exec(<span class="string">&quot;ipconfig&quot;</span>);</span><br><span class="line">        <span class="comment">//获取命令执行后的结果，通过输入流获取</span></span><br><span class="line">        InputStream inputStream = process.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>* <span class="number">100</span>];</span><br><span class="line">        <span class="keyword">int</span> b = inputStream.read(arr);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(arr,<span class="number">0</span>,b,<span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="4-2-工厂模式"><a href="#4-2-工厂模式" class="headerlink" title="4.2 工厂模式"></a>4.2 工厂模式</h2><h3 id="4-2-1-概述"><a href="#4-2-1-概述" class="headerlink" title="4.2.1 概述"></a>4.2.1 概述</h3><p>需求：设计一个咖啡店点餐系统。  </p>
<p>设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。</p>
<p>具体类的设计如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104342.png" alt="img"></p>
<p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：<strong>解耦</strong>。</p>
<p>在本教程中会介绍三种工厂的使用</p>
<ul>
<li>简单工厂模式（不属于GOF的23种经典设计模式）</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<h3 id="4-2-2-简单工厂模式"><a href="#4-2-2-简单工厂模式" class="headerlink" title="4.2.2 简单工厂模式"></a>4.2.2 简单工厂模式</h3><p>简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p>
<h4 id="4-2-2-1-结构"><a href="#4-2-2-1-结构" class="headerlink" title="4.2.2.1 结构"></a>4.2.2.1 结构</h4><p>简单工厂包含如下角色：</p>
<ul>
<li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品 ：实现或者继承抽象产品的子类</li>
<li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</li>
</ul>
<h4 id="4-2-2-2-实现"><a href="#4-2-2-2-实现" class="headerlink" title="4.2.2.2 实现"></a>4.2.2.2 实现</h4><p>现在使用简单工厂对上面案例进行改进，类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104342.png" alt="img"></p>
<p>工厂类代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCoffeeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">createCoffee</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Coffee coffee = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> AmericanoCoffee();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> LatteCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。</p>
<p>后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。</p>
<h4 id="4-2-2-4-优缺点"><a href="#4-2-2-4-优缺点" class="headerlink" title="4.2.2.4 优缺点"></a>4.2.2.4 优缺点</h4><p><strong>优点：</strong></p>
<p>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。</p>
<p><strong>缺点：</strong></p>
<p><strong>增加新产品时还是需要修改工厂类的代码</strong>，违背了“开闭原则”。</p>
<h4 id="4-2-2-3-扩展"><a href="#4-2-2-3-扩展" class="headerlink" title="4.2.2.3 扩展"></a>4.2.2.3 扩展</h4><p><strong>静态工厂</strong></p>
<p>在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCoffeeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title">createCoffee</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Coffee coffee = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> AmericanoCoffee();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> LatteCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="4-2-3-工厂方法模式"><a href="#4-2-3-工厂方法模式" class="headerlink" title="4.2.3 工厂方法模式"></a>4.2.3 工厂方法模式</h3><p>针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p>
<h4 id="4-2-3-1-概念"><a href="#4-2-3-1-概念" class="headerlink" title="4.2.3.1 概念"></a>4.2.3.1 概念</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p>
<h4 id="4-2-3-2-结构"><a href="#4-2-3-2-结构" class="headerlink" title="4.2.3.2 结构"></a>4.2.3.2 结构</h4><p>工厂方法模式的主要角色：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ul>
<h4 id="4-2-3-3-实现"><a href="#4-2-3-3-实现" class="headerlink" title="4.2.3.3 实现"></a>4.2.3.3 实现</h4><p>使用工厂方法模式对上例进行改进，类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104342.png" alt="img"></p>
<p>代码如下：</p>
<p>抽象工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoffeeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Coffee <span class="title">createCoffee</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatteCoffeeFactory</span> <span class="keyword">implements</span> <span class="title">CoffeeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">createCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LatteCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanCoffeeFactory</span> <span class="keyword">implements</span> <span class="title">CoffeeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">createCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmericanCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>咖啡店类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CoffeeFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeStore</span><span class="params">(CoffeeFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">orderCoffee</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Coffee coffee = factory.createCoffee();</span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addsugar();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。</p>
<p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p>
<h4 id="4-2-3-4-优缺点"><a href="#4-2-3-4-优缺点" class="headerlink" title="4.2.3.4 优缺点"></a>4.2.3.4 优缺点</h4><p><strong>优点：</strong></p>
<ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度</strong>。</li>
</ul>
<h3 id="4-2-4-抽象工厂模式"><a href="#4-2-4-抽象工厂模式" class="headerlink" title="4.2.4 抽象工厂模式"></a>4.2.4 抽象工厂模式</h3><p>前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。</p>
<p>这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p>
<p>本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104342.png" alt="img"></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104342.png" alt="img"></p>
<h4 id="4-2-4-1-概念"><a href="#4-2-4-1-概念" class="headerlink" title="4.2.4.1 概念"></a>4.2.4.1 概念</h4><p>是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p>
<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式<strong>可生产多个等级的产品</strong>。</p>
<h4 id="4-2-4-2-结构"><a href="#4-2-4-2-结构" class="headerlink" title="4.2.4.2 结构"></a>4.2.4.2 结构</h4><p>抽象工厂模式的主要角色如下：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li>
</ul>
<h4 id="4-2-4-2-实现"><a href="#4-2-4-2-实现" class="headerlink" title="4.2.4.2 实现"></a>4.2.4.2 实现</h4><p>现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104342.png" alt="img"></p>
<p>代码如下：</p>
<p>抽象工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DessertFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Coffee <span class="title">createCoffee</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Dessert <span class="title">createDessert</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//美式甜点工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanDessertFactory</span> <span class="keyword">implements</span> <span class="title">DessertFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">createCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmericanCoffee();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dessert <span class="title">createDessert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MatchaMousse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//意大利风味甜点工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItalyDessertFactory</span> <span class="keyword">implements</span> <span class="title">DessertFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">createCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LatteCoffee();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dessert <span class="title">createDessert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tiramisu();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。</p>
<h4 id="4-2-4-3-优缺点"><a href="#4-2-4-3-优缺点" class="headerlink" title="4.2.4.3 优缺点"></a>4.2.4.3 优缺点</h4><p><strong>优点：</strong></p>
<p>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<p><strong>缺点：</strong></p>
<p>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p>
<h4 id="4-2-4-4-使用场景"><a href="#4-2-4-4-使用场景" class="headerlink" title="4.2.4.4 使用场景"></a>4.2.4.4 使用场景</h4><ul>
<li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</li>
<li>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</li>
<li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li>
</ul>
<p>如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。</p>
<h3 id="4-2-5-模式扩展"><a href="#4-2-5-模式扩展" class="headerlink" title="4.2.5 模式扩展"></a>4.2.5 模式扩展</h3><p><strong>简单工厂+配置文件解除耦合</strong></p>
<p>可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。</p>
<p>第一步：定义配置文件</p>
<p>为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">american=com.itheima.pattern.factory.config_factory.AmericanCoffee</span><br><span class="line">latte=com.itheima.pattern.factory.config_factory.LatteCoffee</span><br></pre></td></tr></table></figure>
<p>第二步：改进工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Coffee&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;bean.properties&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p.load(is);</span><br><span class="line">            <span class="comment">//遍历Properties集合对象</span></span><br><span class="line">            Set&lt;Object&gt; keys = p.keySet();</span><br><span class="line">            <span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">                <span class="comment">//根据键获取值（全类名）</span></span><br><span class="line">                String className = p.getProperty((String) key);</span><br><span class="line">                <span class="comment">//获取字节码对象</span></span><br><span class="line">                Class clazz = Class.forName(className);</span><br><span class="line">                Coffee obj = (Coffee) clazz.newInstance();</span><br><span class="line">                map.put((String)key,obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title">createCoffee</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。</p>
<h3 id="4-2-6-JDK源码解析-Collection-iterator方法"><a href="#4-2-6-JDK源码解析-Collection-iterator方法" class="headerlink" title="4.2.6 JDK源码解析-Collection.iterator方法"></a>4.2.6 JDK源码解析-Collection.iterator方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;令狐冲&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;风清扬&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;任我行&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取迭代器对象</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="comment">//使用迭代器遍历</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            String ele = it.next();</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对上面的代码大家应该很熟，使用迭代器遍历集合，获取集合中的元素。而单列集合获取迭代器的方法就使用到了工厂方法模式。我们看通过类图看看结构：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104420.png" alt="image-20210326104419771"></p>
<p>Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。</p>
<blockquote>
<p>另：</p>
<p>​    1,DateForamt类中的getInstance()方法使用的是工厂模式；</p>
<p>​    2,Calendar类中的getInstance()方法使用的是工厂模式；</p>
</blockquote>
<h2 id="4-3-原型模式"><a href="#4-3-原型模式" class="headerlink" title="4.3 原型模式"></a>4.3 原型模式</h2><h3 id="4-3-1-概述"><a href="#4-3-1-概述" class="headerlink" title="4.3.1 概述"></a>4.3.1 概述</h3><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p>
<h3 id="4-3-2-结构"><a href="#4-3-2-结构" class="headerlink" title="4.3.2 结构"></a>4.3.2 结构</h3><p>原型模式包含如下角色：</p>
<ul>
<li>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</li>
<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>
</ul>
<p>接口类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104429.png" alt="image-20210326104429212"></p>
<h3 id="4-3-3-实现"><a href="#4-3-3-实现" class="headerlink" title="4.3.3 实现"></a>4.3.3 实现</h3><p>原型模式的克隆分为浅克隆和深克隆。</p>
<blockquote>
<p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</p>
<p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p>
</blockquote>
<p>Java中的Object类中提供了 <code>clone()</code> 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下：</p>
<p><strong>Realizetype（具体的原型类）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Realizetype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Realizetype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体的原型对象创建完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Realizetype <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型复制成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>PrototypeTest（测试访问类）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Realizetype r1 = <span class="keyword">new</span> Realizetype();</span><br><span class="line">        Realizetype r2 = r1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;对象r1和r2是同一个对象？&quot;</span> + (r1 == r2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-4-案例"><a href="#4-3-4-案例" class="headerlink" title="4.3.4 案例"></a>4.3.4 案例</h3><p><strong>用原型模式生成“三好学生”奖状</strong></p>
<p>同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。</p>
<p>类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104438.png" alt="image-20210326104438374"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//奖状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Citation</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Citation <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试访问类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CitationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Citation c1 = <span class="keyword">new</span> Citation();</span><br><span class="line">        c1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制奖状</span></span><br><span class="line">        Citation c2 = c1.clone();</span><br><span class="line">        <span class="comment">//将奖状的名字修改李四</span></span><br><span class="line">        c2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-5-使用场景"><a href="#4-3-5-使用场景" class="headerlink" title="4.3.5 使用场景"></a>4.3.5 使用场景</h3><ul>
<li>对象的创建非常复杂，可以使用原型模式快捷的创建对象。</li>
<li>性能和安全要求比较高。</li>
</ul>
<h3 id="4-3-6-扩展（深克隆）"><a href="#4-3-6-扩展（深克隆）" class="headerlink" title="4.3.6 扩展（深克隆）"></a>4.3.6 扩展（深克隆）</h3><p>将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//奖状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Citation</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStu</span><span class="params">(Student stu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stu = stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(stu.getName() + <span class="string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Citation <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CitationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Citation c1 = <span class="keyword">new</span> Citation();</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line">        c1.setStu(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制奖状</span></span><br><span class="line">        Citation c2 = c1.clone();</span><br><span class="line">        <span class="comment">//获取c2奖状所属学生对象</span></span><br><span class="line">        Student stu1 = c2.getStu();</span><br><span class="line">        stu1.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断stu对象和stu1对象是否是同一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<p><img src="/Users/wsy/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B5%84%E6%96%99day02/%E7%AC%94%E8%AE%B0/img%5C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F2.png?lastModify=1616726593" alt="img"></p>
<p>说明：</p>
<p>​    stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用对象流。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CitationTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Citation c1 = <span class="keyword">new</span> Citation();</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line">        c1.setStu(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象输出流对象</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\Think\\Desktop\\b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//将c1对象写出到文件中</span></span><br><span class="line">        oos.writeObject(c1);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象出入流对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\Think\\Desktop\\b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//读取对象</span></span><br><span class="line">        Citation c2 = (Citation) ois.readObject();</span><br><span class="line">        <span class="comment">//获取c2奖状所属学生对象</span></span><br><span class="line">        Student stu1 = c2.getStu();</span><br><span class="line">        stu1.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断stu对象和stu1对象是否是同一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<p><img src="/Users/wsy/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B5%84%E6%96%99day02/%E7%AC%94%E8%AE%B0/img%5C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F3.png?lastModify=1616726593" alt="img"></p>
<blockquote>
<p>注意：Citation类和Student类必须实现Serializable接口，否则会抛NotSerializableException异常。</p>
</blockquote>
<h2 id="4-5-建造者模式"><a href="#4-5-建造者模式" class="headerlink" title="4.5 建造者模式"></a>4.5 建造者模式</h2><h3 id="4-4-1-概述"><a href="#4-4-1-概述" class="headerlink" title="4.4.1 概述"></a>4.4.1 概述</h3><p>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p><img src="/Users/wsy/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B5%84%E6%96%99day02/%E7%AC%94%E8%AE%B0/img/image-20200413225341516.png?lastModify=1616726593" alt="img"></p>
<ul>
<li>分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。</li>
<li>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</li>
<li>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</li>
</ul>
<h3 id="4-4-2-结构"><a href="#4-4-2-结构" class="headerlink" title="4.4.2 结构"></a>4.4.2 结构</h3><p>建造者（Builder）模式包含如下角色：</p>
<ul>
<li>抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 </li>
<li>具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 </li>
<li>产品类（Product）：要创建的复杂对象。</li>
<li>指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 </li>
</ul>
<p>类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104520.png" alt="image-20210326104520306"></p>
<h3 id="4-4-3-实例"><a href="#4-4-3-实例" class="headerlink" title="4.4.3 实例"></a>4.4.3 实例</h3><p><strong>创建共享单车</strong></p>
<p>生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。</p>
<p>这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104530.png" alt="image-20210326104530024"></p>
<p>具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自行车类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bike</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String frame;</span><br><span class="line">    <span class="keyword">private</span> String seat;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> frame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFrame</span><span class="params">(String frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.frame = frame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeat</span><span class="params">(String seat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seat = seat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象 builder 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Bike mBike = <span class="keyword">new</span> Bike();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Bike <span class="title">createBike</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//摩拜单车Builder类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobikeBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mBike.setFrame(<span class="string">&quot;铝合金车架&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mBike.setSeat(<span class="string">&quot;真皮车座&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bike <span class="title">createBike</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ofo单车Builder类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OfoBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mBike.setFrame(<span class="string">&quot;碳纤维车架&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mBike.setSeat(<span class="string">&quot;橡胶车座&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bike <span class="title">createBike</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指挥者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder mBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        mBuilder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bike <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mBuilder.buildFrame();</span><br><span class="line">        mBuilder.buildSeat();</span><br><span class="line">        <span class="keyword">return</span> mBuilder.createBike();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        showBike(<span class="keyword">new</span> OfoBuilder());</span><br><span class="line">        showBike(<span class="keyword">new</span> MobikeBuilder());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showBike</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        Bike bike = director.construct();</span><br><span class="line">        System.out.println(bike.getFrame());</span><br><span class="line">        System.out.println(bike.getSeat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象 builder 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Bike mBike = <span class="keyword">new</span> Bike();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Bike <span class="title">createBike</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bike <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buildFrame();</span><br><span class="line">        <span class="keyword">this</span>.BuildSeat();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.createBike();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<p>这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。</p>
<h3 id="4-4-4-优缺点"><a href="#4-4-4-优缺点" class="headerlink" title="4.4.4 优缺点"></a>4.4.4 优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</li>
<li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li>
<li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li>
<li>建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</li>
</ul>
<p><strong>缺点：</strong></p>
<p>造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p>
<h3 id="4-4-5-使用场景"><a href="#4-4-5-使用场景" class="headerlink" title="4.4.5 使用场景"></a>4.4.5 使用场景</h3><p>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p>
<ul>
<li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li>
<li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li>
</ul>
<h3 id="4-4-6-模式扩展"><a href="#4-4-6-模式扩展" class="headerlink" title="4.4.6 模式扩展"></a>4.4.6 模式扩展</h3><p>建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。</p>
<p>重构前代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(String cpu, String screen, String memory, String mainboard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">        <span class="keyword">this</span>.screen = screen;</span><br><span class="line">        <span class="keyword">this</span>.memory = memory;</span><br><span class="line">        <span class="keyword">this</span>.mainboard = mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCpu</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> screen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScreen</span><span class="params">(String screen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.screen = screen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(String memory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMainboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMainboard</span><span class="params">(String mainboard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainboard = mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Phone&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建Phone对象</span></span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone(<span class="string">&quot;intel&quot;</span>,<span class="string">&quot;三星屏幕&quot;</span>,<span class="string">&quot;金士顿&quot;</span>,<span class="string">&quot;华硕&quot;</span>);</span><br><span class="line">        System.out.println(phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。</p>
<p>重构后代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Phone</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        cpu = builder.cpu;</span><br><span class="line">        screen = builder.screen;</span><br><span class="line">        memory = builder.memory;</span><br><span class="line">        mainboard = builder.mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String cpu;</span><br><span class="line">        <span class="keyword">private</span> String screen;</span><br><span class="line">        <span class="keyword">private</span> String memory;</span><br><span class="line">        <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">cpu</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">            cpu = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">screen</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">            screen = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">memory</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">            memory = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">mainboard</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">            mainboard = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Phone <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Phone(<span class="keyword">this</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Phone&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone.Builder()</span><br><span class="line">                .cpu(<span class="string">&quot;intel&quot;</span>)</span><br><span class="line">                .mainboard(<span class="string">&quot;华硕&quot;</span>)</span><br><span class="line">                .memory(<span class="string">&quot;金士顿&quot;</span>)</span><br><span class="line">                .screen(<span class="string">&quot;三星&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。</p>
<h2 id="4-6-创建者模式对比"><a href="#4-6-创建者模式对比" class="headerlink" title="4.6 创建者模式对比"></a>4.6 创建者模式对比</h2><h3 id="4-6-1-工厂方法模式VS建造者模式"><a href="#4-6-1-工厂方法模式VS建造者模式" class="headerlink" title="4.6.1 工厂方法模式VS建造者模式"></a>4.6.1 工厂方法模式VS建造者模式</h3><p>工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。</p>
<p>我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。</p>
<h3 id="4-6-2-抽象工厂模式VS建造者模式"><a href="#4-6-2-抽象工厂模式VS建造者模式" class="headerlink" title="4.6.2 抽象工厂模式VS建造者模式"></a>4.6.2 抽象工厂模式VS建造者模式</h3><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。</p>
<p>建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p>
<p>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</p>
<h1 id="5，结构型模式"><a href="#5，结构型模式" class="headerlink" title="5，结构型模式"></a>5，结构型模式</h1><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<p>结构型模式分为以下 7 种：</p>
<ul>
<li>代理模式</li>
<li>适配器模式</li>
<li>装饰者模式</li>
<li>桥接模式</li>
<li>外观模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
<h2 id="5-1-代理模式"><a href="#5-1-代理模式" class="headerlink" title="5.1 代理模式"></a>5.1 代理模式</h2><h3 id="5-1-1-概述"><a href="#5-1-1-概述" class="headerlink" title="5.1.1 概述"></a>5.1.1 概述</h3><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。</p>
<h3 id="5-1-2-结构"><a href="#5-1-2-结构" class="headerlink" title="5.1.2 结构"></a>5.1.2 结构</h3><p>代理（Proxy）模式分为三种角色：</p>
<ul>
<li>抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ul>
<h3 id="5-1-3-静态代理"><a href="#5-1-3-静态代理" class="headerlink" title="5.1.3 静态代理"></a>5.1.3 静态代理</h3><p>我们通过案例来感受一下静态代理。</p>
<p>【例】火车站卖票</p>
<p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104757.png" alt="image-20210326104756792"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainStation</span> <span class="keyword">implements</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代售点</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPoint</span> <span class="keyword">implements</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrainStation station = <span class="keyword">new</span> TrainStation();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用&quot;</span>);</span><br><span class="line">        station.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyPoint pp = <span class="keyword">new</span> ProxyPoint();</span><br><span class="line">        pp.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。</p>
<h3 id="5-1-4-JDK动态代理"><a href="#5-1-4-JDK动态代理" class="headerlink" title="5.1.4 JDK动态代理"></a>5.1.4 JDK动态代理</h3><p>接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainStation</span> <span class="keyword">implements</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂，用来创建代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrainStation station = <span class="keyword">new</span> TrainStation();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SellTickets <span class="title">getProxyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用Proxy获取代理对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            newProxyInstance()方法参数说明：</span></span><br><span class="line"><span class="comment">                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可</span></span><br><span class="line"><span class="comment">                Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口</span></span><br><span class="line"><span class="comment">                InvocationHandler h ： 代理对象的调用处理程序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        InvocationHandler中invoke方法参数说明：</span></span><br><span class="line"><span class="comment">                            proxy ： 代理对象</span></span><br><span class="line"><span class="comment">                            method ： 对应于在代理对象上调用的接口方法的 Method 实例</span></span><br><span class="line"><span class="comment">                            args ： 代理对象调用接口方法时传递的实际参数</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        <span class="comment">//执行真实对象</span></span><br><span class="line">                        Object result = method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        ProxyFactory factory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        </span><br><span class="line">        SellTickets proxyObject = factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="red">使用了动态代理，我们思考下面问题：</font></p>
<ul>
<li><p>ProxyFactory是代理类吗？</p>
<p>ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.proxy.dynamic.jdk.SellTickets;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="keyword">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchMethodException noSuchMethodException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(noSuchMethodException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(classNotFoundException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;object&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m2, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m0, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的类中，我们可以看到以下几个信息：</p>
<ul>
<li>代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。</li>
<li>代理类（$Proxy0）<strong>将我们提供了的匿名内部类对象传递给了父类。</strong></li>
</ul>
</li>
<li><p>动态代理的执行流程是什么样？</p>
<p>下面是摘取的重点代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序运行过程中动态生成的代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="keyword">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m3 = Class.forName(<span class="string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java提供的动态代理相关类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line">	 </span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">(InvocationHandler h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrainStation station = <span class="keyword">new</span> TrainStation();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SellTickets <span class="title">getProxyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        Object result = method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试访问类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        ProxyFactory factory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        SellTickets proxyObject = factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>执行流程如下：</p>
<pre><code>1. 在测试类中通过代理对象调用sell()方法
2. 根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法
3. 代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法
4. invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法</code></pre>
<h3 id="5-1-5-CGLIB动态代理"><a href="#5-1-5-CGLIB动态代理" class="headerlink" title="5.1.5 CGLIB动态代理"></a>5.1.5 CGLIB动态代理</h3><p>同样是上面的案例，我们再次使用CGLIB代理实现。</p>
<p>如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。</p>
<p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。</p>
<p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//火车站</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainStation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrainStation target = <span class="keyword">new</span> TrainStation();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrainStation <span class="title">getProxyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span></span><br><span class="line">        Enhancer enhancer =<span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        TrainStation obj = (TrainStation) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        intercept方法参数说明：</span></span><br><span class="line"><span class="comment">            o ： 代理对象</span></span><br><span class="line"><span class="comment">            method ： 真实对象中的方法的Method实例</span></span><br><span class="line"><span class="comment">            args ： 实际参数</span></span><br><span class="line"><span class="comment">            methodProxy ：代理对象中的方法的method实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrainStation <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;</span>);</span><br><span class="line">        TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建代理工厂对象</span></span><br><span class="line">        ProxyFactory factory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        TrainStation proxyObject = factory.getProxyObject();</span><br><span class="line"></span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-6-三种代理的对比"><a href="#5-1-6-三种代理的对比" class="headerlink" title="5.1.6 三种代理的对比"></a>5.1.6 三种代理的对比</h3><ul>
<li><p>jdk代理和CGLIB代理</p>
<p>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p>
<p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。</p>
</li>
<li><p>动态代理和静态代理</p>
<p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p>
<p>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题</p>
</li>
</ul>
<h3 id="5-1-7-优缺点"><a href="#5-1-7-优缺点" class="headerlink" title="5.1.7 优缺点"></a>5.1.7 优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>增加了系统的复杂度；</li>
</ul>
<h3 id="5-1-8-使用场景"><a href="#5-1-8-使用场景" class="headerlink" title="5.1.8 使用场景"></a>5.1.8 使用场景</h3><ul>
<li><p>远程（Remote）代理</p>
<p>本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。</p>
</li>
<li><p>防火墙（Firewall）代理</p>
<p>当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。</p>
</li>
<li><p>保护（Protect or Access）代理</p>
<p>控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。</p>
</li>
</ul>
<h2 id="5-2-适配器模式"><a href="#5-2-适配器模式" class="headerlink" title="5.2 适配器模式"></a>5.2 适配器模式</h2><h3 id="5-2-1-概述"><a href="#5-2-1-概述" class="headerlink" title="5.2.1 概述"></a>5.2.1 概述</h3><p>如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104820.png" alt="image-20210326104819910"></p>
<p><strong>定义：</strong></p>
<p>​    将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
<p>​    适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<h3 id="5-2-2-结构"><a href="#5-2-2-结构" class="headerlink" title="5.2.2 结构"></a>5.2.2 结构</h3><p>适配器模式（Adapter）包含以下主要角色：</p>
<ul>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ul>
<h3 id="5-2-3-类适配器模式"><a href="#5-2-3-类适配器模式" class="headerlink" title="5.2.3 类适配器模式"></a>5.2.3 类适配器模式</h3><p>实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p>
<p>【例】读卡器</p>
<p>现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。</p>
<p>类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104830.png" alt="image-20210326104829484"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SD卡的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SDCard</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读取SD卡方法</span></span><br><span class="line">    <span class="function">String <span class="title">readSD</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//写入SD卡功能</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeSD</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SD卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDCardImpl</span> <span class="keyword">implements</span> <span class="title">SDCard</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;sd card read a msg :hello word SD&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSD</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sd card write msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">(SDCard sdCard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sdCard == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;sd card null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sdCard.readSD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TFCard</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读取TF卡方法</span></span><br><span class="line">    <span class="function">String <span class="title">readTF</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//写入TF卡功能</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeTF</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TFCardImpl</span> <span class="keyword">implements</span> <span class="title">TFCard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readTF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String msg =<span class="string">&quot;tf card read msg : hello word tf card&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTF</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tf card write a msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义适配器类（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDAdapterTF</span> <span class="keyword">extends</span> <span class="title">TFCardImpl</span> <span class="keyword">implements</span> <span class="title">SDCard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSD</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        SDCard sdCard = <span class="keyword">new</span> SDCardImpl();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        SDAdapterTF adapter = <span class="keyword">new</span> SDAdapterTF();</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。</p>
<h3 id="5-2-4-对象适配器模式"><a href="#5-2-4-对象适配器模式" class="headerlink" title="5.2.4 对象适配器模式"></a>5.2.4 对象适配器模式</h3><p>实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p>
<p>【例】读卡器</p>
<p>我们使用对象适配器模式将读卡器的案例进行改写。类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104837.png" alt="image-20210326104837276"></p>
<p>代码如下：</p>
<p>类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。</p>
<p>组合和聚合比继承耦合度更低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建适配器对象（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDAdapterTF</span>  <span class="keyword">implements</span> <span class="title">SDCard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tfCard = tfCard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSD</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        tfCard.writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        SDCard sdCard = <span class="keyword">new</span> SDCardImpl();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        TFCard tfCard = <span class="keyword">new</span> TFCardImpl();</span><br><span class="line">        SDAdapterTF adapter = <span class="keyword">new</span> SDAdapterTF(tfCard);</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<strong>还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。</strong></p>
</blockquote>
<h3 id="5-2-5-应用场景"><a href="#5-2-5-应用场景" class="headerlink" title="5.2.5 应用场景"></a>5.2.5 应用场景</h3><ul>
<li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li>
<li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li>
</ul>
<h3 id="5-2-6-JDK源码解析"><a href="#5-2-6-JDK源码解析" class="headerlink" title="5.2.6 JDK源码解析"></a>5.2.6 JDK源码解析</h3><p>Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。</p>
<p>InputStreamReader继承自java.io包中的Reader，对他中的抽象的未实现的方法给出实现。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sd.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sd.read(cbuf, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码中的sd（StreamDecoder类对象），在Sun的JDK实现中，实际的方法实现是对sun.nio.cs.StreamDecoder类的同名方法的调用封装。类结构图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104848.png"></p>
<p>从上图可以看出：</p>
<ul>
<li>InputStreamReader是对同样实现了Reader的StreamDecoder的封装。</li>
<li>StreamDecoder不是Java SE API中的内容，是Sun  JDK给出的自身实现。但我们知道他们对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换。</li>
</ul>
<p><font color="red">结论：</font></p>
<p>​    从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式。</p>
<h2 id="5-3-装饰者模式"><a href="#5-3-装饰者模式" class="headerlink" title="5.3 装饰者模式"></a>5.3 装饰者模式</h2><h3 id="5-3-1-概述"><a href="#5-3-1-概述" class="headerlink" title="5.3.1 概述"></a>5.3.1 概述</h3><p>我们先来看一个快餐店的例子。</p>
<p>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326103700.png" alt="image-20210326103654794"></p>
<p>使用继承的方式存在的问题：</p>
<ul>
<li><p>扩展性不好</p>
<p>如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。</p>
</li>
<li><p>产生过多的子类</p>
</li>
</ul>
<p><strong>定义：</strong></p>
<p>​    指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p>
<h3 id="5-3-2-结构"><a href="#5-3-2-结构" class="headerlink" title="5.3.2 结构"></a>5.3.2 结构</h3><p>装饰（Decorator）模式中的角色：</p>
<ul>
<li>抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（Concrete  Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ul>
<h3 id="5-3-3-案例"><a href="#5-3-3-案例" class="headerlink" title="5.3.3 案例"></a>5.3.3 案例</h3><p>我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。</p>
<p>类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104902.png" alt="image-20210326104901644"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快餐接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FastFood</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastFood</span><span class="params">(<span class="keyword">float</span> price, String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span></span>;  <span class="comment">//获取价格</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒饭</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FriedRice</span> <span class="keyword">extends</span> <span class="title">FastFood</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FriedRice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">10</span>, <span class="string">&quot;炒饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FriedNoodles</span> <span class="keyword">extends</span> <span class="title">FastFood</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FriedNoodles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">12</span>, <span class="string">&quot;炒面&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配料类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Garnish</span> <span class="keyword">extends</span> <span class="title">FastFood</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FastFood fastFood;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FastFood <span class="title">getFastFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFastFood</span><span class="params">(FastFood fastFood)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Garnish</span><span class="params">(FastFood fastFood, <span class="keyword">float</span> price, String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(price,desc);</span><br><span class="line">        <span class="keyword">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鸡蛋配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Egg</span> <span class="keyword">extends</span> <span class="title">Garnish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Egg</span><span class="params">(FastFood fastFood)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(fastFood,<span class="number">1</span>,<span class="string">&quot;鸡蛋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//培根配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bacon</span> <span class="keyword">extends</span> <span class="title">Garnish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bacon</span><span class="params">(FastFood fastFood)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(fastFood,<span class="number">2</span>,<span class="string">&quot;培根&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//点一份炒饭</span></span><br><span class="line">        FastFood food = <span class="keyword">new</span> FriedRice();</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">&quot; &quot;</span> + food.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加鸡蛋的炒饭</span></span><br><span class="line">        FastFood food1 = <span class="keyword">new</span> FriedRice();</span><br><span class="line"></span><br><span class="line">        food1 = <span class="keyword">new</span> Egg(food1);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food1.getDesc() + <span class="string">&quot; &quot;</span> + food1.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加培根的炒面</span></span><br><span class="line">        FastFood food2 = <span class="keyword">new</span> FriedNoodles();</span><br><span class="line">        food2 = <span class="keyword">new</span> Bacon(food2);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food2.getDesc() + <span class="string">&quot; &quot;</span> + food2.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>好处：</strong></p>
<ul>
<li><p>饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</p>
</li>
<li><p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
</li>
</ul>
<h3 id="5-3-4-使用场景"><a href="#5-3-4-使用场景" class="headerlink" title="5.3.4 使用场景"></a>5.3.4 使用场景</h3><ul>
<li><p>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</p>
<p>不能采用继承的情况主要有两类：</p>
<ul>
<li>第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；</li>
<li>第二类是因为类定义不能继承（如final类）</li>
</ul>
</li>
<li><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p>
</li>
<li><p>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</p>
</li>
</ul>
<h3 id="5-3-5-JDK源码解析"><a href="#5-3-5-JDK源码解析" class="headerlink" title="5.3.5 JDK源码解析"></a>5.3.5 JDK源码解析</h3><p>IO流中的包装类使用到了装饰者模式。BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter。</p>
<p>我们以BufferedWriter举例来说明，先看看如何使用BufferedWriter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建BufferedWriter对象</span></span><br><span class="line">        <span class="comment">//创建FileWriter对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>);</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        bw.write(<span class="string">&quot;hello Buffered&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用起来感觉确实像是装饰者模式，接下来看它们的结构：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326104953.png"></p>
<blockquote>
<p><font color="red">小结：</font></p>
<p>​    BufferedWriter使用装饰者模式对Writer子实现类进行了增强，添加了缓冲区，提高了写数据的效率。</p>
</blockquote>
<h3 id="5-3-6-代理和装饰者的区别"><a href="#5-3-6-代理和装饰者的区别" class="headerlink" title="5.3.6 代理和装饰者的区别"></a>5.3.6 代理和装饰者的区别</h3><p>静态代理和装饰者模式的区别：</p>
<ul>
<li>相同点：<ul>
<li>都要实现与目标类相同的业务接口</li>
<li>在两个类中都要声明目标对象</li>
<li>都可以在不修改目标类的前提下增强目标方法</li>
</ul>
</li>
<li>不同点：<ul>
<li>目的不同<br>装饰者是为了增强目标对象<br>静态代理是为了保护和隐藏目标对象</li>
<li>获取目标对象构建的地方不同<br><strong>装饰者是由外界传递进来，可以通过构造方法传递</strong><br><strong>静态代理是在代理类内部创建，以此来隐藏目标对象</strong></li>
</ul>
</li>
</ul>
<h2 id="5-4-桥接模式"><a href="#5-4-桥接模式" class="headerlink" title="5.4 桥接模式"></a>5.4 桥接模式</h2><h3 id="5-4-1-概述"><a href="#5-4-1-概述" class="headerlink" title="5.4.1 概述"></a>5.4.1 概述</h3><p>现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105008.png"></p>
<p>我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。</p>
<p>试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。</p>
<p><strong>定义：</strong></p>
<p>​    将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<h3 id="5-4-2-结构"><a href="#5-4-2-结构" class="headerlink" title="5.4.2 结构"></a>5.4.2 结构</h3><p>桥接（Bridge）模式包含以下主要角色：</p>
<ul>
<li>抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。</li>
<li>扩展抽象化（Refined  Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>
<li>实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。</li>
<li>具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。</li>
</ul>
<h3 id="5-4-3-案例"><a href="#5-4-3-案例" class="headerlink" title="5.4.3 案例"></a>5.4.3 案例</h3><p>【例】视频播放器</p>
<p>需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。</p>
<p>类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105017.png" alt="image-20210326105016322"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//视频文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">VideoFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//avi文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVIFile</span> <span class="keyword">implements</span> <span class="title">VideoFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;avi视频文件：&quot;</span>+ fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rmvb文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">REVBBFile</span> <span class="keyword">implements</span> <span class="title">VideoFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rmvb文件：&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作系统版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatingSystemVersion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> VideoFile videoFile;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperatingSystemVersion</span><span class="params">(VideoFile videoFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.videoFile = videoFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Windows版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Windows</span> <span class="keyword">extends</span> <span class="title">OperatingSystemVersion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Windows</span><span class="params">(VideoFile videoFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mac版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mac</span> <span class="keyword">extends</span> <span class="title">OperatingSystemVersion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mac</span><span class="params">(VideoFile videoFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">		videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OperatingSystem os = <span class="keyword">new</span> Windows(<span class="keyword">new</span> AVIFile());</span><br><span class="line">        os.play(<span class="string">&quot;战狼3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>好处：</strong></p>
<ul>
<li><p>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</p>
<p>如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。</p>
</li>
<li><p>实现细节对客户透明</p>
</li>
</ul>
<h3 id="5-4-4-使用场景"><a href="#5-4-4-使用场景" class="headerlink" title="5.4.4 使用场景"></a>5.4.4 使用场景</h3><ul>
<li>当一个类存在两个独立变化的维度，且这<strong>两个维度都需要进行扩展时</strong>。</li>
<li>当一个系统<strong>不希望使用继承或因为多层次继承导致系统类的个数急剧增加时</strong>。</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>
</ul>
<h2 id="5-5-外观模式"><a href="#5-5-外观模式" class="headerlink" title="5.5 外观模式"></a>5.5 外观模式</h2><h3 id="5-5-1-概述"><a href="#5-5-1-概述" class="headerlink" title="5.5.1 概述"></a>5.5.1 概述</h3><p>有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。</p>
<p><strong>定义：</strong></p>
<p>​    又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>
<p>​    外观（Facade）模式是<strong>“迪米特法则”</strong>的典型应用</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105025.png"></p>
<h3 id="5-5-2-结构"><a href="#5-5-2-结构" class="headerlink" title="5.5.2 结构"></a>5.5.2 结构</h3><p>外观（Facade）模式包含以下主要角色：</p>
<ul>
<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li>
<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>
</ul>
<h3 id="5-5-3-案例"><a href="#5-5-3-案例" class="headerlink" title="5.5.3 案例"></a>5.5.3 案例</h3><p>【例】智能家电控制</p>
<p>小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105033.png" alt="image-20210326105033214"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//灯类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了灯....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了灯....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电视类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了电视....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了电视....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirCondition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了空调....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了空调....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//智能音箱</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartAppliancesFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line">    <span class="keyword">private</span> AirCondition airCondition;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmartAppliancesFacade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light = <span class="keyword">new</span> Light();</span><br><span class="line">        tv = <span class="keyword">new</span> TV();</span><br><span class="line">        airCondition = <span class="keyword">new</span> AirCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(message.contains(<span class="string">&quot;打开&quot;</span>)) &#123;</span><br><span class="line">            on();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(message.contains(<span class="string">&quot;关闭&quot;</span>)) &#123;</span><br><span class="line">            off();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我还听不懂你说的！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//起床后一键开电器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;起床了&quot;</span>);</span><br><span class="line">        light.on();</span><br><span class="line">        tv.on();</span><br><span class="line">        airCondition.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//睡觉一键关电器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉了&quot;</span>);</span><br><span class="line">        light.off();</span><br><span class="line">        tv.off();</span><br><span class="line">        airCondition.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建外观对象</span></span><br><span class="line">        SmartAppliancesFacade facade = <span class="keyword">new</span> SmartAppliancesFacade();</span><br><span class="line">        <span class="comment">//客户端直接与外观对象进行交互</span></span><br><span class="line">        facade.say(<span class="string">&quot;打开家电&quot;</span>);</span><br><span class="line">        facade.say(<span class="string">&quot;关闭家电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>好处：</strong></p>
<ul>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不符合开闭原则，修改很麻烦</li>
</ul>
<h3 id="5-5-4-使用场景"><a href="#5-5-4-使用场景" class="headerlink" title="5.5.4 使用场景"></a>5.5.4 使用场景</h3><ul>
<li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>
<li><strong>当一个复杂系统的子系统很多时</strong>，外观模式可以为系统设计一个简单的接口供外界访问。</li>
<li><strong>当客户端与多个子系统之间存在很大的联系时</strong>，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li>
</ul>
<h3 id="5-5-5-源码解析"><a href="#5-5-5-源码解析" class="headerlink" title="5.5.5 源码解析"></a>5.5.5 源码解析</h3><p>使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成<strong>ServletRequest</strong>对象，如下图①处对象。但是大家想想ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道该request对象肯定是一个<strong>HttpServletRequest</strong>对象的子实现类对象，到底是哪个类的对象呢？可以通过输出request对象，我们就会发现是一个名为<strong>RequestFacade</strong>的类的对象。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105043.png" alt="image-20210326105043198"></p>
<p>RequestFacade类就使用了外观模式。先看结构图：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105050.png" alt="image-20210326105049889"></p>
<p><strong>为什么在此处使用外观模式呢？</strong></p>
<p>​    定义 RequestFacade 类，分别实现 ServletRequest ，同时定义私有成员变量 Request ，并且方法的实现调用 Request  的实现。然后，将 RequestFacade上转为 ServletRequest  传给 servlet 的 service 方法，这样即使在 servlet 中被下转为 RequestFacade ，也不能访问私有成员变量对象中的方法。既用了 Request ，又能防止其中方法被不合理的访问。</p>
<h2 id="5-6-组合模式"><a href="#5-6-组合模式" class="headerlink" title="5.6 组合模式"></a>5.6 组合模式</h2><h3 id="5-6-1-概述"><a href="#5-6-1-概述" class="headerlink" title="5.6.1 概述"></a>5.6.1 概述</h3><p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105423.png" alt="image-20210326105422638"></p>
<p>​    对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。</p>
<p><strong>定义：</strong></p>
<p>​    又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
<h3 id="5-6-2-结构"><a href="#5-6-2-结构" class="headerlink" title="5.6.2 结构"></a>5.6.2 结构</h3><p>组合模式主要包含三种角色：</p>
<ul>
<li>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li>
<li>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</li>
<li>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li>
</ul>
<h3 id="5-6-3-案例实现"><a href="#5-6-3-案例实现" class="headerlink" title="5.6.3 案例实现"></a>5.6.3 案例实现</h3><p>【例】软件菜单</p>
<p>如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105433.png" alt="image-20210326105432270"></p>
<p>要实现该案例，我们先画出类图：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105442.png" alt="image-20210326105441722"></p>
<p><strong>代码实现：</strong></p>
<p>不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//菜单组件  不管是菜单还是菜单项，都应该继承该类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加菜单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(MenuComponent menuComponent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除菜单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(MenuComponent menuComponent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定的子菜单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MenuComponent <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取菜单名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">extends</span> <span class="title">MenuComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt; menuComponentList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Menu</span><span class="params">(String name,<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        menuComponentList = <span class="keyword">new</span> ArrayList&lt;MenuComponent&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(MenuComponent menuComponent)</span> </span>&#123;</span><br><span class="line">        menuComponentList.add(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(MenuComponent menuComponent)</span> </span>&#123;</span><br><span class="line">        menuComponentList.remove(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MenuComponent <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> menuComponentList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">for</span> (MenuComponent menuComponent : menuComponentList) &#123;</span><br><span class="line">            menuComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Menu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span> <span class="keyword">extends</span> <span class="title">MenuComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MenuItem</span><span class="params">(String name,<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。</p>
<p>定义一个抽象类成为抽象根节点</p>
<p>定义一个该抽象类的实现类成为树枝节点 该节点中成员有抽象根节点的集合 可以存放树枝节点或树叶节点 因为抽象根节点有两个实现类 就是树枝节点和树叶节点</p>
<p>定一一个该抽象类的实现类成为树叶节点 该节点中只有输出</p>
<h3 id="5-6-4-组合模式的分类"><a href="#5-6-4-组合模式的分类" class="headerlink" title="5.6.4 组合模式的分类"></a>5.6.4 组合模式的分类</h3><p>在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。</p>
<ul>
<li><p>透明组合模式</p>
<p>透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 <code>MenuComponent</code> 声明了 <code>add</code>、<code>remove</code> 、<code>getChild</code> 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。</p>
<p>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这<strong>在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错</strong>（如果没有提供相应的错误处理代码）</p>
</li>
<li><p>安全组合模式</p>
<p>在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 <code>Menu</code> 类中声明并实现这些方法。安全组合模式的缺点是<strong>不够透明</strong>，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，<strong>必须有区别地对待叶子构件和容器构件</strong>。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105455.png" alt="image-20210326105454555"></p>
</li>
</ul>
<h3 id="5-6-5-优点"><a href="#5-6-5-优点" class="headerlink" title="5.6.5 优点"></a>5.6.5 优点</h3><ul>
<li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li>
<li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li>
<li>在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</li>
<li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li>
</ul>
<h3 id="5-6-6-使用场景"><a href="#5-6-6-使用场景" class="headerlink" title="5.6.6 使用场景"></a>5.6.6 使用场景</h3><p><strong>组合模式正是应树形结构而生</strong>，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。</p>
<h2 id="5-7-享元模式"><a href="#5-7-享元模式" class="headerlink" title="5.7 享元模式"></a>5.7 享元模式</h2><h3 id="5-7-1-概述"><a href="#5-7-1-概述" class="headerlink" title="5.7.1 概述"></a>5.7.1 概述</h3><p><strong>定义：</strong></p>
<p>​    运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p>
<h3 id="5-7-2-结构"><a href="#5-7-2-结构" class="headerlink" title="5.7.2 结构"></a>5.7.2 结构</h3><p>享元（Flyweight ）模式中存在以下两种状态：</p>
<ol>
<li>内部状态，即不会随着环境的改变而改变的可共享部分。</li>
<li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</li>
</ol>
<p>享元模式的主要有以下角色：</p>
<ul>
<li>抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li>
<li>具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li>
<li>非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li>
<li>享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li>
</ul>
<h3 id="5-7-3-案例实现"><a href="#5-7-3-案例实现" class="headerlink" title="5.7.3 案例实现"></a>5.7.3 案例实现</h3><p>【例】俄罗斯方块</p>
<p>下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105505.png" alt="image-20210326105505257"></p>
<p><strong>先来看类图：</strong></p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105514.png" alt="image-20210326105513602"></p>
<p><strong>代码如下：</strong></p>
<p>俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getShape</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方块形状：&quot;</span> + <span class="keyword">this</span>.getShape() + <span class="string">&quot; 颜色：&quot;</span> + color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IBox</span> <span class="keyword">extends</span> <span class="title">AbstractBox</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LBox</span> <span class="keyword">extends</span> <span class="title">AbstractBox</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;L&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OBox</span> <span class="keyword">extends</span> <span class="title">AbstractBox</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, AbstractBox&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BoxFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;String, AbstractBox&gt;();</span><br><span class="line">        AbstractBox iBox = <span class="keyword">new</span> IBox();</span><br><span class="line">        AbstractBox lBox = <span class="keyword">new</span> LBox();</span><br><span class="line">        AbstractBox oBox = <span class="keyword">new</span> OBox();</span><br><span class="line">        map.put(<span class="string">&quot;I&quot;</span>, iBox);</span><br><span class="line">        map.put(<span class="string">&quot;L&quot;</span>, lBox);</span><br><span class="line">        map.put(<span class="string">&quot;O&quot;</span>, oBox);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BoxFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BoxFactory INSTANCE = <span class="keyword">new</span> BoxFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractBox <span class="title">getBox</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="5-7-5-优缺点和使用场景"><a href="#5-7-5-优缺点和使用场景" class="headerlink" title="5.7.5 优缺点和使用场景"></a>5.7.5 优缺点和使用场景</h3><p><strong>1，优点</strong></p>
<ul>
<li>极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</li>
<li>享元模式中的外部状态相对独立，且不影响内部状态</li>
</ul>
<p><strong>2，缺点：</strong></p>
<p>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</p>
<p><strong>3，使用场景：</strong></p>
<ul>
<li><strong>一个系统有大量相同或者相似的对象</strong>，造成内存的大量耗费。</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li>
<li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li>
</ul>
<h3 id="5-7-6-JDK源码解析"><a href="#5-7-6-JDK源码解析" class="headerlink" title="5.7.6 JDK源码解析"></a>5.7.6 JDK源码解析</h3><p>Integer类使用了享元模式。我们先看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1 = <span class="number">127</span>;</span><br><span class="line">        Integer i2 = <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;i1和i2对象是否是同一个对象？&quot;</span> + (i1 == i2));</span><br><span class="line"></span><br><span class="line">        Integer i3 = <span class="number">128</span>;</span><br><span class="line">        Integer i4 = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;i3和i4对象是否是同一个对象？&quot;</span> + (i3 == i4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面代码，结果如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105525.png" alt="image-20210326105524552"></p>
<p>为什么第一个输出语句输出的是true，第二个输出语句输出的是false？通过反编译软件进行反编译，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1 = Integer.valueOf((<span class="keyword">int</span>)<span class="number">127</span>);</span><br><span class="line">        Integer i2 Integer.valueOf((<span class="keyword">int</span>)<span class="number">127</span>);</span><br><span class="line">        System.out.println((String)<span class="keyword">new</span> StringBuilder().append((String)<span class="string">&quot;i1\u548ci2\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f&quot;</span>).append((<span class="keyword">boolean</span>)(i1 == i2)).toString());</span><br><span class="line">        Integer i3 = Integer.valueOf((<span class="keyword">int</span>)<span class="number">128</span>);</span><br><span class="line">        Integer i4 = Integer.valueOf((<span class="keyword">int</span>)<span class="number">128</span>);</span><br><span class="line">        System.out.println((String)<span class="keyword">new</span> StringBuilder().append((String)<span class="string">&quot;i3\u548ci4\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f&quot;</span>).append((<span class="keyword">boolean</span>)(i3 == i4)).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码可以看到，直接给Integer类型的变量赋值基本数据类型数据的操作底层使用的是 <code>valueOf()</code> ，所以只需要看该方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>Integer</code> 默认先创建并缓存 <code>-128 ~ 127</code> 之间数的 <code>Integer</code> 对象，当调用 <code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code> 之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code> 对象。</p>
<h1 id="6，行为型模式"><a href="#6，行为型模式" class="headerlink" title="6，行为型模式"></a>6，行为型模式</h1><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p>
<p>行为型模式分为：</p>
<ul>
<li>模板方法模式</li>
<li>策略模式</li>
<li>命令模式</li>
<li>职责链模式</li>
<li>状态模式</li>
<li>观察者模式</li>
<li>中介者模式</li>
<li>迭代器模式</li>
<li>访问者模式</li>
<li>备忘录模式</li>
<li>解释器模式</li>
</ul>
<p>以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。</p>
<h2 id="6-1-模板方法模式"><a href="#6-1-模板方法模式" class="headerlink" title="6.1 模板方法模式"></a>6.1 模板方法模式</h2><h3 id="6-1-1-概述"><a href="#6-1-1-概述" class="headerlink" title="6.1.1 概述"></a>6.1.1 概述</h3><p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p>
<p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p>
<p><strong>定义：</strong></p>
<p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p>
<h3 id="6-1-2-结构"><a href="#6-1-2-结构" class="headerlink" title="6.1.2 结构"></a>6.1.2 结构</h3><p>模板方法（Template Method）模式包含以下主要角色：</p>
<ul>
<li><p>抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</p>
<ul>
<li><p>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p>
</li>
<li><p>基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：</p>
<ul>
<li><p>抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。</p>
</li>
<li><p>具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</p>
</li>
<li><p>钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p>
<p>一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</p>
</li>
</ul>
<h3 id="6-1-3-案例实现"><a href="#6-1-3-案例实现" class="headerlink" title="6.1.3 案例实现"></a>6.1.3 案例实现</h3><p>【例】炒菜</p>
<p>炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105541.png" alt="image-20210326105540392"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">cookProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一步：倒油</span></span><br><span class="line">        <span class="keyword">this</span>.pourOil();</span><br><span class="line">        <span class="comment">//第二步：热油</span></span><br><span class="line">        <span class="keyword">this</span>.heatOil();</span><br><span class="line">        <span class="comment">//第三步：倒蔬菜</span></span><br><span class="line">        <span class="keyword">this</span>.pourVegetable();</span><br><span class="line">        <span class="comment">//第四步：倒调味料</span></span><br><span class="line">        <span class="keyword">this</span>.pourSauce();</span><br><span class="line">        <span class="comment">//第五步：翻炒</span></span><br><span class="line">        <span class="keyword">this</span>.fry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pourOil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;倒油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：热油是一样的，所以直接实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heatOil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;热油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pourVegetable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：倒调味料是不一样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pourSauce</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五步：翻炒是一样的，所以直接实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fry</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;炒啊炒啊炒到熟啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass_BaoCai</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pourVegetable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是包菜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pourSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是辣椒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass_CaiXin</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pourVegetable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是菜心&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pourSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是蒜蓉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//炒手撕包菜</span></span><br><span class="line">        ConcreteClass_BaoCai baoCai = <span class="keyword">new</span> ConcreteClass_BaoCai();</span><br><span class="line">        baoCai.cookProcess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//炒蒜蓉菜心</span></span><br><span class="line">        ConcreteClass_CaiXin caiXin = <span class="keyword">new</span> ConcreteClass_CaiXin();</span><br><span class="line">        caiXin.cookProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：为防止恶意操作，一般模板方法都加上 <strong>final</strong> 关键词。</p>
</blockquote>
<h3 id="6-1-3-优缺点"><a href="#6-1-3-优缺点" class="headerlink" title="6.1.3 优缺点"></a>6.1.3 优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li><p>提高代码复用性</p>
<p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p>
</li>
<li><p>实现了反向控制</p>
<p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>
</ul>
<h3 id="6-1-4-适用场景"><a href="#6-1-4-适用场景" class="headerlink" title="6.1.4 适用场景"></a>6.1.4 适用场景</h3><ul>
<li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>
<li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li>
</ul>
<h3 id="6-1-5-JDK源码解析"><a href="#6-1-5-JDK源码解析" class="headerlink" title="6.1.5 JDK源码解析"></a>6.1.5 JDK源码解析</h3><p>InputStream类就使用了模板方法模式。在InputStream类中定义了多个 <code>read()</code> 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象方法，要求子类必须重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = read(); <span class="comment">//调用了无参的read方法，该方法是每次读取一个字节数据</span></span><br><span class="line">        <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b[off] = (<span class="keyword">byte</span>)c;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; len ; i++) &#123;</span><br><span class="line">                c = read();</span><br><span class="line">                <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                b[off + i] = (<span class="keyword">byte</span>)c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ee) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看到，无参的 <code>read()</code> 方法是抽象方法，要求子类必须实现。而 <code>read(byte b[])</code> 方法调用了 <code>read(byte b[], int off, int len)</code> 方法，所以在此处重点看的方法是带三个参数的方法。 </p>
<p>在该方法中第18行、27行，可以看到调用了无参的抽象的 <code>read()</code> 方法。</p>
<p>总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。</p>
<p>在父类中调用子类的方法，实现反转。</p>
<h2 id="6-2-策略模式"><a href="#6-2-策略模式" class="headerlink" title="6.2 策略模式"></a>6.2 策略模式</h2><h3 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1 概述"></a>6.2.1 概述</h3><p>先看下面的图片，我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105553.png" alt="image-20210326105552731"></p>
<p>作为一个程序猿，开发需要选择一款开发工具，当然可以进行代码开发的工具有很多，可以选择Idea进行开发，也可以使用eclipse进行开发，也可以使用其他的一些开发工具。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105602.png" alt="image-20210326105601773"></p>
<p><strong>定义：</strong></p>
<p>​    该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<h3 id="6-2-2-结构"><a href="#6-2-2-结构" class="headerlink" title="6.2.2 结构"></a>6.2.2 结构</h3><p>策略模式的主要角色如下：</p>
<ul>
<li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>
</ul>
<h3 id="6-2-3-案例实现"><a href="#6-2-3-案例实现" class="headerlink" title="6.2.3 案例实现"></a>6.2.3 案例实现</h3><p>【例】促销活动</p>
<p>一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105611.png" alt="image-20210326105610963"></p>
<p>代码如下：</p>
<p>定义百货公司所有促销活动的共同接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为春节准备的促销活动A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买一送一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为中秋准备的促销活动B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满200元减50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为圣诞准备的促销活动C</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyC</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SalesMan</span> </span>&#123;                        </span><br><span class="line">    <span class="comment">//持有抽象策略角色的引用                              </span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;                 </span><br><span class="line">                                               </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SalesMan</span><span class="params">(Strategy strategy)</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;              </span><br><span class="line">    &#125;                                          </span><br><span class="line">                                               </span><br><span class="line">    <span class="comment">//向客户展示促销活动                                </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">salesManShow</span><span class="params">()</span></span>&#123;                </span><br><span class="line">        strategy.show();                       </span><br><span class="line">    &#125;                                          </span><br><span class="line">&#125;                                              </span><br></pre></td></tr></table></figure>


<h3 id="6-2-4-优缺点"><a href="#6-2-4-优缺点" class="headerlink" title="6.2.4 优缺点"></a>6.2.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li><p>策略类之间可以自由切换</p>
<p>由于策略类都实现同一个接口，所以使它们之间可以自由切换。</p>
</li>
<li><p>易于扩展</p>
<p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“</p>
</li>
<li><p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想。</p>
</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li><strong>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</strong></li>
<li>策略模式将造成产生很多策略类，<strong>可以通过使用享元模式</strong>在一定程度上减少对象的数量。</li>
</ul>
<h3 id="6-2-5-使用场景"><a href="#6-2-5-使用场景" class="headerlink" title="6.2.5 使用场景"></a>6.2.5 使用场景</h3><ul>
<li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li>
<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li>
<li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li>
<li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li>
<li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>
</ul>
<h3 id="6-2-6-JDK源码解析"><a href="#6-2-6-JDK源码解析" class="headerlink" title="6.2.6 JDK源码解析"></a>6.2.6 JDK源码解析</h3><p><code>Comparator</code> 中的策略模式。在Arrays类中有一个 <code>sort()</code> 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arrays</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sort(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">                legacyMergeSort(a, c);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Arrays就是一个环境角色类，这个sort方法可以传一个新策略让Arrays根据这个策略来进行排序。就比如下面的测试类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer[] data = &#123;<span class="number">12</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 实现降序排序</span></span><br><span class="line">        Arrays.sort(data, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(data)); <span class="comment">//[12, 5, 4, 3, 2, 2, 1]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们在调用Arrays的sort方法时，第二个参数传递的是Comparator接口的子实现类对象。所以Comparator充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。环境角色类（Arrays）应该持有抽象策略的引用来调用。那么，Arrays类的sort方法到底有没有使用Comparator子实现类中的 <code>compare()</code> 方法吗？让我们继续查看TimSort类的 <code>sort()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimSort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comparator&lt;? <span class="keyword">super</span> T&gt; c,</span></span></span><br><span class="line"><span class="function"><span class="params">                         T[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> c != <span class="keyword">null</span> &amp;&amp; a != <span class="keyword">null</span> &amp;&amp; lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nRemaining  = hi - lo;</span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// Arrays of size 0 and 1 are always sorted</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If array is small, do a &quot;mini-TimSort&quot; with no merges</span></span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">            <span class="keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line">            binarySort(a, lo, hi, lo + initRunLen, c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;   </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">countRunAndMakeAscending</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi,Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> lo &lt; hi;</span><br><span class="line">        <span class="keyword">int</span> runHi = lo + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (runHi == hi)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find end of run, and reverse range if descending</span></span><br><span class="line">        <span class="keyword">if</span> (c.compare(a[runHi++], a[lo]) &lt; <span class="number">0</span>) &#123; <span class="comment">// Descending</span></span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">                runHi++;</span><br><span class="line">            reverseRange(a, lo, runHi);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                              <span class="comment">// Ascending</span></span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &gt;= <span class="number">0</span>)</span><br><span class="line">                runHi++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> runHi - lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中最终会跑到 <code>countRunAndMakeAscending()</code> 这个方法中。我们可以看见，只用了compare方法，所以在调用Arrays.sort方法只传具体compare重写方法的类对象就行，这也是Comparator接口中必须要子类实现的一个方法。</p>
<h2 id="6-3-命令模式"><a href="#6-3-命令模式" class="headerlink" title="6.3 命令模式"></a>6.3 命令模式</h2><h3 id="6-3-1-概述"><a href="#6-3-1-概述" class="headerlink" title="6.3.1 概述"></a>6.3.1 概述</h3><p>日常生活中，我们出去吃饭都会遇到下面的场景。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105626.png" alt="image-20210326105626199"></p>
<p><strong>定义：</strong></p>
<p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p>
<h3 id="6-3-2-结构"><a href="#6-3-2-结构" class="headerlink" title="6.3.2 结构"></a>6.3.2 结构</h3><p>命令模式包含以下主要角色：</p>
<ul>
<li>抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。</li>
<li>具体命令（Concrete  Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li>
<li>实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li>
<li>调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</li>
</ul>
<h3 id="6-3-3-案例实现"><a href="#6-3-3-案例实现" class="headerlink" title="6.3.3 案例实现"></a>6.3.3 案例实现</h3><p>将上面的案例用代码实现，那我们就需要分析命令模式的角色在该案例中由谁来充当。</p>
<p>服务员： 就是调用者角色，由她来发起命令。</p>
<p>资深大厨： 就是接收者角色，真正命令执行的对象。</p>
<p>订单： 命令中包含订单。</p>
<p>类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105637.png" alt="image-20210326105636496"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;<span class="comment">//只需要定义一个统一的执行方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持有接受者对象</span></span><br><span class="line">    <span class="keyword">private</span> SeniorChef receiver;</span><br><span class="line">    <span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderCommand</span><span class="params">(SeniorChef receiver, Order order)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">        <span class="keyword">this</span>.order = order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">&quot;桌的订单：&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = order.getFoodDic().keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            receiver.makeFood(order.getFoodDic().get(key),key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);<span class="comment">//停顿一下 模拟做饭的过程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">&quot;桌的饭弄好了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 餐桌号码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> diningTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来存储餐名并记录份数</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; foodDic = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDiningTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> diningTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDiningTable</span><span class="params">(<span class="keyword">int</span> diningTable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.diningTable = diningTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title">getFoodDic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> foodDic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFoodDic</span><span class="params">(String name, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        foodDic.put(name,num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资深大厨类 是命令的Receiver</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeniorChef</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeFood</span><span class="params">(<span class="keyword">int</span> num,String foodName)</span> </span>&#123;</span><br><span class="line">        System.out.println(num + <span class="string">&quot;份&quot;</span> + foodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Command&gt; commands;<span class="comment">//可以持有很多的命令对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Waitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        commands = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command cmd)</span></span>&#123;</span><br><span class="line">        commands.add(cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发出命令 喊 订单来了，厨师开始执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;美女服务员：叮咚，大厨，新订单来了.......&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; commands.size(); i++) &#123;</span><br><span class="line">            Command cmd = commands.get(i);</span><br><span class="line">            <span class="keyword">if</span> (cmd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cmd.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建2个order</span></span><br><span class="line">        Order order1 = <span class="keyword">new</span> Order();</span><br><span class="line">        order1.setDiningTable(<span class="number">1</span>);</span><br><span class="line">        order1.getFoodDic().put(<span class="string">&quot;西红柿鸡蛋面&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        order1.getFoodDic().put(<span class="string">&quot;小杯可乐&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">        order2.setDiningTable(<span class="number">3</span>);</span><br><span class="line">        order2.getFoodDic().put(<span class="string">&quot;尖椒肉丝盖饭&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        order2.getFoodDic().put(<span class="string">&quot;小杯雪碧&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建接收者</span></span><br><span class="line">        SeniorChef receiver=<span class="keyword">new</span> SeniorChef();</span><br><span class="line">        <span class="comment">//将订单和接收者封装成命令对象</span></span><br><span class="line">        OrderCommand cmd1 = <span class="keyword">new</span> OrderCommand(receiver, order1);</span><br><span class="line">        OrderCommand cmd2 = <span class="keyword">new</span> OrderCommand(receiver, order2);</span><br><span class="line">        <span class="comment">//创建调用者 waitor</span></span><br><span class="line">        Waitor invoker = <span class="keyword">new</span> Waitor();</span><br><span class="line">        invoker.setCommand(cmd1);</span><br><span class="line">        invoker.setCommand(cmd2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将订单带到柜台 并向厨师喊 订单来了</span></span><br><span class="line">        invoker.orderUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="6-3-4-优缺点"><a href="#6-3-4-优缺点" class="headerlink" title="6.3.4 优缺点"></a>6.3.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li>
<li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li>
<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>
<li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。</li>
<li>系统结构更加复杂。</li>
</ul>
<h3 id="6-3-5-使用场景"><a href="#6-3-5-使用场景" class="headerlink" title="6.3.5 使用场景"></a>6.3.5 使用场景</h3><ul>
<li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li>
<li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li>
<li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li>
</ul>
<h3 id="6-3-6-JDK源码解析"><a href="#6-3-6-JDK源码解析" class="headerlink" title="6.3.6 JDK源码解析"></a>6.3.6 JDK源码解析</h3><p>Runable是一个典型命令模式，Runnable担当命令的角色，Thread充当的是调用者，start方法就是其执行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//命令接口(抽象命令角色)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">        group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会调用一个native方法start0(),调用系统方法，开启一个线程。而接收者是对程序员开放的，可以自己定义接收者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk Runnable 命令模式</span></span><br><span class="line"><span class="comment"> *		TurnOffThread ： 属于具体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurnOffThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">TurnOffThread</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">     	<span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	receiver.turnOFF();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Receiver receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line">         TurnOffThread turnOffThread = <span class="keyword">new</span> TurnOffThread(receiver);</span><br><span class="line">         Thread thread = <span class="keyword">new</span> Thread(turnOffThread);</span><br><span class="line">         thread.start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6-4-责任链模式"><a href="#6-4-责任链模式" class="headerlink" title="6.4 责任链模式"></a>6.4 责任链模式</h2><h3 id="6-4-1-概述"><a href="#6-4-1-概述" class="headerlink" title="6.4.1 概述"></a>6.4.1 概述</h3><p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。</p>
<p><strong>定义：</strong></p>
<p>又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<h3 id="6-4-2-结构"><a href="#6-4-2-结构" class="headerlink" title="6.4.2 结构"></a>6.4.2 结构</h3><p>职责链模式主要包含以下角色:</p>
<ul>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ul>
<h3 id="6-4-3-案例实现"><a href="#6-4-3-案例实现" class="headerlink" title="6.4.3 案例实现"></a>6.4.3 案例实现</h3><p>现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。</p>
<p>类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105654.png" alt="image-20210326105653562"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请假条</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaveRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;<span class="comment">//请假天数</span></span><br><span class="line">    <span class="keyword">private</span> String content;<span class="comment">//请假内容</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LeaveRequest</span><span class="params">(String name, <span class="keyword">int</span> num, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理者抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_ONE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_THREE = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_SEVEN = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该领导处理的请假天数区间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//领导上面还有领导</span></span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围 上不封顶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">int</span> numStart)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numStart = numStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">int</span> numStart, <span class="keyword">int</span> numEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numStart = numStart;</span><br><span class="line">        <span class="keyword">this</span>.numEnd = numEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置上级领导</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextHandler</span><span class="params">(Handler nextHandler)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交请假条</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(LeaveRequest leave)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == <span class="keyword">this</span>.numStart)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果请假天数达到该领导者的处理要求</span></span><br><span class="line">        <span class="keyword">if</span>(leave.getNum() &gt;= <span class="keyword">this</span>.numStart)&#123;</span><br><span class="line">            <span class="keyword">this</span>.handleLeave(leave);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果还有上级 并且请假天数超过了当前领导的处理范围</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != <span class="keyword">this</span>.nextHandler &amp;&amp; leave.getNum() &gt; numEnd)&#123;</span><br><span class="line">                <span class="keyword">this</span>.nextHandler.submit(leave);<span class="comment">//继续提交</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;流程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各级领导处理请假条方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleLeave</span><span class="params">(LeaveRequest leave)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小组长</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupLeader</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupLeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//小组长处理1-3天的请假</span></span><br><span class="line">        <span class="keyword">super</span>(Handler.NUM_ONE, Handler.NUM_THREE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleLeave</span><span class="params">(LeaveRequest leave)</span> </span>&#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小组长审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//部门经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//部门经理处理3-7天的请假</span></span><br><span class="line">        <span class="keyword">super</span>(Handler.NUM_THREE, Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleLeave</span><span class="params">(LeaveRequest leave)</span> </span>&#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;部门经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralManager</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GeneralManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//部门经理处理7天以上的请假</span></span><br><span class="line">        <span class="keyword">super</span>(Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleLeave</span><span class="params">(LeaveRequest leave)</span> </span>&#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//请假条来一张</span></span><br><span class="line">        LeaveRequest leave = <span class="keyword">new</span> LeaveRequest(<span class="string">&quot;小花&quot;</span>,<span class="number">5</span>,<span class="string">&quot;身体不适&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//各位领导</span></span><br><span class="line">        GroupLeader groupLeader = <span class="keyword">new</span> GroupLeader();</span><br><span class="line">        Manager manager = <span class="keyword">new</span> Manager();</span><br><span class="line">        GeneralManager generalManager = <span class="keyword">new</span> GeneralManager();</span><br><span class="line"></span><br><span class="line">        groupLeader.setNextHandler(manager);<span class="comment">//小组长的领导是部门经理</span></span><br><span class="line">        manager.setNextHandler(generalManager);<span class="comment">//部门经理的领导是总经理</span></span><br><span class="line">        <span class="comment">//之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交申请</span></span><br><span class="line">        groupLeader.submit(leave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="6-4-4-优缺点"><a href="#6-4-4-优缺点" class="headerlink" title="6.4.4 优缺点"></a>6.4.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li><p>降低了对象之间的耦合度</p>
<p>该模式降低了请求发送者和接收者的耦合度。</p>
</li>
<li><p>增强了系统的可扩展性</p>
<p>可以根据需要增加新的请求处理类，满足开闭原则。</p>
</li>
<li><p>增强了给对象指派职责的灵活性</p>
<p>当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。</p>
</li>
<li><p>责任链简化了对象之间的连接</p>
<p>一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</p>
</li>
<li><p>责任分担</p>
<p>每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</p>
</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li>
<li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li>
<li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li>
</ul>
<h3 id="6-4-5-源码解析"><a href="#6-4-5-源码解析" class="headerlink" title="6.4.5 源码解析"></a>6.4.5 源码解析</h3><p>在javaWeb应用开发中，FilterChain是职责链（过滤器）模式的典型应用，以下是Filter的模拟实现分析:</p>
<ul>
<li><p>模拟web请求Request以及web响应Response</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Request</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Response</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>模拟web过滤器Filter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request req,Response res,FilterChain c)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>模拟实现具体过滤器  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain chain)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器1 前置处理&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先执行所有request再倒序执行所有response</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器1 后置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondFilter</span>  <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain chain)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器2 前置处理&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先执行所有request再倒序执行所有response</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器2 后置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>模拟实现过滤器链FilterChain  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;Filter&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterChain <span class="title">addFilter</span><span class="params">(Filter filter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filters.add(filter);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == filters.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Filter filter = filters.get(index);</span><br><span class="line">        index++;</span><br><span class="line">        filter.doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Request  req = <span class="keyword">null</span>;</span><br><span class="line">        Response res = <span class="keyword">null</span> ;</span><br><span class="line"></span><br><span class="line">        FilterChain filterChain = <span class="keyword">new</span> FilterChain();</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> FirstFilter()).addFilter(<span class="keyword">new</span> SecondFilter());</span><br><span class="line">        filterChain.doFilter(req,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="6-5-状态模式"><a href="#6-5-状态模式" class="headerlink" title="6.5 状态模式"></a>6.5 状态模式</h2><h3 id="6-5-1-概述"><a href="#6-5-1-概述" class="headerlink" title="6.5.1 概述"></a>6.5.1 概述</h3><p>【例】通过按钮来控制一个电梯的状态，一个电梯有开门状态，关门状态，停止状态，运行状态。每一种状态改变，都有可能要根据其他状态来更新处理。例如，如果电梯门现在处于运行时状态，就不能进行开门操作，而如果电梯门是停止状态，就可以执行开门操作。</p>
<p>类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105817.png" alt="image-20210326105816377"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILift</span> </span>&#123;</span><br><span class="line">    <span class="comment">//电梯的4个状态</span></span><br><span class="line">    <span class="comment">//开门状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> OPENING_STATE = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//关门状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CLOSING_STATE = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//运行状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> RUNNING_STATE = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//停止状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> STOPPING_STATE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置电梯的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯的动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lift</span> <span class="keyword">implements</span> <span class="title">ILift</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行关门动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE:</span><br><span class="line">                System.out.println(<span class="string">&quot;电梯关门了。。。&quot;</span>);<span class="comment">//只有开门状态可以关闭电梯门，可以对应电梯状态表来看</span></span><br><span class="line">                <span class="keyword">this</span>.setState(CLOSING_STATE);<span class="comment">//关门之后电梯就是关闭状态了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:</span><br><span class="line">                <span class="comment">//do nothing //已经是关门状态，不能关门</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">                <span class="comment">//do nothing //运行时电梯门是关着的，不能关门</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                <span class="comment">//do nothing //停止时电梯也是关着的，不能关门</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行开门动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE:<span class="comment">//门已经开了，不能再开门了</span></span><br><span class="line">                <span class="comment">//do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:<span class="comment">//关门状态，门打开:</span></span><br><span class="line">                System.out.println(<span class="string">&quot;电梯门打开了。。。&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.setState(OPENING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">                <span class="comment">//do nothing 运行时电梯不能开门</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                System.out.println(<span class="string">&quot;电梯门开了。。。&quot;</span>);<span class="comment">//电梯停了，可以开门了</span></span><br><span class="line">                <span class="keyword">this</span>.setState(OPENING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行运行动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE:<span class="comment">//电梯不能开着门就走</span></span><br><span class="line">                <span class="comment">//do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:<span class="comment">//门关了，可以运行了</span></span><br><span class="line">                System.out.println(<span class="string">&quot;电梯开始运行了。。。&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.setState(RUNNING_STATE);<span class="comment">//现在是运行状态</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">                <span class="comment">//do nothing 已经是运行状态了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                System.out.println(<span class="string">&quot;电梯开始运行了。。。&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.setState(RUNNING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行停止动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE: <span class="comment">//开门的电梯已经是是停止的了(正常情况下)</span></span><br><span class="line">                <span class="comment">//do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:<span class="comment">//关门时才可以停止</span></span><br><span class="line">                System.out.println(<span class="string">&quot;电梯停止了。。。&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.setState(STOPPING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:<span class="comment">//运行时当然可以停止了</span></span><br><span class="line">                System.out.println(<span class="string">&quot;电梯停止了。。。&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.setState(STOPPING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                <span class="comment">//do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lift lift = <span class="keyword">new</span> Lift();</span><br><span class="line">        lift.setState(ILift.STOPPING_STATE);<span class="comment">//电梯是停止的</span></span><br><span class="line">        lift.open();<span class="comment">//开门</span></span><br><span class="line">        lift.close();<span class="comment">//关门</span></span><br><span class="line">        lift.run();<span class="comment">//运行</span></span><br><span class="line">        lift.stop();<span class="comment">//停止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题分析：</p>
<ul>
<li>使用了大量的switch…case这样的判断（if…else也是一样)，使程序的可阅读性变差。</li>
<li>扩展性很差。如果新加了断电的状态，我们需要修改上面判断逻辑</li>
</ul>
<p><strong>定义：</strong></p>
<p>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p>
<h3 id="6-5-2-结构"><a href="#6-5-2-结构" class="headerlink" title="6.5.2 结构"></a>6.5.2 结构</h3><p>状态模式包含以下主要角色。</p>
<ul>
<li>环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li>
<li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li>
<li>具体状态（Concrete  State）角色：实现抽象状态所对应的行为。</li>
</ul>
<h3 id="6-5-3-案例实现"><a href="#6-5-3-案例实现" class="headerlink" title="6.5.3 案例实现"></a>6.5.3 案例实现</h3><p>对上述电梯的案例使用状态模式进行改进。类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105829.png" alt="image-20210326105828428"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象状态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个环境角色，也就是封装状态的变化引起的功能变化</span></span><br><span class="line">    <span class="keyword">protected</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯开门动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯关门动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯运行动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯停止动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenningState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启当然可以关闭了，我就想测试一下电梯门开关功能</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯门开启...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//状态修改</span></span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.closeingState);</span><br><span class="line">        <span class="comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span></span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门不能开着就跑，这里什么也不做</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开门状态已经是停止的了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunningState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行的时候开电梯门？你疯了！电梯不会给你开的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门关闭？这是肯定了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;<span class="comment">//虽然可以关门，但这个动作不归我执行</span></span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是在运行状态下要实现的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯正在运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.stoppingState);</span><br><span class="line">        <span class="keyword">super</span>.context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoppingState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止状态，开门，那是要的！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//状态修改</span></span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.openningState);</span><br><span class="line">        <span class="comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span></span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;<span class="comment">//虽然可以关门，但这个动作不归我执行</span></span><br><span class="line">        <span class="comment">//状态修改</span></span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.closeingState);</span><br><span class="line">        <span class="comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span></span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止状态再跑起来，正常的很</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//状态修改</span></span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.runningState);</span><br><span class="line">        <span class="comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span></span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止状态是怎么发生的呢？当然是停止方法执行了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯停止了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosingState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//电梯门关闭，这是关闭状态要实现的动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯门关闭...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门关了再打开，逗你玩呢，那这个允许呀</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.openningState);</span><br><span class="line">        <span class="keyword">super</span>.context.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门关了就跑，这是再正常不过了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.runningState);</span><br><span class="line">        <span class="keyword">super</span>.context.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门关着，我就不按楼层</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.stoppingState);</span><br><span class="line">        <span class="keyword">super</span>.context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//环境角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义出所有的电梯状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> OpenningState openningState = <span class="keyword">new</span> OpenningState();<span class="comment">//开门状态，这时候电梯只能关闭</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> ClosingState closeingState = <span class="keyword">new</span> ClosingState();<span class="comment">//关闭状态，这时候电梯可以运行、停止和开门</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> RunningState runningState = <span class="keyword">new</span> RunningState();<span class="comment">//运行状态，这时候电梯只能停止</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> StoppingState stoppingState = <span class="keyword">new</span> StoppingState();<span class="comment">//停止状态，这时候电梯可以开门、运行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个当前电梯状态</span></span><br><span class="line">    <span class="keyword">private</span> LiftState liftState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiftState <span class="title">getLiftState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.liftState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLiftState</span><span class="params">(LiftState liftState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前环境改变</span></span><br><span class="line">        <span class="keyword">this</span>.liftState = liftState;</span><br><span class="line">        <span class="comment">//把当前的环境通知到各个实现类中</span></span><br><span class="line">        <span class="keyword">this</span>.liftState.setContext(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        context.setLiftState(<span class="keyword">new</span> ClosingState());</span><br><span class="line"></span><br><span class="line">        context.open();</span><br><span class="line">        context.close();</span><br><span class="line">        context.run();</span><br><span class="line">        context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="6-5-4-优缺点"><a href="#6-5-4-优缺点" class="headerlink" title="6.5.4 优缺点"></a>6.5.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li>
<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>状态模式的使用必然会增加系统类和对象的个数。 </li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li>
<li>状态模式对”开闭原则”的支持并不太好。</li>
</ul>
<h3 id="6-5-5-使用场景"><a href="#6-5-5-使用场景" class="headerlink" title="6.5.5 使用场景"></a>6.5.5 使用场景</h3><ul>
<li><strong>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时</strong>，就可以考虑使用状态模式。</li>
<li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li>
</ul>
<h2 id="6-6-观察者模式"><a href="#6-6-观察者模式" class="headerlink" title="6.6 观察者模式"></a>6.6 观察者模式</h2><h3 id="6-6-1-概述"><a href="#6-6-1-概述" class="headerlink" title="6.6.1 概述"></a>6.6.1 概述</h3><p><strong>定义：</strong></p>
<p>又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p>
<h3 id="6-6-2-结构"><a href="#6-6-2-结构" class="headerlink" title="6.6.2 结构"></a>6.6.2 结构</h3><p>在观察者模式中有如下角色：</p>
<ul>
<li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li>
<li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li>
<li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li>
<li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li>
</ul>
<h3 id="6-6-3-案例实现"><a href="#6-6-3-案例实现" class="headerlink" title="6.6.3 案例实现"></a>6.6.3 案例实现</h3><p>【例】微信公众号</p>
<p>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。</p>
<p>类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326105844.png" alt="image-20210326105843837"></p>
<p>代码如下：</p>
<p>定义抽象观察者类，里面定义一个更新的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义具体观察者类，微信用户是观察者，里面实现了更新的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinUser</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 微信用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeixinUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义抽象主题类，提供了attach、detach、notify三个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//增加订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通知订阅者更新消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//储存订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; weixinUserlist = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        weixinUserlist.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        weixinUserlist.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : weixinUserlist) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubscriptionSubject mSubscriptionSubject=<span class="keyword">new</span> SubscriptionSubject();</span><br><span class="line">        <span class="comment">//创建微信用户</span></span><br><span class="line">        WeixinUser user1=<span class="keyword">new</span> WeixinUser(<span class="string">&quot;孙悟空&quot;</span>);</span><br><span class="line">        WeixinUser user2=<span class="keyword">new</span> WeixinUser(<span class="string">&quot;猪悟能&quot;</span>);</span><br><span class="line">        WeixinUser user3=<span class="keyword">new</span> WeixinUser(<span class="string">&quot;沙悟净&quot;</span>);</span><br><span class="line">        <span class="comment">//订阅公众号</span></span><br><span class="line">        mSubscriptionSubject.attach(user1);</span><br><span class="line">        mSubscriptionSubject.attach(user2);</span><br><span class="line">        mSubscriptionSubject.attach(user3);</span><br><span class="line">        <span class="comment">//公众号更新发出消息给订阅的微信用户</span></span><br><span class="line">        mSubscriptionSubject.notify(<span class="string">&quot;传智黑马的专栏更新了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="6-6-4-优缺点"><a href="#6-6-4-优缺点" class="headerlink" title="6.6.4 优缺点"></a>6.6.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li>
<li>被观察者发送通知，所有注册的观察者都会收到信息<strong>【可以实现广播机制】</strong></li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时</li>
<li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</li>
</ul>
<h3 id="6-6-5-使用场景"><a href="#6-6-5-使用场景" class="headerlink" title="6.6.5 使用场景"></a>6.6.5 使用场景</h3><ul>
<li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li>
<li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。</li>
</ul>
<h3 id="6-6-6-JDK中提供的实现"><a href="#6-6-6-JDK中提供的实现" class="headerlink" title="6.6.6 JDK中提供的实现"></a>6.6.6 JDK中提供的实现</h3><p>在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。</p>
<p><strong>1，Observable类</strong></p>
<p>Observable 类是抽象目标类（被观察者），它有一个 Vector 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。</p>
<ul>
<li><p>void addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中。</p>
</li>
<li><p>void notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。</p>
</li>
<li><p>void setChange() 方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。</p>
</li>
</ul>
<p><strong>2，Observer 接口</strong></p>
<p>Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作。</p>
<p>【例】警察抓小偷</p>
<p>警察抓小偷也可以使用观察者模式来实现，警察是观察者，小偷是被观察者。代码如下：</p>
<p>小偷是一个被观察者，所以需要继承Observable类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thief</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thief</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">steal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小偷：我偷东西了，有没有人来抓我！！！&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.setChanged(); <span class="comment">//changed  = true</span></span><br><span class="line">        <span class="keyword">super</span>.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>警察是一个观察者，所以需要让其实现Observer接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Policemen</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Policemen</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;警察：&quot;</span> + ((Thief) o).getName() + <span class="string">&quot;，我已经盯你很久了，你可以保持沉默，但你所说的将成为呈堂证供！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建小偷对象</span></span><br><span class="line">        Thief t = <span class="keyword">new</span> Thief(<span class="string">&quot;隔壁老王&quot;</span>);</span><br><span class="line">        <span class="comment">//创建警察对象</span></span><br><span class="line">        Policemen p = <span class="keyword">new</span> Policemen(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        <span class="comment">//让警察盯着小偷</span></span><br><span class="line">        t.addObserver(p);</span><br><span class="line">        <span class="comment">//小偷偷东西</span></span><br><span class="line">        t.steal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6-7-中介者模式"><a href="#6-7-中介者模式" class="headerlink" title="6.7 中介者模式"></a>6.7 中介者模式</h2><h3 id="6-7-1-概述"><a href="#6-7-1-概述" class="headerlink" title="6.7.1 概述"></a>6.7.1 概述</h3><p>一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下左图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。</p>
<p>如果引入中介者模式，那么同事类之间的关系将变为星型结构，从下右图中可以看到，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。</p>
<img src="/Users/wsy/%25E5%25AD%25A6%25E4%25B9%25A0%25E8%25B5%2584%25E6%2596%2599/%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F/Java%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%25E8%25B5%2584%25E6%2596%2599day05/%25E7%25AC%2594%25E8%25AE%25B0/img/image-20200214110924010.png" style="zoom:60%;" />

<p><strong>定义：</strong></p>
<p>又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。</p>
<h3 id="6-7-2-结构"><a href="#6-7-2-结构" class="headerlink" title="6.7.2 结构"></a>6.7.2 结构</h3><p>中介者模式包含以下主要角色：</p>
<ul>
<li><p>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</p>
</li>
<li><p>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</p>
</li>
<li><p>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</p>
</li>
<li><p>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</p>
</li>
</ul>
<h3 id="6-7-3-案例实现"><a href="#6-7-3-案例实现" class="headerlink" title="6.7.3 案例实现"></a>6.7.3 案例实现</h3><p>【例】租房</p>
<p>现在租房基本都是通过房屋中介，房主将房屋托管给房屋中介，而租房者从房屋中介获取房屋信息。房屋中介充当租房者与房屋所有者之间的中介者。</p>
<p>类图如下：</p>
<img src="/Users/wsy/%25E5%25AD%25A6%25E4%25B9%25A0%25E8%25B5%2584%25E6%2596%2599/%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F/Java%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%25E8%25B5%2584%25E6%2596%2599day05/%25E7%25AC%2594%25E8%25AE%25B0/img/%25E4%25B8%25AD%25E4%25BB%258B%25E8%2580%2585%25E6%25A8%25A1%25E5%25BC%258F.png" style="zoom:70%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象中介者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//申明一个联络方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">constact</span><span class="params">(String message,Person person)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象同事类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,Mediator mediator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体同事类 房屋拥有者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseOwner</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseOwner</span><span class="params">(String name, Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与中介者联系</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">constact</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        mediator.constact(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房主&quot;</span> + name +<span class="string">&quot;获取到的信息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体同事类 承租人</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tenant</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tenant</span><span class="params">(String name, Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与中介者联系</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">constact</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        mediator.constact(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;租房者&quot;</span> + name +<span class="string">&quot;获取到的信息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中介机构</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorStructure</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先中介结构必须知道所有房主和租房者的信息</span></span><br><span class="line">    <span class="keyword">private</span> HouseOwner houseOwner;</span><br><span class="line">    <span class="keyword">private</span> Tenant tenant;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HouseOwner <span class="title">getHouseOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> houseOwner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHouseOwner</span><span class="params">(HouseOwner houseOwner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseOwner = houseOwner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tenant <span class="title">getTenant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tenant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTenant</span><span class="params">(Tenant tenant)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tenant = tenant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">constact</span><span class="params">(String message, Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (person == houseOwner) &#123;          <span class="comment">//如果是房主，则租房者获得信息</span></span><br><span class="line">            tenant.getMessage(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;       <span class="comment">//反正则是房主获得信息</span></span><br><span class="line">            houseOwner.getMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个房主、一个租房者、一个中介机构</span></span><br><span class="line">        MediatorStructure mediator = <span class="keyword">new</span> MediatorStructure();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//房主和租房者只需要知道中介机构即可</span></span><br><span class="line">        HouseOwner houseOwner = <span class="keyword">new</span> HouseOwner(<span class="string">&quot;张三&quot;</span>, mediator);</span><br><span class="line">        Tenant tenant = <span class="keyword">new</span> Tenant(<span class="string">&quot;李四&quot;</span>, mediator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中介结构要知道房主和租房者</span></span><br><span class="line">        mediator.setHouseOwner(houseOwner);</span><br><span class="line">        mediator.setTenant(tenant);</span><br><span class="line"></span><br><span class="line">        tenant.constact(<span class="string">&quot;需要租三室的房子&quot;</span>);</span><br><span class="line">        houseOwner.constact(<span class="string">&quot;我这有三室的房子，你需要租吗？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="6-7-4-优缺点"><a href="#6-7-4-优缺点" class="headerlink" title="6.7.4 优缺点"></a>6.7.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li><p>松散耦合</p>
<p>中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。</p>
</li>
<li><p>集中控制交互</p>
<p>多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。</p>
</li>
<li><p>一对多关联转变为一对一的关联</p>
<p>没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。</p>
</li>
</ul>
<p><strong>2，缺点：</strong></p>
<p>当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p>
<h3 id="6-7-5-使用场景"><a href="#6-7-5-使用场景" class="headerlink" title="6.7.5 使用场景"></a>6.7.5 使用场景</h3><ul>
<li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</li>
<li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li>
</ul>
<h2 id="6-8-迭代器模式"><a href="#6-8-迭代器模式" class="headerlink" title="6.8 迭代器模式"></a>6.8 迭代器模式</h2><h3 id="6-8-1-概述"><a href="#6-8-1-概述" class="headerlink" title="6.8.1 概述"></a>6.8.1 概述</h3><p><strong>定义：</strong></p>
<p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 </p>
<h3 id="6-8-2-结构"><a href="#6-8-2-结构" class="headerlink" title="6.8.2 结构"></a>6.8.2 结构</h3><p>迭代器模式主要包含以下角色：</p>
<ul>
<li><p>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。</p>
</li>
<li><p>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</p>
</li>
<li><p>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。</p>
</li>
<li><p>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</p>
</li>
</ul>
<h3 id="6-8-3-案例实现"><a href="#6-8-3-案例实现" class="headerlink" title="6.8.3 案例实现"></a>6.8.3 案例实现</h3><p>【例】定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现，涉及到的类如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326110145.png" alt="image-20210326110144116"></p>
<p>代码如下：</p>
<p>定义迭代器接口，声明hasNext、next方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义具体的迭代器类，重写所有的抽象方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentIteratorImpl</span> <span class="keyword">implements</span> <span class="title">StudentIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentIteratorImpl</span><span class="params">(List&lt;Student&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student currentStudent = list.get(position);</span><br><span class="line">        position ++;</span><br><span class="line">        <span class="keyword">return</span> currentStudent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义抽象容器类，包含添加元素，删除元素，获取迭代器对象的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentAggregate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(Student student)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeStudent</span><span class="params">(Student student)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">StudentIterator <span class="title">getStudentIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义具体的容器类，重写所有的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentAggregateImpl</span> <span class="keyword">implements</span> <span class="title">StudentAggregate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();  <span class="comment">// 学生列表</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list.add(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeStudent</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list.remove(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentIterator <span class="title">getStudentIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentIteratorImpl(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="6-8-4-优缺点"><a href="#6-8-4-优缺点" class="headerlink" title="6.8.4 优缺点"></a>6.8.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li>它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</li>
<li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</li>
<li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足 “开闭原则” 的要求。</li>
</ul>
<p><strong>2，缺点：</strong></p>
<p>增加了类的个数，这在一定程度上增加了系统的复杂性。</p>
<h3 id="6-8-5-使用场景"><a href="#6-8-5-使用场景" class="headerlink" title="6.8.5 使用场景"></a>6.8.5 使用场景</h3><ul>
<li>当需要为聚合对象提供多种遍历方式时。</li>
<li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li>
<li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li>
</ul>
<h3 id="6-8-6-JDK源码解析"><a href="#6-8-6-JDK源码解析" class="headerlink" title="6.8.6 JDK源码解析"></a>6.8.6 JDK源码解析</h3><p>迭代器模式在JAVA的很多集合类中被广泛应用，接下来看看JAVA源码中是如何使用迭代器模式的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator(); <span class="comment">//list.iterator()方法返回的肯定是Iterator接口的子实现类对象</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完这段代码是不是很熟悉，与我们上面代码基本类似。单列集合都使用到了迭代器，我们以ArrayList举例来说明</p>
<ul>
<li>List：抽象聚合类</li>
<li>ArrayList：具体的聚合类</li>
<li>Iterator：抽象迭代器</li>
<li>list.iterator()：返回的是实现了 <code>Iterator</code> 接口的具体迭代器对象</li>
</ul>
<p>具体的来看看 ArrayList的代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// 下一个要返回元素的索引</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// 上一个返回元素的索引</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//判断是否还有元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取下一个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码还是比较简单，大致就是在 <code>iterator</code> 方法中返回了一个实例化的 <code>Iterator</code> 对象。Itr是一个内部类，它实现了 <code>Iterator</code> 接口并重写了其中的抽象方法。</p>
<blockquote>
<p>注意： </p>
<p>​    当我们在使用JAVA开发的时候，想使用迭代器模式的话，只要让我们自己定义的容器类实现<code>java.util.Iterable</code>并实现其中的iterator()方法使其返回一个 <code>java.util.Iterator</code> 的实现类就可以了。</p>
</blockquote>
<h2 id="6-9-访问者模式"><a href="#6-9-访问者模式" class="headerlink" title="6.9 访问者模式"></a>6.9 访问者模式</h2><h3 id="6-9-1-概述"><a href="#6-9-1-概述" class="headerlink" title="6.9.1 概述"></a>6.9.1 概述</h3><p><strong>定义：</strong></p>
<p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</p>
<h3 id="6-9-2-结构"><a href="#6-9-2-结构" class="headerlink" title="6.9.2 结构"></a>6.9.2 结构</h3><p>访问者模式包含以下主要角色:</p>
<ul>
<li>抽象访问者（Visitor）角色：定义了对每一个元素<code>（Element）</code>访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。</li>
<li>具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。</li>
<li>抽象元素（Element）角色：定义了一个接受访问者的方法（<code>accept</code>），其意义是指，每一个元素都要可以被访问者访问。</li>
<li>具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。</li>
<li>对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（<code>Element</code>），并且可以迭代这些元素，供访问者访问。</li>
</ul>
<h3 id="6-9-3-案例实现"><a href="#6-9-3-案例实现" class="headerlink" title="6.9.3 案例实现"></a>6.9.3 案例实现</h3><p>【例】给宠物喂食</p>
<p>现在养宠物的人特别多，我们就以这个为例，当然宠物还分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食。</p>
<ul>
<li>访问者角色：给宠物喂食的人</li>
<li>具体访问者角色：主人、其他人</li>
<li>抽象元素角色：动物抽象类</li>
<li>具体元素角色：宠物狗、宠物猫</li>
<li>结构对象角色：主人家</li>
</ul>
<p>类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326110202.png"></p>
<p>代码如下：</p>
<p>创建抽象访问者接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">feed</span><span class="params">(Cat cat)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">feed</span><span class="params">(Dog dog)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建不同的具体访问者角色（主人和其他人），都需要实现 <code>Person</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Owner</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人喂食猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人喂食狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Someone</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人喂食猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人喂食狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义抽象节点 – 宠物</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义实现<code>Animal</code>接口的 具体节点（元素）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        person.feed(<span class="keyword">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;好好吃，汪汪汪！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        person.feed(<span class="keyword">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;好好吃，喵喵喵！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义对象结构，此案例中就是主人的家</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Animal&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Animal node : nodeList) &#123;</span><br><span class="line">            node.accept(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">        nodeList.add(animal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Home home = <span class="keyword">new</span> Home();</span><br><span class="line">        home.add(<span class="keyword">new</span> Dog());</span><br><span class="line">        home.add(<span class="keyword">new</span> Cat());</span><br><span class="line"></span><br><span class="line">        Owner owner = <span class="keyword">new</span> Owner();</span><br><span class="line">        home.action(owner);</span><br><span class="line"></span><br><span class="line">        Someone someone = <span class="keyword">new</span> Someone();</span><br><span class="line">        home.action(someone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="6-9-4-优缺点"><a href="#6-9-4-优缺点" class="headerlink" title="6.9.4 优缺点"></a>6.9.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li><p>扩展性好</p>
<p>在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</p>
</li>
<li><p>复用性好</p>
<p>通过访问者来定义整个对象结构通用的功能，从而提高复用程度。</p>
</li>
<li><p>分离无关行为</p>
<p>通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。</p>
</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li><p>对象结构变化很困难</p>
<p>在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</p>
</li>
<li><p>违反了依赖倒置原则</p>
<p>访问者模式依赖了具体类，而没有依赖抽象类。</p>
</li>
</ul>
<h3 id="6-9-5-使用场景"><a href="#6-9-5-使用场景" class="headerlink" title="6.9.5  使用场景"></a>6.9.5  使用场景</h3><ul>
<li><p>对象结构相对稳定，但其操作算法经常变化的程序。</p>
</li>
<li><p>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</p>
</li>
</ul>
<h3 id="6-9-6-扩展"><a href="#6-9-6-扩展" class="headerlink" title="6.9.6 扩展"></a>6.9.6 扩展</h3><p>访问者模式用到了一种双分派的技术。</p>
<p><strong>1，分派：</strong></p>
<p>变量被声明时的类型叫做变量的静态类型，有些人又把静态类型叫做明显类型；而变量所引用的对象的真实类型又叫做变量的实际类型。比如 <code>Map map = new HashMap()</code> ，map变量的静态类型是 <code>Map</code> ，实际类型是 <code>HashMap</code> 。根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即静态分派和动态分派。</p>
<p><strong>静态分派(Static Dispatch)</strong> 发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。</p>
<p><strong>动态分派(Dynamic Dispatch)</strong> 发生在运行时期，动态分派动态地置换掉某个方法。Java通过方法的重写支持动态分派。</p>
<p><strong>2，动态分派：</strong></p>
<p>通过方法的重写支持动态分派。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Dog();</span><br><span class="line">        a.execute();</span><br><span class="line">        </span><br><span class="line">        Animal a1 = <span class="keyword">new</span> Cat();</span><br><span class="line">        a1.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的结果大家应该直接可以说出来，这不就是多态吗！运行执行的是子类中的方法。</p>
<p>Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。</p>
<p><strong>3，静态分派：</strong></p>
<p>通过方法重载支持静态分派。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Execute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Animal a)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Dog d)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Cat c)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        Animal a1 = <span class="keyword">new</span> Dog();</span><br><span class="line">        Animal a2 = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line">        Execute exe = <span class="keyword">new</span> Execute();</span><br><span class="line">        exe.execute(a);</span><br><span class="line">        exe.execute(a1);</span><br><span class="line">        exe.execute(a2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326110223.png" alt="image-20210326110222617"></p>
<p>这个结果可能出乎一些人的意料了，为什么呢？</p>
<p><strong>重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。</strong></p>
<p><strong>4，双分派：</strong></p>
<p>所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别，还要根据参数的运行时区别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Execute exe)</span> </span>&#123;</span><br><span class="line">        exe.execute(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Execute exe)</span> </span>&#123;</span><br><span class="line">        exe.execute(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Execute exe)</span> </span>&#123;</span><br><span class="line">        exe.execute(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Execute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Animal a)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Dog d)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Cat c)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        Animal d = <span class="keyword">new</span> Dog();</span><br><span class="line">        Animal c = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line">        Execute exe = <span class="keyword">new</span> Execute();</span><br><span class="line">        a.accept(exe);</span><br><span class="line">        d.accept(exe);</span><br><span class="line">        c.accept(exe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面代码中，客户端将Execute对象做为参数传递给Animal类型的变量调用的方法，这里完成第一次分派，这里是方法重写，所以是动态分派，也就是执行实际类型中的方法，同时也<code>将自己this作为参数传递进去，这里就完成了第二次分派</code>，这里的Execute类中有多个重载的方法，而传递进行的是this，就是具体的实际类型的对象。</p>
<p>说到这里，我们已经明白双分派是怎么回事了，但是它有什么效果呢？就是可以实现方法的动态绑定，我们可以对上面的程序进行修改。</p>
<p>运行结果如下：</p>
<img src="/Users/wsy/%25E5%25AD%25A6%25E4%25B9%25A0%25E8%25B5%2584%25E6%2596%2599/%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F/Java%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%25E8%25B5%2584%25E6%2596%2599day05/%25E7%25AC%2594%25E8%25AE%25B0/img/image-20200426233931693.png" style="zoom:67%;" />

<p><strong>双分派实现动态绑定的本质，就是在重载方法委派的前面加上了继承体系中覆盖的环节，由于覆盖是动态的，所以重载就是动态的了。</strong></p>
<h2 id="6-10-备忘录模式"><a href="#6-10-备忘录模式" class="headerlink" title="6.10 备忘录模式"></a>6.10 备忘录模式</h2><h3 id="6-10-1-概述"><a href="#6-10-1-概述" class="headerlink" title="6.10.1 概述"></a>6.10.1 概述</h3><p>备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件都提供了撤销（Undo）操作，如 Word、记事本、Photoshop、IDEA等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 浏览器 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p>
<p><strong>定义：</strong></p>
<p>又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。</p>
<h3 id="6-10-2-结构"><a href="#6-10-2-结构" class="headerlink" title="6.10.2 结构"></a>6.10.2 结构</h3><p>备忘录模式的主要角色如下：</p>
<ul>
<li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li>
<li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li>
<li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li>
</ul>
<blockquote>
<p>备忘录有两个等效的接口：</p>
<ul>
<li><strong>窄接口</strong>：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narror Interface)，这个窄接口只允许他把备忘录对象传给其他的对象。</li>
<li><strong>宽接口</strong>：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。</li>
</ul>
</blockquote>
<h3 id="6-10-3-案例实现"><a href="#6-10-3-案例实现" class="headerlink" title="6.10.3 案例实现"></a>6.10.3 案例实现</h3><p>【例】游戏挑战BOSS</p>
<p>游戏中的某个场景，一游戏角色有生命力、攻击力、防御力等数据，在打Boss前和后一定会不一样的，我们允许玩家如果感觉与Boss决斗的效果不理想可以让游戏恢复到决斗之前的状态。</p>
<p>要实现上述案例，有两种方式：</p>
<ul>
<li>“白箱”备忘录模式</li>
<li>“黑箱”备忘录模式</li>
</ul>
<h4 id="6-10-3-1-“白箱”备忘录模式"><a href="#6-10-3-1-“白箱”备忘录模式" class="headerlink" title="6.10.3.1 “白箱”备忘录模式"></a>6.10.3.1 “白箱”备忘录模式</h4><p>备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326110238.png" alt="image-20210326110237010"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//游戏角色类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameRole</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> vit; <span class="comment">//生命力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> atk; <span class="comment">//攻击力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> def; <span class="comment">//防御力</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.atk = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.def = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//战斗</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.atk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.def = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存角色状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RoleStateMemento <span class="title">saveState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RoleStateMemento(vit, atk, def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回复角色状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverState</span><span class="params">(RoleStateMemento roleStateMemento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = roleStateMemento.getVit();</span><br><span class="line">        <span class="keyword">this</span>.atk = roleStateMemento.getAtk();</span><br><span class="line">        <span class="keyword">this</span>.def = roleStateMemento.getDef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;角色生命力：&quot;</span> + vit);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色攻击力：&quot;</span> + atk);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色防御力：&quot;</span> + def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVit</span><span class="params">(<span class="keyword">int</span> vit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAtk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAtk</span><span class="params">(<span class="keyword">int</span> atk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.atk = atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDef</span><span class="params">(<span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏状态存储类(备忘录类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleStateMemento</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> vit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> atk;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> def;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RoleStateMemento</span><span class="params">(<span class="keyword">int</span> vit, <span class="keyword">int</span> atk, <span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = vit;</span><br><span class="line">        <span class="keyword">this</span>.atk = atk;</span><br><span class="line">        <span class="keyword">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVit</span><span class="params">(<span class="keyword">int</span> vit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAtk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAtk</span><span class="params">(<span class="keyword">int</span> atk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.atk = atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDef</span><span class="params">(<span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//角色状态管理者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleStateCaretaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RoleStateMemento roleStateMemento;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RoleStateMemento <span class="title">getRoleStateMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roleStateMemento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoleStateMemento</span><span class="params">(RoleStateMemento roleStateMemento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roleStateMemento = roleStateMemento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss前------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss前</span></span><br><span class="line">        GameRole gameRole = <span class="keyword">new</span> GameRole();</span><br><span class="line">        gameRole.initState();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存进度</span></span><br><span class="line">        RoleStateCaretaker roleStateCaretaker = <span class="keyword">new</span> RoleStateCaretaker();</span><br><span class="line">        roleStateCaretaker.setRoleStateMemento(gameRole.saveState());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss后------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss时，损耗严重</span></span><br><span class="line">        gameRole.fight();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------恢复之前状态------------&quot;</span>);</span><br><span class="line">        <span class="comment">//恢复之前状态</span></span><br><span class="line">        gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分析：白箱备忘录模式是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。</p>
</blockquote>
<h4 id="6-10-3-2-“黑箱”备忘录模式"><a href="#6-10-3-2-“黑箱”备忘录模式" class="headerlink" title="6.10.3.2 “黑箱”备忘录模式"></a>6.10.3.2 “黑箱”备忘录模式</h4><p>备忘录角色对发起人对象提供一个宽接口，而为其他对象提供一个窄接口。在Java语言中，实现双重接口的办法就是将<strong>备忘录类</strong>设计成<strong>发起人类</strong>的内部成员类。</p>
<p>将 <code>RoleStateMemento</code> 设为 <code>GameRole</code> 的内部类，从而将 <code>RoleStateMemento</code> 对象封装在 <code>GameRole</code> 里面；在外面提供一个标识接口 <code>Memento</code> 给 <code>RoleStateCaretaker</code> 及其他对象使用。这样 <code>GameRole</code> 类看到的是 <code>RoleStateMemento</code> 所有的接口，而<code>RoleStateCaretaker</code>  及其他对象看到的仅仅是标识接口 <code>Memento</code> 所暴露出来的接口，从而维护了封装型。类图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326110254.png" alt="image-20210326110253126"></p>
<p>代码如下：</p>
<p>窄接口<code>Memento</code>，这是一个标识接口，因此没有定义出任何的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义发起人类 <code>GameRole</code>，并在内部定义备忘录内部类 <code>RoleStateMemento</code>（该内部类设置为私有的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/游戏角色类</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameRole</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> vit; <span class="comment">//生命力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> atk; <span class="comment">//攻击力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> def; <span class="comment">//防御力</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.atk = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.def = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//战斗</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.atk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.def = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存角色状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">saveState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RoleStateMemento(vit, atk, def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回复角色状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverState</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        RoleStateMemento roleStateMemento = (RoleStateMemento) memento;</span><br><span class="line">        <span class="keyword">this</span>.vit = roleStateMemento.getVit();</span><br><span class="line">        <span class="keyword">this</span>.atk = roleStateMemento.getAtk();</span><br><span class="line">        <span class="keyword">this</span>.def = roleStateMemento.getDef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;角色生命力：&quot;</span> + vit);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色攻击力：&quot;</span> + atk);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色防御力：&quot;</span> + def);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVit</span><span class="params">(<span class="keyword">int</span> vit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAtk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAtk</span><span class="params">(<span class="keyword">int</span> atk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.atk = atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDef</span><span class="params">(<span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleStateMemento</span> <span class="keyword">implements</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> vit;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> atk;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> def;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RoleStateMemento</span><span class="params">(<span class="keyword">int</span> vit, <span class="keyword">int</span> atk, <span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.vit = vit;</span><br><span class="line">            <span class="keyword">this</span>.atk = atk;</span><br><span class="line">            <span class="keyword">this</span>.def = def;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> vit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVit</span><span class="params">(<span class="keyword">int</span> vit)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.vit = vit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAtk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> atk;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAtk</span><span class="params">(<span class="keyword">int</span> atk)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.atk = atk;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> def;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDef</span><span class="params">(<span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.def = def;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>负责人角色类 <code>RoleStateCaretaker</code> 能够得到的备忘录对象是以 <code>Memento</code> 为接口的，由于这个接口仅仅是一个标识接口，因此负责人角色不可能改变这个备忘录对象的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//角色状态管理者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleStateCaretaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss前------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss前</span></span><br><span class="line">        GameRole gameRole = <span class="keyword">new</span> GameRole();</span><br><span class="line">        gameRole.initState();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存进度</span></span><br><span class="line">        RoleStateCaretaker roleStateCaretaker = <span class="keyword">new</span> RoleStateCaretaker();</span><br><span class="line">        roleStateCaretaker.setMemento(gameRole.saveState());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss后------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss时，损耗严重</span></span><br><span class="line">        gameRole.fight();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------恢复之前状态------------&quot;</span>);</span><br><span class="line">        <span class="comment">//恢复之前状态</span></span><br><span class="line">        gameRole.recoverState(roleStateCaretaker.getMemento());</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="6-10-4-优缺点"><a href="#6-10-4-优缺点" class="headerlink" title="6.10.4 优缺点"></a>6.10.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li>
<li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li>
<li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li>
</ul>
<h3 id="6-10-5-使用场景"><a href="#6-10-5-使用场景" class="headerlink" title="6.10.5 使用场景"></a>6.10.5 使用场景</h3><ul>
<li><p>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</p>
</li>
<li><p>需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，idea等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</p>
</li>
</ul>
<h2 id="6-11-解释器模式"><a href="#6-11-解释器模式" class="headerlink" title="6.11 解释器模式"></a>6.11 解释器模式</h2><h3 id="6-11-1-概述"><a href="#6-11-1-概述" class="headerlink" title="6.11.1 概述"></a>6.11.1 概述</h3><p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326110311.png" alt="image-20210326110310258"></p>
<p>如上图，设计一个软件用来进行加减计算。我们第一想法就是使用工具类，提供对应的加法和减法的工具方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于两个整数相加</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于两个整数相加</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于n个整数相加</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Integer ... arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : arr) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的形式比较单一、有限，如果形式变化非常多，这就不符合要求，因为加法和减法运算，两个运算符与数值可以有无限种组合方式。比如 1+2+3+4+5、1+2+3-4等等。   </p>
<p>显然，现在需要一种翻译识别机器，能够解析由数字以及 + - 符号构成的合法的运算序列。如果把运算符和数字都看作节点的话，能够逐个节点的进行读取解析运算，这就是解释器模式的思维。</p>
<p><strong>定义：</strong></p>
<blockquote>
<p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
</blockquote>
<p>在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种“语言”。比如加减法运算，规则为：由数值和+-符号组成的合法序列，“1+3-2” 就是这种语言的句子。</p>
<p>解释器就是要解析出来语句的含义。但是如何描述规则呢？</p>
<p><strong>文法（语法）规则：</strong></p>
<p>文法是用于描述语言的语法结构的形式规则。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expression ::&#x3D; value | plus | minus</span><br><span class="line">plus ::&#x3D; expression ‘+’ expression   </span><br><span class="line">minus ::&#x3D; expression ‘-’ expression  </span><br><span class="line">value ::&#x3D; integer</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： 这里的符号“::=”表示“定义为”的意思，竖线 | 表示或，左右的其中一个，引号内为字符本身，引号外为语法。</p>
</blockquote>
<p>上面规则描述为 ：</p>
<p>表达式可以是一个值，也可以是plus或者minus运算，而plus和minus又是由表达式结合运算符构成，值的类型为整型数。</p>
<p><strong>抽象语法树：</strong></p>
<p>在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p>
<p>用树形来表示符合文法规则的句子。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326110322.png" alt="image-20210326110321377"></p>
<h3 id="6-11-2-结构"><a href="#6-11-2-结构" class="headerlink" title="6.11.2 结构"></a>6.11.2 结构</h3><p>解释器模式包含以下主要角色。</p>
<ul>
<li><p>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</p>
</li>
<li><p>终结符表达式（Terminal  Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</p>
</li>
<li><p>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</p>
</li>
<li><p>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</p>
</li>
<li><p>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</p>
</li>
</ul>
<h3 id="6-11-3-案例实现"><a href="#6-11-3-案例实现" class="headerlink" title="6.11.3 案例实现"></a>6.11.3 案例实现</h3><p>【例】设计实现加减法的软件</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326110332.png" alt="image-20210326110331144"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象角色AbstractExpression</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//终结符表达式角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Value</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(value).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非终结符表达式角色  加法表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plus</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression left;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plus</span><span class="params">(AbstractExpression left, AbstractExpression right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret(context) + right.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + left.toString() + <span class="string">&quot; + &quot;</span> + right.toString() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///非终结符表达式角色 减法表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minus</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression left;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Minus</span><span class="params">(AbstractExpression left, AbstractExpression right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret(context) - right.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + left.toString() + <span class="string">&quot; - &quot;</span> + right.toString() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//终结符表达式角色 变量表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Variable</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.getValue(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Variable, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Variable, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(Variable <span class="keyword">var</span>, Integer value)</span> </span>&#123;</span><br><span class="line">        map.put(<span class="keyword">var</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(Variable <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        Integer value = map.get(<span class="keyword">var</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line"></span><br><span class="line">        Variable a = <span class="keyword">new</span> Variable(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Variable b = <span class="keyword">new</span> Variable(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        Variable c = <span class="keyword">new</span> Variable(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        Variable d = <span class="keyword">new</span> Variable(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        Variable e = <span class="keyword">new</span> Variable(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">        <span class="comment">//Value v = new Value(1);</span></span><br><span class="line"></span><br><span class="line">        context.assign(a, <span class="number">1</span>);</span><br><span class="line">        context.assign(b, <span class="number">2</span>);</span><br><span class="line">        context.assign(c, <span class="number">3</span>);</span><br><span class="line">        context.assign(d, <span class="number">4</span>);</span><br><span class="line">        context.assign(e, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        AbstractExpression expression = <span class="keyword">new</span> Minus(<span class="keyword">new</span> Plus(<span class="keyword">new</span> Plus(<span class="keyword">new</span> Plus(a, b), c), d), e);</span><br><span class="line"></span><br><span class="line">        System.out.println(expression + <span class="string">&quot;= &quot;</span> + expression.interpret(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="6-11-4-优缺点"><a href="#6-11-4-优缺点" class="headerlink" title="6.11.4 优缺点"></a>6.11.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li><p>易于改变和扩展文法。</p>
<p>由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。</p>
</li>
<li><p>实现文法较为容易。</p>
<p>在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂。</p>
</li>
<li><p>增加新的解释表达式较为方便。</p>
<p>如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合 “开闭原则”。</p>
</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li><p>对于复杂文法难以维护。</p>
<p>在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护。</p>
</li>
</ul>
<ul>
<li><p>执行效率较低。</p>
<p>由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。</p>
</li>
</ul>
<h3 id="6-11-5-使用场景"><a href="#6-11-5-使用场景" class="headerlink" title="6.11.5 使用场景"></a>6.11.5 使用场景</h3><ul>
<li><p>当语言的文法较为简单，且执行效率不是关键问题时。</p>
</li>
<li><p>当问题重复出现，且可以用一种简单的语言来进行表达时。</p>
</li>
<li><p>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候。</p>
</li>
</ul>
<h1 id="7，自定义Spring框架"><a href="#7，自定义Spring框架" class="headerlink" title="7，自定义Spring框架"></a>7，自定义Spring框架</h1><h2 id="7-1-spring使用回顾"><a href="#7-1-spring使用回顾" class="headerlink" title="7.1 spring使用回顾"></a>7.1 spring使用回顾</h2><p>自定义spring框架前，先回顾一下spring框架的使用，从而分析spring的核心，并对核心功能进行模拟。</p>
<ul>
<li><p>数据访问层。定义UserDao接口及其子实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;userDaoImpl ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>业务逻辑层。定义UserService接口及其子实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;userServiceImpl ...&quot;</span>);</span><br><span class="line">        userDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义UserController类，使用main方法模拟controller层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建spring容器对象</span></span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//从IOC容器中获取UserService对象</span></span><br><span class="line">        UserService userService = applicationContext.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">        <span class="comment">//调用UserService对象的add方法</span></span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写配置文件。在类路径下编写一个名为ApplicationContext.xml的配置文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span><br><span class="line">        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>代码运行结果如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326110350.png" alt="image-20210326110349694"></p>
</li>
</ul>
<p>通过上面代码及结果可以看出：</p>
<ul>
<li>userService对象是从applicationContext容器对象获取到的，也就是userService对象交由spring进行管理。</li>
<li>上面结果可以看到调用了UserDao对象中的add方法，也就是说UserDao子实现类对象也交由spring管理了。</li>
<li>UserService中的userDao变量我们并没有进行赋值，但是可以正常使用，说明spring已经将UserDao对象赋值给了userDao变量。</li>
</ul>
<p>上面三点体现了Spring框架的IOC（Inversion of Control）和DI（Dependency Injection, DI）</p>
<h2 id="7-2-spring核心功能结构"><a href="#7-2-spring核心功能结构" class="headerlink" title="7.2 spring核心功能结构"></a>7.2 spring核心功能结构</h2><p>Spring大约有20个模块，由1300多个不同的文件构成。这些模块可以分为:</p>
<p>核心容器、AOP和设备支持、数据访问与集成、Web组件、通信报文和集成测试等，下面是 Spring 框架的总体架构图：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326110400.png" alt="image-20210326110359204"></p>
<p>核心容器由 beans、core、context 和 expression（Spring Expression Language，SpEL）4个模块组成。</p>
<ul>
<li>spring-beans和spring-core模块是Spring框架的核心模块，包含了控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）。BeanFactory使用控制反转对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。BeanFactory属于延时加载，也就是说在实例化容器对象后并不会自动实例化Bean，只有当Bean被使用时，BeanFactory才会对该 Bean 进行实例化与依赖关系的装配。</li>
<li>spring-context模块构架于核心模块之上，扩展了BeanFactory，为它添加了Bean生命周期控制、框架事件体系及资源加载透明化等功能。此外，该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，ApplicationContext 是该模块的核心接口，它的超类是 BeanFactory。与BeanFactory不同，ApplicationContext实例化后会自动对所有的单实例Bean进行实例化与依赖关系的装配，使之处于待用状态。</li>
<li>spring-context-support模块是对Spring IoC容器及IoC子容器的扩展支持。</li>
<li>spring-context-indexer模块是Spring的类管理组件和Classpath扫描组件。</li>
<li>spring-expression 模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也可以方便地调用对象方法，以及操作数组、集合等。它的语法类似于传统EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。EL的特性是基于Spring产品的需求而设计的，可以非常方便地同Spring IoC进行交互。</li>
</ul>
<h3 id="7-1-1-bean概述"><a href="#7-1-1-bean概述" class="headerlink" title="7.1.1 bean概述"></a>7.1.1 bean概述</h3><p>Spring 就是面向 <code>Bean</code> 的编程（BOP,Bean Oriented Programming），Bean 在 Spring 中处于核心地位。Bean对于Spring的意义就像Object对于OOP的意义一样，Spring中没有Bean也就没有Spring存在的意义。Spring IoC容器通过配置文件或者注解的方式来管理bean对象之间的依赖关系。</p>
<p>spring中bean用于对一个类进行封装。如下面的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为什么Bean如此重要呢？</p>
<ul>
<li>spring 将bean对象交由一个叫IOC容器进行管理。</li>
<li>bean对象之间的依赖关系在配置文件中体现，并由spring完成。</li>
</ul>
<h2 id="7-3-Spring-IOC相关接口分析"><a href="#7-3-Spring-IOC相关接口分析" class="headerlink" title="7.3 Spring IOC相关接口分析"></a>7.3 Spring IOC相关接口分析</h2><h3 id="7-3-1-BeanFactory解析"><a href="#7-3-1-BeanFactory解析" class="headerlink" title="7.3.1 BeanFactory解析"></a>7.3.1 BeanFactory解析</h3><p>Spring中Bean的创建是典型的工厂模式，这一系列的Bean工厂，即IoC容器，为开发者管理对象之间的依赖关系提供了很多便利和基础服务，在Spring中有许多IoC容器的实现供用户选择，其相互关系如下图所示。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326110413.png" alt="image-20210326110412458"></p>
<p>其中，BeanFactory作为最顶层的一个接口，定义了IoC容器的基本功能规范，BeanFactory有三个重要的子接口：ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBeanFactory。但是从类图中我们可以发现最终的默认实现类是DefaultListableBeanFactory，它实现了所有的接口。</p>
<p>那么为何要定义这么多层次的接口呢？</p>
<p>每个接口都有它的使用场合，主要是为了区分在Spring内部操作过程中对象的传递和转化，对对象的数据访问所做的限制。例如，</p>
<ul>
<li>ListableBeanFactory接口表示这些Bean可列表化。</li>
<li>HierarchicalBeanFactory表示这些Bean 是有继承关系的，也就是每个 Bean 可能有父 Bean</li>
<li>AutowireCapableBeanFactory 接口定义Bean的自动装配规则。</li>
</ul>
<p>这三个接口共同定义了Bean的集合、Bean之间的关系及Bean行为。最基本的IoC容器接口是BeanFactory，来看一下它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据bean的名称获取IOC容器中的的bean对象</span></span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	<span class="comment">//根据bean的名称获取IOC容器中的的bean对象，并指定获取到的bean对象的类型，这样我们使用时就不需要进行类型强转了</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	</span><br><span class="line">	&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class="line">	&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断容器中是否包含指定名称的bean对象</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line">	<span class="comment">//根据bean的名称判断是否是单例</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">	String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在BeanFactory里只对IoC容器的基本行为做了定义，根本不关心你的Bean是如何定义及怎样加载的。正如我们只关心能从工厂里得到什么产品，不关心工厂是怎么生产这些产品的。</p>
<p>BeanFactory有一个很重要的子接口，就是ApplicationContext接口，该接口主要来规范容器中的bean对象是非延时加载，即在创建容器对象的时候就对象bean进行初始化，并存储到一个容器中。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326110425.png" alt="image-20210326110423935"></p>
<p>要知道工厂是如何产生对象的，我们需要看具体的IoC容器实现，Spring提供了许多IoC容器实现，比如：</p>
<ul>
<li>ClasspathXmlApplicationContext : 根据类路径加载xml配置文件，并创建IOC容器对象。</li>
<li>FileSystemXmlApplicationContext ：根据系统路径加载xml配置文件，并创建IOC容器对象。</li>
<li>AnnotationConfigApplicationContext ：加载注解类配置，并创建IOC容器。</li>
</ul>
<h3 id="7-3-2-BeanDefinition解析"><a href="#7-3-2-BeanDefinition解析" class="headerlink" title="7.3.2 BeanDefinition解析"></a>7.3.2 BeanDefinition解析</h3><p>Spring IoC容器管理我们定义的各种Bean对象及其相互关系，而Bean对象在Spring实现中是以BeanDefinition来描述的，如下面配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">bean标签还有很多属性：</span><br><span class="line">	scope、init-method、destory-method等。</span><br></pre></td></tr></table></figure>
<p>其继承体系如下图所示。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326110438.png" alt="image-20210326110436353"></p>
<h3 id="7-3-3-BeanDefinitionReader解析"><a href="#7-3-3-BeanDefinitionReader解析" class="headerlink" title="7.3.3 BeanDefinitionReader解析"></a>7.3.3 BeanDefinitionReader解析</h3><p>Bean的解析过程非常复杂，功能被分得很细，因为这里需要被扩展的地方很多，必须保证足够的灵活性，以应对可能的变化。Bean的解析主要就是对Spring配置文件的解析。这个解析过程主要通过BeanDefinitionReader来完成，看看Spring中BeanDefinitionReader的类结构图，如下图所示。</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326110451.png" alt="image-20210326110450227"></p>
<p>看看BeanDefinitionReader接口定义的功能来理解它具体的作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取BeanDefinitionRegistry注册器对象</span></span><br><span class="line">	<span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">ClassLoader <span class="title">getBeanClassLoader</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">BeanNameGenerator <span class="title">getBeanNameGenerator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		下面的loadBeanDefinitions都是加载bean定义，从指定的资源中</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="7-3-4-BeanDefinitionRegistry解析"><a href="#7-3-4-BeanDefinitionRegistry解析" class="headerlink" title="7.3.4 BeanDefinitionRegistry解析"></a>7.3.4 BeanDefinitionRegistry解析</h3><p>BeanDefinitionReader用来解析bean定义，并封装BeanDefinition对象，而我们定义的配置文件中定义了很多bean标签，所以就有一个问题，解析的BeanDefinition对象存储到哪儿？答案就是BeanDefinition的注册中心，而该注册中心顶层接口就是BeanDefinitionRegistry。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">AliasRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//往注册表中注册bean</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从注册表中删除指定名称的bean</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取注册表中指定名称的bean</span></span><br><span class="line">	<span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//判断注册表中是否已经注册了指定名称的bean</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//获取注册表中所有的bean的名称</span></span><br><span class="line">	String[] getBeanDefinitionNames();</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承结构图如下：</p>
<p><img src="https://gitee.com/Pink_oops/image/raw/master/20210326110508.png" alt="image-20210326110507190"></p>
<p>从上面类图可以看到BeanDefinitionRegistry接口的子实现类主要有以下几个：</p>
<ul>
<li><p>DefaultListableBeanFactory</p>
<p>在该类中定义了如下代码，就是用来注册bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>SimpleBeanDefinitionRegistry</p>
<p>在该类中定义了如下代码，就是用来注册bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="7-3-5-创建容器"><a href="#7-3-5-创建容器" class="headerlink" title="7.3.5 创建容器"></a>7.3.5 创建容器</h3><p>ClassPathXmlApplicationContext对Bean配置资源的载入是从refresh（）方法开始的。refresh（）方法是一个模板方法，规定了 IoC 容器的启动流程，有些逻辑要交给其子类实现。它对 Bean 配置资源进行载入，ClassPathXmlApplicationContext通过调用其父类AbstractApplicationContext的refresh（）方法启动整个IoC容器对Bean定义的载入过程。</p>
<h2 id="7-4-自定义SpringIOC"><a href="#7-4-自定义SpringIOC" class="headerlink" title="7.4 自定义SpringIOC"></a>7.4 自定义SpringIOC</h2><p>现要对下面的配置文件进行解析，并自定义Spring框架的IOC对涉及到的对象进行管理。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="7-4-1-定义bean相关的pojo类"><a href="#7-4-1-定义bean相关的pojo类" class="headerlink" title="7.4.1 定义bean相关的pojo类"></a>7.4.1 定义bean相关的pojo类</h3><h4 id="7-4-1-1-PropertyValue类"><a href="#7-4-1-1-PropertyValue类" class="headerlink" title="7.4.1.1 PropertyValue类"></a>7.4.1.1 PropertyValue类</h4><p>用于封装bean的属性，体现到上面的配置文件就是封装bean标签的子标签property标签数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String ref;</span><br><span class="line">  <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PropertyValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PropertyValue</span><span class="params">(String name, String ref,String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.ref = ref;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ref;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRef</span><span class="params">(String ref)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ref = ref;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="7-4-1-2-MutablePropertyValues类"><a href="#7-4-1-2-MutablePropertyValues类" class="headerlink" title="7.4.1.2 MutablePropertyValues类"></a>7.4.1.2 MutablePropertyValues类</h4><p>一个bean标签可以有多个property子标签，所以再定义一个MutablePropertyValues类，用来存储并管理多个PropertyValue对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutablePropertyValues</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">PropertyValue</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PropertyValue&gt; propertyValueList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutablePropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.propertyValueList = <span class="keyword">new</span> ArrayList&lt;PropertyValue&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutablePropertyValues</span><span class="params">(List&lt;PropertyValue&gt; propertyValueList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.propertyValueList = (propertyValueList != <span class="keyword">null</span> ? propertyValueList : <span class="keyword">new</span> ArrayList&lt;PropertyValue&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PropertyValue[] getPropertyValues() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.propertyValueList.toArray(<span class="keyword">new</span> PropertyValue[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyValue <span class="title">getPropertyValue</span><span class="params">(String propertyName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (PropertyValue pv : <span class="keyword">this</span>.propertyValueList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pv.getName().equals(propertyName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pv;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;PropertyValue&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> propertyValueList.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.propertyValueList.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutablePropertyValues <span class="title">addPropertyValue</span><span class="params">(PropertyValue pv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.propertyValueList.size(); i++) &#123;</span><br><span class="line">            PropertyValue currentPv = <span class="keyword">this</span>.propertyValueList.get(i);</span><br><span class="line">            <span class="keyword">if</span> (currentPv.getName().equals(pv.getName())) &#123;</span><br><span class="line">                <span class="keyword">this</span>.propertyValueList.set(i, <span class="keyword">new</span> PropertyValue(pv.getName(),pv.getRef(), pv.getValue()));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.propertyValueList.add(pv);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String propertyName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPropertyValue(propertyName) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="7-4-1-3-BeanDefinition类"><a href="#7-4-1-3-BeanDefinition类" class="headerlink" title="7.4.1.3 BeanDefinition类"></a>7.4.1.3 BeanDefinition类</h4><p>BeanDefinition类用来封装bean信息的，主要包含id（即bean对象的名称）、class（需要交由spring管理的类的全类名）及子标签property数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MutablePropertyValues propertyValues;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        propertyValues = <span class="keyword">new</span> MutablePropertyValues();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValues</span><span class="params">(MutablePropertyValues propertyValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.propertyValues = propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="7-4-2-定义注册表相关类"><a href="#7-4-2-定义注册表相关类" class="headerlink" title="7.4.2 定义注册表相关类"></a>7.4.2 定义注册表相关类</h3><h4 id="7-4-2-1-BeanDefinitionRegistry接口"><a href="#7-4-2-1-BeanDefinitionRegistry接口" class="headerlink" title="7.4.2.1 BeanDefinitionRegistry接口"></a>7.4.2.1 BeanDefinitionRegistry接口</h4><p>BeanDefinitionRegistry接口定义了注册表的相关操作，定义如下功能：</p>
<ul>
<li>注册BeanDefinition对象到注册表中</li>
<li>从注册表中删除指定名称的BeanDefinition对象</li>
<li>根据名称从注册表中获取BeanDefinition对象</li>
<li>判断注册表中是否包含指定名称的BeanDefinition对象</li>
<li>获取注册表中BeanDefinition对象的个数</li>
<li>获取注册表中所有的BeanDefinition的名称</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册BeanDefinition对象到注册表中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从注册表中删除指定名称的BeanDefinition对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据名称从注册表中获取BeanDefinition对象</span></span><br><span class="line">    <span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    String[] getBeanDefinitionNames();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="7-4-2-2-SimpleBeanDefinitionRegistry类"><a href="#7-4-2-2-SimpleBeanDefinitionRegistry类" class="headerlink" title="7.4.2.2 SimpleBeanDefinitionRegistry类"></a>7.4.2.2 SimpleBeanDefinitionRegistry类</h4><p>该类实现了BeanDefinitionRegistry接口，定义了Map集合作为注册表容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBeanDefinitionRegistry</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> HashMap&lt;String, BeanDefinition&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        beanDefinitionMap.put(beanName,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        beanDefinitionMap.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.containsKey(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanDefinitionNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.keySet().toArray(<span class="keyword">new</span> String[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="7-4-3-定义解析器相关类"><a href="#7-4-3-定义解析器相关类" class="headerlink" title="7.4.3 定义解析器相关类"></a>7.4.3 定义解析器相关类</h3><h4 id="7-4-3-1-BeanDefinitionReader接口"><a href="#7-4-3-1-BeanDefinitionReader接口" class="headerlink" title="7.4.3.1 BeanDefinitionReader接口"></a>7.4.3.1 BeanDefinitionReader接口</h4><p>BeanDefinitionReader是用来解析配置文件并在注册表中注册bean的信息。定义了两个规范：</p>
<ul>
<li>获取注册表的功能，让外界可以通过该对象获取注册表对象。</li>
<li>加载配置文件，并注册bean数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取注册表对象</span></span><br><span class="line">    <span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//加载配置文件并在注册表中进行注册</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="7-4-3-2-XmlBeanDefinitionReader类"><a href="#7-4-3-2-XmlBeanDefinitionReader类" class="headerlink" title="7.4.3.2 XmlBeanDefinitionReader类"></a>7.4.3.2 XmlBeanDefinitionReader类</h4><p>XmlBeanDefinitionReader类是专门用来解析xml配置文件的。该类实现BeanDefinitionReader接口并实现接口中的两个功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanDefinitionRegistry registry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registry = <span class="keyword">new</span> SimpleBeanDefinitionRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        InputStream is = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(configLocation);</span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        Document document = reader.read(is);</span><br><span class="line">        Element rootElement = document.getRootElement();</span><br><span class="line">        <span class="comment">//解析bean标签</span></span><br><span class="line">        parseBean(rootElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseBean</span><span class="params">(Element rootElement)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Element&gt; elements = rootElement.elements();</span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            String id = element.attributeValue(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            String className = element.attributeValue(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">            BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">            beanDefinition.setId(id);</span><br><span class="line">            beanDefinition.setClassName(className);</span><br><span class="line">            List&lt;Element&gt; list = element.elements(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">            MutablePropertyValues mutablePropertyValues = <span class="keyword">new</span> MutablePropertyValues();</span><br><span class="line">            <span class="keyword">for</span> (Element element1 : list) &#123;</span><br><span class="line">                String name = element1.attributeValue(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                String ref = element1.attributeValue(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">                String value = element1.attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                PropertyValue propertyValue = <span class="keyword">new</span> PropertyValue(name,ref,value);</span><br><span class="line">                mutablePropertyValues.addPropertyValue(propertyValue);</span><br><span class="line">            &#125;</span><br><span class="line">            beanDefinition.setPropertyValues(mutablePropertyValues);</span><br><span class="line"></span><br><span class="line">            registry.registerBeanDefinition(id,beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="7-4-4-IOC容器相关类"><a href="#7-4-4-IOC容器相关类" class="headerlink" title="7.4.4 IOC容器相关类"></a>7.4.4 IOC容器相关类</h3><h4 id="7-4-4-1-BeanFactory接口"><a href="#7-4-4-1-BeanFactory接口" class="headerlink" title="7.4.4.1 BeanFactory接口"></a>7.4.4.1 BeanFactory接口</h4><p>在该接口中定义IOC容器的统一规范即获取bean对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//根据bean对象的名称获取bean对象</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="comment">//根据bean对象的名称获取bean对象，并进行类型转换</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;? extends T&gt; clazz)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="7-4-4-2-ApplicationContext接口"><a href="#7-4-4-2-ApplicationContext接口" class="headerlink" title="7.4.4.2 ApplicationContext接口"></a>7.4.4.2 ApplicationContext接口</h4><p>该接口的所以的子实现类对bean对象的创建都是非延时的，所以在该接口中定义 <code>refresh()</code> 方法，该方法主要完成以下两个功能：</p>
<ul>
<li>加载配置文件。</li>
<li>根据注册表中的BeanDefinition对象封装的数据进行bean对象的创建。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//进行配置文件加载并进行对象创建</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException, Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="7-4-4-3-AbstractApplicationContext类"><a href="#7-4-4-3-AbstractApplicationContext类" class="headerlink" title="7.4.4.3 AbstractApplicationContext类"></a>7.4.4.3 AbstractApplicationContext类</h4><ul>
<li><p>作为ApplicationContext接口的子类，所以该类也是非延时加载，所以需要在该类中定义一个Map集合，作为bean对象存储的容器。</p>
</li>
<li><p>声明BeanDefinitionReader类型的变量，用来进行xml配置文件的解析，符合单一职责原则。</p>
<p>BeanDefinitionReader类型的对象创建交由子类实现，因为只有子类明确到底创建BeanDefinitionReader哪儿个子实现类对象。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> BeanDefinitionReader beanDefinitionReader;</span><br><span class="line">    <span class="comment">//用来存储bean对象的容器   key存储的是bean的id值，value存储的是bean对象</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储配置文件的路径</span></span><br><span class="line">    <span class="keyword">protected</span> String configLocation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException, Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载BeanDefinition</span></span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(configLocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化bean</span></span><br><span class="line">        finishBeanInitialization();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bean的初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishBeanInitialization</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry();</span><br><span class="line">        String[] beanNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            BeanDefinition beanDefinition = registry.getBeanDefinition(beanName);</span><br><span class="line">            getBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：该类finishBeanInitialization()方法中调用getBean()方法使用到了模板方法模式。</p>
</blockquote>
<h4 id="7-4-4-4-ClassPathXmlApplicationContext类"><a href="#7-4-4-4-ClassPathXmlApplicationContext类" class="headerlink" title="7.4.4.4 ClassPathXmlApplicationContext类"></a>7.4.4.4 ClassPathXmlApplicationContext类</h4><p>该类主要是加载类路径下的配置文件，并进行bean对象的创建，主要完成以下功能：</p>
<ul>
<li>在构造方法中，创建BeanDefinitionReader对象。</li>
<li>在构造方法中，调用refresh()方法，用于进行配置文件加载、创建bean对象并存储到容器中。</li>
<li>重写父接口中的getBean()方法，并实现依赖注入操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configLocation = configLocation;</span><br><span class="line">        <span class="comment">//构建XmlBeanDefinitionReader对象</span></span><br><span class="line">        beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.refresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据bean的id属性值获取bean对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//return singletonObjects.get(name);</span></span><br><span class="line">        Object obj = singletonObjects.get(name);</span><br><span class="line">        <span class="keyword">if</span>(obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry();</span><br><span class="line">        BeanDefinition beanDefinition = registry.getBeanDefinition(name);</span><br><span class="line">        <span class="keyword">if</span>(beanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String className = beanDefinition.getClassName();</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">        Object beanObj = clazz.newInstance();</span><br><span class="line">        MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();</span><br><span class="line">        <span class="keyword">for</span> (PropertyValue propertyValue : propertyValues) &#123;</span><br><span class="line">            String propertyName = propertyValue.getName();</span><br><span class="line">            String value = propertyValue.getValue();</span><br><span class="line">            String ref = propertyValue.getRef();</span><br><span class="line">            <span class="keyword">if</span>(ref != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(ref)) &#123;</span><br><span class="line"></span><br><span class="line">                Object bean = getBean(ref);</span><br><span class="line">                String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName);</span><br><span class="line">                Method[] methods = clazz.getMethods();</span><br><span class="line">                <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(method.getName().equals(methodName)) &#123;</span><br><span class="line">                        method.invoke(beanObj,bean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(value != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(value)) &#123;</span><br><span class="line">                String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName);</span><br><span class="line">                Method method = clazz.getMethod(methodName, String.class);</span><br><span class="line">                method.invoke(beanObj,value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        singletonObjects.put(name,beanObj);</span><br><span class="line">        <span class="keyword">return</span> beanObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;? extends T&gt; clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object bean = getBean(name);</span><br><span class="line">        <span class="keyword">if</span>(bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz.cast(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="7-4-5-自定义Spring-IOC总结"><a href="#7-4-5-自定义Spring-IOC总结" class="headerlink" title="7.4.5 自定义Spring IOC总结"></a>7.4.5 自定义Spring IOC总结</h3><h4 id="7-4-5-1-使用到的设计模式"><a href="#7-4-5-1-使用到的设计模式" class="headerlink" title="7.4.5.1 使用到的设计模式"></a>7.4.5.1 使用到的设计模式</h4><ul>
<li>工厂模式。这个使用工厂模式 + 配置文件的方式。</li>
<li>单例模式。Spring IOC管理的bean对象都是单例的，此处的单例不是通过构造器进行单例的控制的，而是spring框架对每一个bean只创建了一个对象。</li>
<li>模板方法模式。AbstractApplicationContext类中的finishBeanInitialization()方法调用了子类的getBean()方法，因为getBean()的实现和环境息息相关。</li>
<li>迭代器模式。对于MutablePropertyValues类定义使用到了迭代器模式，因为此类存储并管理PropertyValue对象，也属于一个容器，所以给该容器提供一个遍历方式。</li>
</ul>
<p>spring框架其实使用到了很多设计模式，如AOP使用到了代理模式，选择JDK代理或者CGLIB代理使用到了策略模式，还有适配器模式，装饰者模式，观察者模式等。</p>
<h4 id="7-4-5-2-符合大部分设计原则"><a href="#7-4-5-2-符合大部分设计原则" class="headerlink" title="7.4.5.2 符合大部分设计原则"></a>7.4.5.2 符合大部分设计原则</h4><h4 id="7-4-5-3-整个设计和Spring的设计还是有一定的出入"><a href="#7-4-5-3-整个设计和Spring的设计还是有一定的出入" class="headerlink" title="7.4.5.3 整个设计和Spring的设计还是有一定的出入"></a>7.4.5.3 整个设计和Spring的设计还是有一定的出入</h4><p>spring框架底层是很复杂的，进行了很深入的封装，并对外提供了很好的扩展性。而我们自定义SpringIOC有以下几个目的：</p>
<ul>
<li>了解Spring底层对对象的大体管理机制。</li>
<li>了解设计模式在具体的开发中的使用。</li>
<li>以后学习spring源码，通过该案例的实现，可以降低spring学习的入门成本。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
